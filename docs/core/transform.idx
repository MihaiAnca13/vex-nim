nimTitle	transform	core/transform.html	module src/vex/core/transform		0
nim	transformPoint	core/transform.html#transformPoint,Mat3,Vec2	proc transformPoint(m: Mat3; p: Vec2): Vec2		5
nim	transformPointInverse	core/transform.html#transformPointInverse,Mat3,Vec2	proc transformPointInverse(m: Mat3; p: Vec2): Vec2		9
nim	localToGlobal	core/transform.html#localToGlobal,Node,Vec2	proc localToGlobal(node: Node; localPoint: Vec2): Vec2		13
nim	globalToLocal	core/transform.html#globalToLocal,Node,Vec2	proc globalToLocal(node: Node; globalPoint: Vec2): Vec2		16
nim	transformRect	core/transform.html#transformRect,Mat3,Rect	proc transformRect(m: Mat3; r: Rect): Rect		19
nim	getGlobalBounds	core/transform.html#getGlobalBounds,Node	proc getGlobalBounds(node: Node): Rect		32
nim	getWorldPosition	core/transform.html#getWorldPosition,Node	proc getWorldPosition(node: Node): Vec2		36
nim	getWorldScale	core/transform.html#getWorldScale,Node	proc getWorldScale(node: Node): Vec2		40
nim	getWorldRotation	core/transform.html#getWorldRotation,Node	proc getWorldRotation(node: Node): float32		46
nim	isTransformEqual	core/transform.html#isTransformEqual,Mat3,Mat3,float	proc isTransformEqual(a, b: Mat3; tolerance = 0.0001): bool		50
nim	decomposeTransform	core/transform.html#decomposeTransform,Mat3	proc decomposeTransform(m: Mat3): tuple[pos: Vec2, scale: Vec2, rotation: float32]		57
nim	combineTransforms	core/transform.html#combineTransforms,Mat3,Mat3	proc combineTransforms(parent, child: Mat3): Mat3		64
nim	invertTransform	core/transform.html#invertTransform,Mat3	proc invertTransform(m: Mat3): Mat3		67
nim	lerpTransform	core/transform.html#lerpTransform,Mat3,Mat3,float32	proc lerpTransform(a, b: Mat3; t: float32): Mat3		70
