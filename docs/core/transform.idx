nimTitle	transform	core/transform.html	module vex/core/transform		0
nim	transformPoint	core/transform.html#transformPoint,Mat3,Vec2	proc transformPoint(m: Mat3; p: Vec2): Vec2		11
nim	transformPointInverse	core/transform.html#transformPointInverse,Mat3,Vec2	proc transformPointInverse(m: Mat3; p: Vec2): Vec2		17
nim	localToGlobal	core/transform.html#localToGlobal,Node,Vec2	proc localToGlobal(node: Node; localPoint: Vec2): Vec2		22
nim	globalToLocal	core/transform.html#globalToLocal,Node,Vec2	proc globalToLocal(node: Node; globalPoint: Vec2): Vec2		26
nim	transformRect	core/transform.html#transformRect,Mat3,Rect	proc transformRect(m: Mat3; r: Rect): Rect		32
nim	getGlobalBounds	core/transform.html#getGlobalBounds,Node	proc getGlobalBounds(node: Node): Rect		46
nim	getLocalBounds	core/transform.html#getLocalBounds,Node	proc getLocalBounds(node: Node): Rect		50
nim	getLocalBoundsCenter	core/transform.html#getLocalBoundsCenter,Node	proc getLocalBoundsCenter(node: Node): Vec2		75
nim	getWorldPosition	core/transform.html#getWorldPosition,Node	proc getWorldPosition(node: Node): Vec2		80
nim	getWorldScale	core/transform.html#getWorldScale,Node	proc getWorldScale(node: Node): Vec2		85
nim	getWorldRotation	core/transform.html#getWorldRotation,Node	proc getWorldRotation(node: Node): float32		92
nim	isTransformEqual	core/transform.html#isTransformEqual,Mat3,Mat3,float	proc isTransformEqual(a, b: Mat3; tolerance = 0.0001): bool		97
nim	decomposeTransform	core/transform.html#decomposeTransform,Mat3	proc decomposeTransform(m: Mat3): tuple[pos: Vec2, scale: Vec2, rotation: float32]		105
nim	combineTransforms	core/transform.html#combineTransforms,Mat3,Mat3	proc combineTransforms(parent, child: Mat3): Mat3		113
nim	invertTransform	core/transform.html#invertTransform,Mat3	proc invertTransform(m: Mat3): Mat3		117
nim	lerpTransform	core/transform.html#lerpTransform,Mat3,Mat3,float32	proc lerpTransform(a: Mat3; b: Mat3; t: float32): Mat3		122
