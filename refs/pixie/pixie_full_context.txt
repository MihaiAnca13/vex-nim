Directory structure:
â””â”€â”€ treeform-pixie/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ pixie.nimble
    â”œâ”€â”€ bindings/
    â”‚   â”œâ”€â”€ bindings.nim
    â”‚   â””â”€â”€ generated/
    â”‚       â””â”€â”€ placeholder.txt
    â”œâ”€â”€ examples/
    â”‚   â”œâ”€â”€ blur.nim
    â”‚   â”œâ”€â”€ gradient.nim
    â”‚   â”œâ”€â”€ heart.nim
    â”‚   â”œâ”€â”€ image_tiled.nim
    â”‚   â”œâ”€â”€ line.nim
    â”‚   â”œâ”€â”€ masking.nim
    â”‚   â”œâ”€â”€ rounded_rectangle.nim
    â”‚   â”œâ”€â”€ shadow.nim
    â”‚   â”œâ”€â”€ square.nim
    â”‚   â”œâ”€â”€ text.nim
    â”‚   â”œâ”€â”€ text_spans.nim
    â”‚   â””â”€â”€ tiger.nim
    â”œâ”€â”€ experiments/
    â”‚   â”œâ”€â”€ bench_cairo.nim
    â”‚   â”œâ”€â”€ bench_cairo_draw.nim
    â”‚   â”œâ”€â”€ sweeps.nim
    â”‚   â”œâ”€â”€ sweeps2.nim
    â”‚   â”œâ”€â”€ sweeps3.nim
    â”‚   â”œâ”€â”€ sweeps4.nim
    â”‚   â”œâ”€â”€ trapezoid.nim
    â”‚   â”œâ”€â”€ trapezoid0.nim
    â”‚   â””â”€â”€ trapezoid2.nim
    â”œâ”€â”€ src/
    â”‚   â”œâ”€â”€ pixie.nim
    â”‚   â””â”€â”€ pixie/
    â”‚       â”œâ”€â”€ blends.nim
    â”‚       â”œâ”€â”€ common.nim
    â”‚       â”œâ”€â”€ contexts.nim
    â”‚       â”œâ”€â”€ fonts.nim
    â”‚       â”œâ”€â”€ images.nim
    â”‚       â”œâ”€â”€ internal.nim
    â”‚       â”œâ”€â”€ paints.nim
    â”‚       â”œâ”€â”€ simd.nim
    â”‚       â”œâ”€â”€ fileformats/
    â”‚       â”‚   â”œâ”€â”€ bmp.nim
    â”‚       â”‚   â”œâ”€â”€ gif.nim
    â”‚       â”‚   â”œâ”€â”€ jpeg.nim
    â”‚       â”‚   â”œâ”€â”€ png.nim
    â”‚       â”‚   â”œâ”€â”€ ppm.nim
    â”‚       â”‚   â”œâ”€â”€ qoi.nim
    â”‚       â”‚   â”œâ”€â”€ svg.nim
    â”‚       â”‚   â””â”€â”€ tiff.nim
    â”‚       â”œâ”€â”€ fontformats/
    â”‚       â”‚   â””â”€â”€ svgfont.nim
    â”‚       â””â”€â”€ simd/
    â”‚           â”œâ”€â”€ avx.nim
    â”‚           â”œâ”€â”€ avx2.nim
    â”‚           â”œâ”€â”€ neon.nim
    â”‚           â””â”€â”€ sse2.nim
    â”œâ”€â”€ tests/
    â”‚   â”œâ”€â”€ all.nim
    â”‚   â”œâ”€â”€ bench_blends.nim
    â”‚   â”œâ”€â”€ bench_fonts.nim
    â”‚   â”œâ”€â”€ bench_gif.nim
    â”‚   â”œâ”€â”€ bench_images.nim
    â”‚   â”œâ”€â”€ bench_images_draw.nim
    â”‚   â”œâ”€â”€ bench_jpeg.nim
    â”‚   â”œâ”€â”€ bench_paints.nim
    â”‚   â”œâ”€â”€ bench_paths.nim
    â”‚   â”œâ”€â”€ bench_png.nim
    â”‚   â”œâ”€â”€ bench_qoi.nim
    â”‚   â”œâ”€â”€ bench_svg.nim
    â”‚   â”œâ”€â”€ common.nim
    â”‚   â”œâ”€â”€ config.nims
    â”‚   â”œâ”€â”€ fuzz_bmp.nim
    â”‚   â”œâ”€â”€ fuzz_gif.nim
    â”‚   â”œâ”€â”€ fuzz_image_draw.nim
    â”‚   â”œâ”€â”€ fuzz_jpeg.nim
    â”‚   â”œâ”€â”€ fuzz_leaks.nim
    â”‚   â”œâ”€â”€ fuzz_leaks2.nim
    â”‚   â”œâ”€â”€ fuzz_leaks3.nim
    â”‚   â”œâ”€â”€ fuzz_opentype.nim
    â”‚   â”œâ”€â”€ fuzz_paths.nim
    â”‚   â”œâ”€â”€ fuzz_png.nim
    â”‚   â”œâ”€â”€ fuzz_qoi.nim
    â”‚   â”œâ”€â”€ fuzz_svg.nim
    â”‚   â”œâ”€â”€ jpegsuite.nim
    â”‚   â”œâ”€â”€ megatest_emoji.nim
    â”‚   â”œâ”€â”€ megatest_fonts.nim
    â”‚   â”œâ”€â”€ megatest_icons.nim
    â”‚   â”œâ”€â”€ pngsuite.nim
    â”‚   â”œâ”€â”€ test_bmp.nim
    â”‚   â”œâ”€â”€ test_contexts.nim
    â”‚   â”œâ”€â”€ test_fonts.nim
    â”‚   â”œâ”€â”€ test_gif.nim
    â”‚   â”œâ”€â”€ test_images.nim
    â”‚   â”œâ”€â”€ test_images_draw.nim
    â”‚   â”œâ”€â”€ test_jpeg.nim
    â”‚   â”œâ”€â”€ test_paints.nim
    â”‚   â”œâ”€â”€ test_paths.nim
    â”‚   â”œâ”€â”€ test_png.nim
    â”‚   â”œâ”€â”€ test_ppm.nim
    â”‚   â”œâ”€â”€ test_qoi.nim
    â”‚   â”œâ”€â”€ test_svg.nim
    â”‚   â”œâ”€â”€ test_tiff.nim
    â”‚   â”œâ”€â”€ validate_fonts.nim
    â”‚   â”œâ”€â”€ validate_jpeg.nim
    â”‚   â”œâ”€â”€ validate_png.nim
    â”‚   â””â”€â”€ xrays.nim
    â””â”€â”€ tools/
        â””â”€â”€ gen_readme.nim

================================================
FILE: README.md
================================================
<img src="docs/banner.png">

ðŸ‘ ðŸ‘ ðŸ‘ Check out video about the library: [A full-featured 2D graphics library for Nim (NimConf 2021)](https://www.youtube.com/watch?v=8acDfUIwLnk) ðŸ‘ ðŸ‘ ðŸ‘

# Pixie - A full-featured 2D graphics library for Nim

Pixie is a 2D graphics library similar to [Cairo](https://www.cairographics.org/) and [Skia](https://skia.org) written entirely in Nim.

This library is being actively developed and we'd be happy for you to use it.

`nimble install pixie`

![Github Actions](https://github.com/treeform/pixie/workflows/Github%20Actions/badge.svg)

[API reference](https://treeform.github.io/pixie)

[Pixie Book](https://github.com/treeform/pixiebook)

### Videos

* [Pixie 5.0 performance improvements](https://www.youtube.com/watch?v=Did21OYIrGI)
* [The details of JPEG decoding in Nim](https://www.youtube.com/watch?v=vYwD7OynFcg&t=4s)
* [A full-featured 2D graphics library for Nim (NimConf 2021)](https://www.youtube.com/watch?v=8acDfUIwLnk)

Features:
* Typesetting and rasterizing text, including styled rich text via spans.
* Drawing paths, shapes and curves with even-odd and non-zero windings.
* Pixel-perfect AA quality.
* Supported file formats are PNG, BMP, JPG, SVG + more in development.
* Strokes with joins and caps.
* Shadows, glows and blurs.
* Complex masking: Subtract, Intersect, Exclude.
* Complex blends: Darken, Multiply, Color Dodge, Hue, Luminosity... etc.
* Many operations are SIMD accelerated.

### Image file formats

Format        | Read          | Write         |
------------- | ------------- | ------------- |
PNG           | âœ…           | âœ…            |
JPEG          | âœ…           |               |
BMP           | âœ…           | âœ…            |
QOI           | âœ…           | âœ…            |
GIF           | âœ…           |               |
SVG           | âœ…           |               |
PPM           | âœ…           | âœ…            |

### Font file formats

Format        | Read
------------- | -------------
TTF           | âœ…
OTF           | âœ…
SVG           | âœ…

### Joins and caps

Supported Caps:
  * Butt
  * Round
  * Square

Supported Joins:
  * Miter (with miter angle limit)
  * Bevel
  * Round

### Blending & masking

Supported Blend Modes:
  * Normal
  * Darken
  * Multiply
  * ColorBurn
  * Lighten
  * Screen
  * Color Dodge
  * Overlay
  * Soft Light
  * Hard Light
  * Difference
  * Exclusion
  * Hue
  * Saturation
  * Color
  * Luminosity

Supported Mask Modes:
  * Mask
  * Overwrite
  * Subtract Mask
  * Intersect Mask
  * Exclude Mask

### SVG style paths:

Format        | Supported     | Description           |
------------- | ------------- | --------------------- |
M m           | âœ…            | move to               |
L l           | âœ…            | line to               |
H h           | âœ…            | horizontal line to    |
V v           | âœ…            | vertical line to      |
C c S s       | âœ…            | cubic curve to        |
Q q T t       | âœ…            | quadratic curve to    |
A a           | âœ…            | arc to                |
z             | âœ…            | close path            |

### Pixie + GPU

To learn how to use Pixie for realtime graphics with GPU, check out [Boxy](https://github.com/treeform/boxy).

## Testing

`nimble test`

## Examples

`git clone https://github.com/treeform/pixie` to run examples.

### Text
nim c -r [examples/text.nim](examples/text.nim)
```nim
var font = readFont("examples/data/Roboto-Regular_1.ttf")
font.size = 20

let text = "Typesetting is the arrangement and composition of text in graphic design and publishing in both digital and traditional medias."

image.fillText(font.typeset(text, vec2(180, 180)), translate(vec2(10, 10)))
```
![example output](examples/text.png)

### Text spans
nim c -r [examples/text_spans.nim](examples/text_spans.nim)
```nim
let typeface = readTypeface("examples/data/Ubuntu-Regular_1.ttf")

proc newFont(typeface: Typeface, size: float32, color: Color): Font =
  result = newFont(typeface)
  result.size = size
  result.paint.color = color

let spans = @[
  newSpan("verb [with object] ",
    newFont(typeface, 12, color(0.78125, 0.78125, 0.78125, 1))),
  newSpan("strallow\n", newFont(typeface, 36, color(0, 0, 0, 1))),
  newSpan("\nstralÂ·low\n", newFont(typeface, 13, color(0, 0.5, 0.953125, 1))),
  newSpan("\n1. free (something) from restrictive restrictions \"the regulations are intended to strallow changes in public policy\" ",
      newFont(typeface, 14, color(0.3125, 0.3125, 0.3125, 1)))
]

image.fillText(typeset(spans, vec2(180, 180)), translate(vec2(10, 10)))
```
![example output](examples/text_spans.png)

### Square
nim c -r [examples/square.nim](examples/square.nim)
```nim
let ctx = newContext(image)
ctx.fillStyle = rgba(255, 0, 0, 255)

let
  pos = vec2(50, 50)
  wh = vec2(100, 100)

ctx.fillRect(rect(pos, wh))
```
![example output](examples/square.png)

### Line
nim c -r [examples/line.nim](examples/line.nim)
```nim
let ctx = newContext(image)
ctx.strokeStyle = "#FF5C00"
ctx.lineWidth = 10

let
  start = vec2(25, 25)
  stop = vec2(175, 175)

ctx.strokeSegment(segment(start, stop))
```
![example output](examples/line.png)

### Rounded rectangle
nim c -r [examples/rounded_rectangle.nim](examples/rounded_rectangle.nim)
```nim
let ctx = newContext(image)
ctx.fillStyle = rgba(0, 255, 0, 255)

let
  pos = vec2(50, 50)
  wh = vec2(100, 100)
  r = 25.0

ctx.fillRoundedRect(rect(pos, wh), r)
```
![example output](examples/rounded_rectangle.png)

### Heart
nim c -r [examples/heart.nim](examples/heart.nim)
```nim
image.fillPath(
  """
    M 20 60
    A 40 40 90 0 1 100 60
    A 40 40 90 0 1 180 60
    Q 180 120 100 180
    Q 20 120 20 60
    z
  """,
  parseHtmlColor("#FC427B").rgba
)
```
![example output](examples/heart.png)

### Masking
nim c -r [examples/masking.nim](examples/masking.nim)
```nim
let ctx = newContext(lines)
ctx.strokeStyle = "#F8D1DD"
ctx.lineWidth = 30

ctx.strokeSegment(segment(vec2(25, 25), vec2(175, 175)))
ctx.strokeSegment(segment(vec2(25, 175), vec2(175, 25)))

mask.fillPath(
  """
    M 20 60
    A 40 40 90 0 1 100 60
    A 40 40 90 0 1 180 60
    Q 180 120 100 180
    Q 20 120 20 60
    z
  """,
  color(1, 1, 1, 1)
)
lines.draw(mask, blendMode = MaskBlend)
image.draw(lines)
```
![example output](examples/masking.png)

### Gradient
nim c -r [examples/gradient.nim](examples/gradient.nim)
```nim
let paint = newPaint(RadialGradientPaint)
paint.gradientHandlePositions = @[
  vec2(100, 100),
  vec2(200, 100),
  vec2(100, 200)
]
paint.gradientStops = @[
  ColorStop(color: color(1, 0, 0, 1), position: 0),
  ColorStop(color: color(1, 0, 0, 0.15625), position: 1.0),
]

image.fillPath(
  """
    M 20 60
    A 40 40 90 0 1 100 60
    A 40 40 90 0 1 180 60
    Q 180 120 100 180
    Q 20 120 20 60
    z
  """,
  paint
)
```
![example output](examples/gradient.png)

### Image tiled
nim c -r [examples/image_tiled.nim](examples/image_tiled.nim)
```nim
let path = newPath()
path.polygon(
  vec2(100, 100),
  70,
  sides = 8
)

let paint = newPaint(TiledImagePaint)
paint.image = readImage("examples/data/mandrill.png")
paint.imageMat = scale(vec2(0.08, 0.08))

image.fillPath(path, paint)
```
![example output](examples/image_tiled.png)

### Shadow
nim c -r [examples/shadow.nim](examples/shadow.nim)
```nim
let path = newPath()
path.polygon(vec2(100, 100), 70, sides = 8)

let polygonImage = newImage(200, 200)
polygonImage.fillPath(path, rgba(255, 255, 255, 255))

let shadow = polygonImage.shadow(
  offset = vec2(2, 2),
  spread = 2,
  blur = 10,
  color = rgba(0, 0, 0, 200)
)

image.draw(shadow)
image.draw(polygonImage)
```
![example output](examples/shadow.png)

### Blur
nim c -r [examples/blur.nim](examples/blur.nim)
```nim
let path = newPath()
path.polygon(vec2(100, 100), 70, sides = 6)

let mask = newImage(200, 200)
mask.fillPath(path, color(1, 1, 1, 1))

blur.blur(20)
blur.draw(mask, blendMode = MaskBlend)

image.draw(trees)
image.draw(blur)
```
![example output](examples/blur.png)

### Tiger
nim c -r [examples/tiger.nim](examples/tiger.nim)
```nim
let tiger = readImage("examples/data/tiger.svg")

image.draw(
  tiger,
  translate(vec2(100, 100)) *
  scale(vec2(0.2, 0.2)) *
  translate(vec2(-450, -450))
)
```
![example output](examples/tiger.png)



================================================
FILE: pixie.nimble
================================================
version     = "5.1.0"
author      = "Andre von Houck and Ryan Oldenburg"
description = "Full-featured 2d graphics library for Nim."
license     = "MIT"

srcDir = "src"

requires "nim >= 1.4.8"
requires "vmath >= 1.1.4"
requires "chroma >= 0.2.6"
requires "zippy >= 0.10.3"
requires "flatty >= 0.3.4"
requires "nimsimd >= 1.2.4"
requires "bumpy >= 1.1.3"
requires "crunchy >= 0.1.0"

task bindings, "Generate bindings":

  proc compile(libName: string, flags = "") =
    exec "nim c -f " & flags & " -d:release --app:lib --gc:arc --tlsEmulation:off --out:" & libName & " --outdir:bindings/generated bindings/bindings.nim"

  when defined(windows):
    compile "pixie.dll"

  elif defined(macosx):
    compile "libpixie.dylib.arm", "--cpu:arm64 -l:'-target arm64-apple-macos11' -t:'-target arm64-apple-macos11'"
    compile "libpixie.dylib.x64", "--cpu:amd64 -l:'-target x86_64-apple-macos10.12' -t:'-target x86_64-apple-macos10.12'"
    exec "lipo bindings/generated/libpixie.dylib.arm bindings/generated/libpixie.dylib.x64 -output bindings/generated/libpixie.dylib -create"

  else:
    compile "libpixie.so"



================================================
FILE: bindings/bindings.nim
================================================
import genny, pixie, pixie/internal, unicode

var lastError: ref PixieError

proc takeError(): string =
  result = lastError.msg
  lastError = nil

proc checkError(): bool =
  result = lastError != nil

type
  Vector2* = object
    x*, y*: float32

  Matrix3* = object
    values*: array[9, float32]

proc matrix3(): Matrix3 =
  cast[Matrix3](mat3())

proc mul(a, b: Matrix3): Matrix3 =
  cast[Matrix3](cast[Mat3](a) * cast[Mat3](b))

proc translate(x, y: float32): Matrix3 =
  cast[Matrix3](translate(vec2(x, y)))

proc rotate(angle: float32): Matrix3 =
  cast[Matrix3](rotate(angle))

proc scale(x, y: float32): Matrix3 =
  cast[Matrix3](scale(vec2(x, y)))

proc inverse(m: Matrix3): Matrix3 =
  cast[Matrix3](inverse(cast[Mat3](m)))

proc parseColor(s: string): Color {.raises: [PixieError]} =
  try:
    result = parseHtmlColor(s)
  except:
    raise currentExceptionAsPixieError()

proc drawImage2(
  ctx: Context, image: Image, dx, dy, dWidth, dHeight: float32
) {.raises: [PixieError].} =
  ctx.drawImage(image, dx, dy, dWidth, dHeight)

proc drawImage3(
  ctx: Context,
  image: Image,
  sx, sy, sWidth, sHeight,
  dx, dy, dWidth, dHeight: float32
) {.raises: [PixieError].} =
  ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)

exportConsts:
  defaultMiterLimit
  autoLineHeight

exportEnums:
  FileFormat
  BlendMode
  PaintKind
  WindingRule
  LineCap
  LineJoin
  HorizontalAlignment
  VerticalAlignment
  TextCase

exportProcs:
  checkError
  takeError

exportObject Vector2:
  discard

exportObject Matrix3:
  constructor:
    matrix3
  procs:
    mul(Matrix3, Matrix3)

exportObject Rect:
  discard

exportObject Color:
  discard

exportObject ColorStop:
  discard

exportObject TextMetrics:
  discard

exportObject ImageDimensions:
  discard

exportSeq seq[float32]:
  discard

exportSeq seq[Span]:
  procs:
    typeset(seq[Span], Vec2, HorizontalAlignment, VerticalAlignment, bool)
    layoutBounds(seq[Span])

exportRefObject Image:
  fields:
    width
    height
  constructor:
    newImage(int, int)
  procs:
    writeFile(Image, string)
    copy(Image)
    getColor
    setColor
    fill(Image, Color)
    fill(Image, Paint)
    isOneColor(Image)
    isTransparent(Image)
    isOpaque(Image)
    flipHorizontal
    flipVertical
    rotate90
    subImage(Image, int, int, int, int)
    subImage(Image, Rect)
    minifyBy2(Image, int)
    magnifyBy2(Image, int)
    applyOpacity(Image, float32)
    invert(Image)
    ceil(Image)
    blur(Image, float32, Color)
    resize(Image, int, int)
    shadow(Image, Vec2, float32, float32, Color)
    superImage
    draw(Image, Image, Mat3, BlendMode)
    fillGradient
    fillText(Image, Font, string, Mat3, Vec2, HorizontalAlignment, VerticalAlignment)
    fillText(Image, Arrangement, Mat3)
    strokeText(Image, Font, string, Mat3, float32, Vec2, HorizontalAlignment, VerticalAlignment, LineCap, LineJoin, float32, seq[float32])
    strokeText(Image, Arrangement, Mat3, float32, LineCap, LineJoin, float32, seq[float32])
    fillPath(Image, Path, Paint, Mat3, WindingRule)
    strokePath(Image, Path, Paint, Mat3, float32, LineCap, LineJoin, float32, seq[float32])
    newContext(Image)
    opaqueBounds

exportRefObject Paint:
  fields:
    kind
    blendMode
    opacity
    color
    image
    imageMat
    gradientHandlePositions
    gradientStops
  constructor:
    newPaint(PaintKind)
  procs:
    copy(Paint)

exportRefObject Path:
  constructor:
    newPath
  procs:
    copy(Path)
    transform(Path, Mat3)
    addPath(Path, Path)
    closePath(Path)
    computeBounds(Path)
    fillOverlaps
    strokeOverlaps
    moveTo(Path, float32, float32)
    lineTo(Path, float32, float32)
    bezierCurveTo(Path, float32, float32, float32, float32, float32, float32)
    quadraticCurveTo(Path, float32, float32, float32, float32)
    ellipticalArcTo(Path, float32, float32, float32, bool, bool, float32, float32)
    arc(Path, float32, float32, float32, float32, float32, bool)
    arcTo(Path, float32, float32, float32, float32, float32)
    rect(Path, float32, float32, float32, float32)
    roundedRect(Path, float32, float32, float32, float32, float32, float32, float32, float32, bool)
    ellipse(Path, float32, float32, float32, float32)
    circle(Path, float32, float32, float32)
    polygon(Path, float32, float32, float32, int)

exportRefObject Typeface:
  fields:
    filePath
  procs:
    ascent
    descent
    lineGap
    lineHeight
    hasGlyph
    getGlyphPath
    getAdvance
    getKerningAdjustment
    newFont

exportRefObject Font:
  fields:
    typeface
    size
    lineHeight
    paints
    paint
    textCase
    underline
    strikethrough
    noKerningAdjustments
  procs:
    copy(Font)
    scale(Font)
    defaultLineHeight
    typeset(Font, string, Vec2, HorizontalAlignment, VerticalAlignment, bool)
    layoutBounds(Font, string)

exportRefObject Span:
  fields:
    text
    font
  constructor:
    newSpan

exportRefObject Arrangement:
  procs:
    layoutBounds(Arrangement)
    computeBounds(Arrangement, Mat3)

exportRefObject Context:
  fields:
    image
    fillStyle
    strokeStyle
    globalAlpha
    lineWidth
    miterLimit
    lineCap
    lineJoin
    font
    fontSize
    textAlign
  constructor:
    newContext(int, int)
  procs:
    save
    saveLayer
    restore
    beginPath
    closePath(Context)
    fill(Context, WindingRule)
    fill(Context, Path, WindingRule)
    clip(Context, WindingRule)
    clip(Context, Path, WindingRule)
    stroke(Context)
    stroke(Context, Path)
    measureText
    getTransform
    setTransform
    transform(Context, Mat3)
    resetTransform
    getLineDash
    setLineDash
    drawImage(Context, Image, float32, float32)
    drawImage2
    drawImage3
    moveTo(Context, float32, float32)
    lineTo(Context, float32, float32)
    bezierCurveTo(Context, float32, float32, float32, float32, float32, float32)
    quadraticCurveTo(Context, float32, float32, float32, float32)
    arc(Context, float32, float32, float32, float32, float32, bool)
    arcTo(Context, float32, float32, float32, float32, float32)
    rect(Context, float32, float32, float32, float32)
    roundedRect(Context, float32, float32, float32, float32, float32, float32, float32, float32)
    ellipse(Context, float32, float32, float32, float32)
    circle(Context, float32, float32, float32)
    polygon(Context, float32, float32, float32, int)
    clearRect(Context, float32, float32, float32, float32)
    fillRect(Context, float32, float32, float32, float32)
    strokeRect(Context, float32, float32, float32, float32)
    strokeSegment(Context, float32, float32, float32, float32)
    fillText(Context, string, float32, float32)
    strokeText(Context, string, float32, float32)
    translate(Context, float32, float32)
    scale(Context, float32, float32)
    rotate(Context, float32)
    isPointInPath(Context, float32, float32, WindingRule)
    isPointInPath(Context, Path, float32, float32, WindingRule)
    isPointInStroke(Context, float32, float32)
    isPointInStroke(Context, Path, float32, float32)

exportProcs:
  decodeImage
  decodeImageDimensions
  readImage
  readImageDimensions
  readTypeface
  readFont
  parsePath
  miterLimitToAngle
  angleToMiterLimit
  parseColor
  translate(float32, float32)
  rotate(float32)
  scale(float32, float32)
  inverse(Matrix3)
  snapToPixels
  mix(Color, Color, float32)

writeFiles("bindings/generated", "Pixie")

include generated/internal



================================================
FILE: bindings/generated/placeholder.txt
================================================
[Empty file]


================================================
FILE: examples/blur.nim
================================================
import pixie

let
  trees = readImage("examples/data/trees.png")
  blur = trees.copy()
  image = newImage(200, 200)

image.fill(rgba(255, 255, 255, 255))

let path = newPath()
path.polygon(vec2(100, 100), 70, sides = 6)

let mask = newImage(200, 200)
mask.fillPath(path, color(1, 1, 1, 1))

blur.blur(20)
blur.draw(mask, blendMode = MaskBlend)

image.draw(trees)
image.draw(blur)

image.writeFile("examples/blur.png")



================================================
FILE: examples/gradient.nim
================================================
import pixie

let image = newImage(200, 200)
image.fill(rgba(255, 255, 255, 255))

let paint = newPaint(RadialGradientPaint)
paint.gradientHandlePositions = @[
  vec2(100, 100),
  vec2(200, 100),
  vec2(100, 200)
]
paint.gradientStops = @[
  ColorStop(color: color(1, 0, 0, 1), position: 0),
  ColorStop(color: color(1, 0, 0, 0.15625), position: 1.0),
]

image.fillPath(
  """
    M 20 60
    A 40 40 90 0 1 100 60
    A 40 40 90 0 1 180 60
    Q 180 120 100 180
    Q 20 120 20 60
    z
  """,
  paint
)

image.writeFile("examples/gradient.png")



================================================
FILE: examples/heart.nim
================================================
import pixie

let image = newImage(200, 200)
image.fill(rgba(255, 255, 255, 255))

image.fillPath(
  """
    M 20 60
    A 40 40 90 0 1 100 60
    A 40 40 90 0 1 180 60
    Q 180 120 100 180
    Q 20 120 20 60
    z
  """,
  parseHtmlColor("#FC427B").rgba
)

image.writeFile("examples/heart.png")



================================================
FILE: examples/image_tiled.nim
================================================
import pixie

let image = newImage(200, 200)
image.fill(rgba(255, 255, 255, 255))

let path = newPath()
path.polygon(
  vec2(100, 100),
  70,
  sides = 8
)

let paint = newPaint(TiledImagePaint)
paint.image = readImage("examples/data/mandrill.png")
paint.imageMat = scale(vec2(0.08, 0.08))

image.fillPath(path, paint)
image.writeFile("examples/image_tiled.png")



================================================
FILE: examples/line.nim
================================================
import pixie

let image = newImage(200, 200)
image.fill(rgba(255, 255, 255, 255))

let ctx = newContext(image)
ctx.strokeStyle = "#FF5C00"
ctx.lineWidth = 10

let
  start = vec2(25, 25)
  stop = vec2(175, 175)

ctx.strokeSegment(segment(start, stop))

image.writeFile("examples/line.png")



================================================
FILE: examples/masking.nim
================================================
import pixie

let
  image = newImage(200, 200)
  lines = newImage(200, 200)
  mask = newImage(200, 200)

lines.fill(parseHtmlColor("#FC427B").rgba)
image.fill(rgba(255, 255, 255, 255))

let ctx = newContext(lines)
ctx.strokeStyle = "#F8D1DD"
ctx.lineWidth = 30

ctx.strokeSegment(segment(vec2(25, 25), vec2(175, 175)))
ctx.strokeSegment(segment(vec2(25, 175), vec2(175, 25)))

mask.fillPath(
  """
    M 20 60
    A 40 40 90 0 1 100 60
    A 40 40 90 0 1 180 60
    Q 180 120 100 180
    Q 20 120 20 60
    z
  """,
  color(1, 1, 1, 1)
)
lines.draw(mask, blendMode = MaskBlend)
image.draw(lines)

image.writeFile("examples/masking.png")



================================================
FILE: examples/rounded_rectangle.nim
================================================
import pixie

let image = newImage(200, 200)
image.fill(rgba(255, 255, 255, 255))

let ctx = newContext(image)
ctx.fillStyle = rgba(0, 255, 0, 255)

let
  pos = vec2(50, 50)
  wh = vec2(100, 100)
  r = 25.0

ctx.fillRoundedRect(rect(pos, wh), r)

image.writeFile("examples/rounded_rectangle.png")



================================================
FILE: examples/shadow.nim
================================================
import pixie

let image = newImage(200, 200)
image.fill(rgba(255, 255, 255, 255))

let path = newPath()
path.polygon(vec2(100, 100), 70, sides = 8)

let polygonImage = newImage(200, 200)
polygonImage.fillPath(path, rgba(255, 255, 255, 255))

let shadow = polygonImage.shadow(
  offset = vec2(2, 2),
  spread = 2,
  blur = 10,
  color = rgba(0, 0, 0, 200)
)

image.draw(shadow)
image.draw(polygonImage)

image.writeFile("examples/shadow.png")



================================================
FILE: examples/square.nim
================================================
import pixie

let image = newImage(200, 200)
image.fill(rgba(255, 255, 255, 255))

let ctx = newContext(image)
ctx.fillStyle = rgba(255, 0, 0, 255)

let
  pos = vec2(50, 50)
  wh = vec2(100, 100)

ctx.fillRect(rect(pos, wh))

image.writeFile("examples/square.png")



================================================
FILE: examples/text.nim
================================================
import pixie

let image = newImage(200, 200)
image.fill(rgba(255, 255, 255, 255))

var font = readFont("examples/data/Roboto-Regular_1.ttf")
font.size = 20
font.paint.color = color(1, 0, 0)

let text = "Typesetting is the arrangement and composition of text in graphic design and publishing in both digital and traditional medias."

image.fillText(font.typeset(text, vec2(180, 180)), translate(vec2(10, 10)))
image.writeFile("examples/text.png")



================================================
FILE: examples/text_spans.nim
================================================
import pixie

let image = newImage(200, 200)
image.fill(rgba(255, 255, 255, 255))

let typeface = readTypeface("examples/data/Ubuntu-Regular_1.ttf")

proc newFont(typeface: Typeface, size: float32, color: Color): Font =
  result = newFont(typeface)
  result.size = size
  result.paint.color = color

let spans = @[
  newSpan("verb [with object] ",
    newFont(typeface, 12, color(0.78125, 0.78125, 0.78125, 1))),
  newSpan("strallow\n", newFont(typeface, 36, color(0, 0, 0, 1))),
  newSpan("\nstralÂ·low\n", newFont(typeface, 13, color(0, 0.5, 0.953125, 1))),
  newSpan("\n1. free (something) from restrictive restrictions \"the regulations are intended to strallow changes in public policy\" ",
      newFont(typeface, 14, color(0.3125, 0.3125, 0.3125, 1)))
]

image.fillText(typeset(spans, vec2(180, 180)), translate(vec2(10, 10)))
image.writeFile("examples/text_spans.png")



================================================
FILE: examples/tiger.nim
================================================
import pixie

let image = newImage(200, 200)
image.fill(rgba(255, 255, 255, 255))

let tiger = readImage("examples/data/tiger.svg")

image.draw(
  tiger,
  translate(vec2(100, 100)) *
  scale(vec2(0.2, 0.2)) *
  translate(vec2(-450, -450))
)

image.writeFile("examples/tiger.png")



================================================
FILE: experiments/bench_cairo.nim
================================================
import benchy, cairo, pixie, pixie/fileformats/svg {.all.}, pixie/paths {.all.}

type
  Fill = object
    shapes: seq[Polygon]
    transform: Mat3
    paint: Paint
    windingRule: WindingRule

  Benchmark = object
    name: string
    fills: seq[Fill]

var benchmarks: seq[Benchmark]

let
  opaque = newPaint(SolidPaint)
  notOpaque = newPaint(SolidPaint)
opaque.color = color(0, 0, 0, 1)
notOpaque.color = color(0, 0, 0, 0.5)

block: # Basic rect
  let path = newPath()
  path.rect(rect(50, 50, 800, 800))

  let shapes = path.commandsToShapes(true, 1)

  benchmarks.add(Benchmark(
    name: "rect opaque",
    fills: @[Fill(
    shapes: shapes,
    transform: mat3(),
    paint: opaque,
    windingRule: NonZero
  )]))

  benchmarks.add(Benchmark(
    name: "rect not opaque",
    fills: @[Fill(
    shapes: shapes,
    transform: mat3(),
    paint: notOpaque,
    windingRule: NonZero
  )]))

block: # Rounded rect
  let path = newPath()
  path.roundedRect(rect(0, 0, 900, 900), 100, 100, 100, 100)

  let shapes = path.commandsToShapes(true, 1)

  benchmarks.add(Benchmark(
    name: "roundedRect opaque",
    fills: @[Fill(
    shapes: shapes,
    transform: mat3(),
    paint: opaque,
    windingRule: NonZero
    )]))

  benchmarks.add(Benchmark(
    name: "roundedRect not opaque",
    fills: @[Fill(
    shapes: shapes,
    transform: mat3(),
    paint: notOpaque,
    windingRule: NonZero
    )]))

block: # Pentagon
  let path = newPath()
  path.polygon(vec2(450, 450), 400, 5)

  let shapes = path.commandsToShapes(true, 1)

  benchmarks.add(Benchmark(
    name: "pentagon opaque",
    fills: @[Fill(
    shapes: shapes,
    transform: mat3(),
    paint: opaque,
    windingRule: NonZero
  )]))

  benchmarks.add(Benchmark(
    name: "pentagon not opaque",
    fills: @[Fill(
    shapes: shapes,
    transform: mat3(),
    paint: notOpaque,
    windingRule: NonZero
  )]))

block: # Circle
  let path = newPath()
  path.circle(circle(vec2(450, 450), 400))

  let shapes = path.commandsToShapes(true, 1)

  benchmarks.add(Benchmark(
    name: "circle opaque",
    fills: @[Fill(
    shapes: shapes,
    transform: mat3(),
    paint: opaque,
    windingRule: NonZero
  )]))

  benchmarks.add(Benchmark(
    name: "circle not opaque",
    fills: @[Fill(
    shapes: shapes,
    transform: mat3(),
    paint: notOpaque,
    windingRule: NonZero
  )]))

block: # Heart
  let path = parsePath("""
      M 100,300
      A 200,200 0,0,1 500,300
      A 200,200 0,0,1 900,300
      Q 900,600 500,900
      Q 100,600 100,300 z
  """)

  let shapes = path.commandsToShapes(true, 1)

  benchmarks.add(Benchmark(
    name: "heart opaque",
    fills: @[Fill(
    shapes: shapes,
    transform: mat3(),
    paint: opaque,
    windingRule: NonZero
  )]))

  benchmarks.add(Benchmark(
    name: "heart not opaque",
    fills: @[Fill(
    shapes: shapes,
    transform: mat3(),
    paint: notOpaque,
    windingRule: NonZero
  )]))

block: # Tiger
  let
    data = readFile("tests/fileformats/svg/Ghostscript_Tiger.svg")
    parsed = parseSvg(data)

  var fills: seq[Fill]

  for (path, props) in parsed.elements:
    if props.display and props.opacity > 0:
      if props.fill != "none":
        let
          shapes = path.commandsToShapes(true, 1)
          paint = parseSomePaint(props.fill)
        fills.add(Fill(
          shapes: shapes,
          transform: props.transform,
          paint: paint,
          windingRule: props.fillRule
        ))

      if props.stroke != rgbx(0, 0, 0, 0) and props.strokeWidth > 0:
        let strokeShapes = strokeShapes(
          parseSomePath(path, false, props.transform.pixelScale),
          props.strokeWidth,
          props.strokeLineCap,
          props.strokeLineJoin,
          props.strokeMiterLimit,
          props.strokeDashArray,
          props.transform.pixelScale
        )
        let paint = props.stroke.copy()
        paint.color.a *= (props.opacity * props.strokeOpacity)
        fills.add(Fill(
          shapes: strokeShapes,
          transform: props.transform,
          paint: paint,
          windingRule: NonZero
        ))

  benchmarks.add(Benchmark(
    name: "tiger",
    fills: fills
  ))

block:
  for benchmark in benchmarks:
    let
      surface = imageSurfaceCreate(FORMAT_ARGB32, 900, 900)
      ctx = surface.create()

    ctx.setLineWidth(1)

    timeIt "[cairo] " & benchmark.name:
      for fill in benchmark.fills:
        if fill.shapes.len > 0:
          ctx.newPath()
          for shape in fill.shapes:
            ctx.moveTo(shape[0].x, shape[0].y)
            for v in shape:
              ctx.lineTo(v.x, v.y)
          let
            color = fill.paint.color
            matrix = Matrix(
              xx: fill.transform[0, 0],
              yx: fill.transform[0, 1],
              xy: fill.transform[1, 0],
              yy: fill.transform[1, 1],
              x0: fill.transform[2, 0],
              y0: fill.transform[2, 1],
            )
          ctx.setSourceRgba(color.r, color.g, color.b, color.a)
          ctx.setMatrix(matrix.unsafeAddr)
          ctx.setFillRule(
            if fill.windingRule == NonZero:
              FillRuleWinding
            else:
              FillRuleEvenOdd
          )
          ctx.fill()
          # ctx.stroke()

    # discard surface.writeToPng(("cairo_" & benchmark.name & ".png").cstring)

block:
  for benchmark in benchmarks:
    let image = newImage(900, 900)

    timeIt "[pixie] " & benchmark.name:
      for fill in benchmark.fills:
        if fill.shapes.len > 0:
          let p = newPath()
          for shape in fill.shapes:
            p.moveTo(shape[0])
            for v in shape:
              p.lineTo(v)
          image.fillPath(
            p,
            fill.paint,
            fill.transform,
            fill.windingRule
          )
          # image.strokePath(
          #   p,
          #   fill.paint,
          #   fill.transform,
          #   1
          # )

    # image.writeFile("pixie_" & benchmark.name & ".png")



================================================
FILE: experiments/bench_cairo_draw.nim
================================================
import benchy, cairo, pixie

block:
  let
    backdrop = imageSurfaceCreateFromPng("tests/fileformats/svg/masters/dragon2.png")
    source = imageSurfaceCreateFromPng("tests/fileformats/svg/masters/Ghostscript_Tiger.png")
    tmp = imageSurfaceCreate(FORMAT_ARGB32, 1568, 940)
    ctx = tmp.create()

  timeIt "cairo draw normal":
    ctx.setSource(backdrop, 0, 0)
    ctx.paint()
    ctx.setSource(source, 0, 0)
    ctx.paint()
    tmp.flush()

  # echo tmp.writeToPng("tmp.png")

block:
  let
    backdrop = readImage("tests/fileformats/svg/masters/dragon2.png")
    source = readImage("tests/fileformats/svg/masters/Ghostscript_Tiger.png")
    tmp = newImage(1568, 940)

  timeIt "pixie draw normal":
    tmp.draw(backdrop)
    tmp.draw(source)

  # tmp.writeFile("tmp2.png")

block:
  let
    backdrop = readImage("tests/fileformats/svg/masters/dragon2.png")
    source = readImage("tests/fileformats/svg/masters/Ghostscript_Tiger.png")
    tmp = newImage(1568, 940)

  timeIt "pixie draw overwrite":
    tmp.draw(backdrop, blendMode = OverwriteBlend)
    tmp.draw(source)

  # tmp.writeFile("tmp2.png")

block:
  let
    backdrop = imageSurfaceCreateFromPng("tests/fileformats/svg/masters/dragon2.png")
    source = imageSurfaceCreateFromPng("tests/fileformats/svg/masters/Ghostscript_Tiger.png")
    tmp = imageSurfaceCreate(FORMAT_ARGB32, 1568, 940)
    ctx = tmp.create()

  timeIt "cairo draw mask":
    ctx.setSource(backdrop, 0, 0)
    ctx.mask(source, 0, 0)
    tmp.flush()

  # tmp.writeToPng("tmp_masked.png")

block:
  let
    backdrop = readImage("tests/fileformats/svg/masters/dragon2.png")
    source = readImage("tests/fileformats/svg/masters/Ghostscript_Tiger.png")
    tmp = newImage(1568, 940)

  timeIt "pixie draw mask":
    tmp.draw(backdrop)
    tmp.draw(source, blendMode = MaskBlend)

  # tmp.writeFile("tmp_masked2.png")

block:
  let
    backdrop = imageSurfaceCreateFromPng("tests/fileformats/svg/masters/dragon2.png")
    source = imageSurfaceCreateFromPng("tests/fileformats/svg/masters/Ghostscript_Tiger.png")
    tmp = imageSurfaceCreate(FORMAT_ARGB32, 1568, 940)
    ctx = tmp.create()

  timeIt "cairo draw smooth":
    var
      mat = mat3()
      matrix = cairo.Matrix(
        xx: mat[0, 0],
        yx: mat[0, 1],
        xy: mat[1, 0],
        yy: mat[1, 1],
        x0: mat[2, 0],
        y0: mat[2, 1],
      )
    ctx.setMatrix(matrix.unsafeAddr)
    ctx.setSource(backdrop, 0, 0)
    ctx.paint()
    mat = translate(vec2(0.5, 0.5))
    matrix = cairo.Matrix(
      xx: mat[0, 0],
      yx: mat[0, 1],
      xy: mat[1, 0],
      yy: mat[1, 1],
      x0: mat[2, 0],
      y0: mat[2, 1],
    )
    ctx.setMatrix(matrix.unsafeAddr)
    ctx.setSource(source, 0, 0)
    ctx.paint()
    tmp.flush()

  # echo tmp.writeToPng("tmp.png")

block:
  let
    backdrop = readImage("tests/fileformats/svg/masters/dragon2.png")
    source = readImage("tests/fileformats/svg/masters/Ghostscript_Tiger.png")
    tmp = newImage(1568, 940)

  timeIt "pixie draw smooth":
    tmp.draw(backdrop)
    tmp.draw(source, translate(vec2(0.5, 0.5)))

  # tmp.writeFile("tmp2.png")

block:
  let
    backdrop = imageSurfaceCreateFromPng("tests/fileformats/svg/masters/dragon2.png")
    source = imageSurfaceCreateFromPng("tests/fileformats/svg/masters/Ghostscript_Tiger.png")
    tmp = imageSurfaceCreate(FORMAT_ARGB32, 1568, 940)
    ctx = tmp.create()

  timeIt "cairo draw smooth rotated":
    var
      mat = mat3()
      matrix = cairo.Matrix(
        xx: mat[0, 0],
        yx: mat[0, 1],
        xy: mat[1, 0],
        yy: mat[1, 1],
        x0: mat[2, 0],
        y0: mat[2, 1],
      )
    ctx.setMatrix(matrix.unsafeAddr)
    ctx.setSource(backdrop, 0, 0)
    ctx.paint()
    mat = rotate(15.toRadians)
    matrix = cairo.Matrix(
      xx: mat[0, 0],
      yx: mat[0, 1],
      xy: mat[1, 0],
      yy: mat[1, 1],
      x0: mat[2, 0],
      y0: mat[2, 1],
    )
    ctx.setMatrix(matrix.unsafeAddr)
    ctx.setSource(source, 0, 0)
    ctx.paint()
    tmp.flush()

  # echo tmp.writeToPng("tmp.png")

block:
  let
    backdrop = readImage("tests/fileformats/svg/masters/dragon2.png")
    source = readImage("tests/fileformats/svg/masters/Ghostscript_Tiger.png")
    tmp = newImage(1568, 940)

  timeIt "pixie draw smooth rotated":
    tmp.draw(backdrop)
    tmp.draw(source, rotate(15.toRadians))

  # tmp.writeFile("tmp2.png")



================================================
FILE: experiments/sweeps.nim
================================================

import algorithm, bumpy, chroma, pixie/images, print,
    sequtils, vmath, benchy

import pixie, pixie/paths {.all.}


printColors = false

proc intersects*(a, b: Segment, at: var Vec2): bool {.inline.} =
  ## Checks if the a segment intersects b segment.
  ## If it returns true, at will have point of intersection
  let
    s1 = a.to - a.at
    s2 = b.to - b.at
    denominator = (-s2.x * s1.y + s1.x * s2.y)
    s = (-s1.y * (a.at.x - b.at.x) + s1.x * (a.at.y - b.at.y)) / denominator
    t = (s2.x * (a.at.y - b.at.y) - s2.y * (a.at.x - b.at.x)) / denominator

  if s > 0 and s < 1 and t > 0 and t < 1:
    at = a.at + (t * s1)
    return true

proc pixelCover(a0, b0: Vec2): float32 =
  ## Returns the amount of area a given segment sweeps to the right
  ## in a [0,0 to 1,1] box.
  var
    a = a0
    b = b0
    aI: Vec2
    bI: Vec2
    area: float32 = 0.0

  # # Sort A on top.
  # if a.y > b.y:
  #   let tmp = a
  #   a = b
  #   b = tmp

  # if (b.y < 0 or a.y > 1) or # Above or bellow, no effect.
  #   (a.x >= 1 and b.x >= 1) or # To the right, no effect.
  #   (a.y == b.y): # Horizontal line, no effect.
  #   return 0

  if (a.x < 0 and b.x < 0) or # Both to the left.
    (a.x == b.x): # Vertical line
    # Area of the rectangle:
    return (1 - clamp(a.x, 0, 1)) * (min(b.y, 1) - max(a.y, 0))

  else:
    # y = mm*x + bb
    let
      mm: float32 = (b.y - a.y) / (b.x - a.x)
      bb: float32 = a.y - mm * a.x

    if a.x >= 0 and a.x <= 1 and a.y >= 0 and a.y <= 1:
      # A is in pixel bounds.
      aI = a
    else:
      aI = vec2((0 - bb) / mm, 0)
      if aI.x < 0:
        let y = mm * 0 + bb
        # Area of the extra rectangle.
        area += (min(bb, 1) - max(a.y, 0)).clamp(0, 1)
        aI = vec2(0, y.clamp(0, 1))
      elif aI.x > 1:
        let y = mm * 1 + bb
        aI = vec2(1, y.clamp(0, 1))

    if b.x >= 0 and b.x <= 1 and b.y >= 0 and b.y <= 1:
      # B is in pixel bounds.
      bI = b
    else:
      bI = vec2((1 - bb) / mm, 1)
      if bI.x < 0:
        let y = mm * 0 + bb
        # Area of the extra rectangle.
        area += (min(b.y, 1) - max(bb, 0)).clamp(0, 1)
        bI = vec2(0, y.clamp(0, 1))
      elif bI.x > 1:
        let y = mm * 1 + bb
        bI = vec2(1, y.clamp(0, 1))

  area += ((1 - aI.x) + (1 - bI.x)) / 2 * (bI.y - aI.y)
  return area

proc intersectsInner*(a, b: Segment, at: var Vec2): bool {.inline.} =
  ## Checks if the a segment intersects b segment.
  ## If it returns true, at will have point of intersection
  let
    s1 = a.to - a.at
    s2 = b.to - b.at
    denominator = (-s2.x * s1.y + s1.x * s2.y)
    s = (-s1.y * (a.at.x - b.at.x) + s1.x * (a.at.y - b.at.y)) / denominator
    t = (s2.x * (a.at.y - b.at.y) - s2.y * (a.at.x - b.at.x)) / denominator

  if s > 0 and s < 1 and t >= 0 and t <= 1:
    at = a.at + (t * s1)
    return true

type

  Trapezoid = object
    nw, ne, se, sw: Vec2

  Line = object
    #m, x, b: float32
    atx, tox: float32

proc toLine(s: Segment): Line =
  var line = Line()
  # y = mx + b
  line.atx = s.at.x
  line.tox = s.to.x
  # line.m = (s.at.y - s.to.y) / (s.at.x - s.to.x)
  # line.b = s.at.y - line.m * s.at.x
  return line

proc roundBy*(v: Vec2, n: float32): Vec2 {.inline.} =
  result.x = sign(v.x) * round(abs(v.x) / n) * n
  result.y = sign(v.y) * round(abs(v.y) / n) * n

proc fillPath2(mask: Mask, p: Path) =

  var polygons = p.commandsToShapes()

  const q = 1/256.0

  # Creates segment q, quantize and remove horizontal lines.
  var segments1: seq[Segment]
  for shape in polygons:
    for s in shape.segments:
      var s = s
      s.at = s.at.roundBy(q)
      s.to = s.to.roundBy(q)
      if s.at.y != s.to.y:
        if s.at.y > s.to.y:
          # make sure segments always are at.y higher
          swap(s.at, s.to)
        segments1.add(s)
  segments1.sort(proc(a, b: Segment): int = cmp(a.at.y, b.at.y))

  # Compute cutLines
  var
    cutLines: seq[float32]
    last = segments1[0].at.y
    bottom = segments1[0].to.y
  cutLines.add(last)
  for s in segments1:
    if s.at.y != last:
      last = s.at.y
      cutLines.add(last)
    if bottom < s.to.y:
      bottom = s.to.y
  cutLines.add(bottom)
  #print cutLines

  var
    sweeps = newSeq[seq[Line]](cutLines.len - 1) # dont add bottom cutLine
    lastSeg = 0
  for i, sweep in sweeps.mpairs:
    #print "sweep", i, cutLines[i]
    while segments1[lastSeg].at.y == cutLines[i]:
      let s = segments1[lastSeg]
      #print s
      if s.to.y != cutLines[i + 1]:
        #print "needs cut?"
        quit()
      sweep.add(toLine(segments1[lastSeg]))
      inc lastSeg
      if lastSeg >= segments1.len:
        # Sort the last sweep by X
        break
    # Sort the sweep by X
    sweep.sort proc(a, b: Line): int =
      result = cmp(a.atx, b.atx)
      if result == 0:
        result = cmp(a.tox, b.tox)

  #print sweeps

  proc fillCoverage(y: int, currCutLine: int, sweep: seq[Line]) =

    let
      sweepHeight = cutLines[currCutLine + 1] - cutLines[currCutLine]
      yFracTop = (y.float32 - cutLines[currCutLine]) / sweepHeight
      yFracBottom = (y.float32 + 1 - cutLines[currCutLine]) / sweepHeight
    var i = 0
    while i < sweep.len:
      let
        nwX = mix(sweep[i+0].atx, sweep[i+0].tox, yFracTop)
        neX = mix(sweep[i+1].atx, sweep[i+1].tox, yFracTop)

        swX = mix(sweep[i+0].atx, sweep[i+0].tox, yFracBottom)
        seX = mix(sweep[i+1].atx, sweep[i+1].tox, yFracBottom)

        minWi = min(nwX, swX).int
        maxWi = max(nwX, swX).ceil.int

        minEi = min(neX, seX).int
        maxEi = max(neX, seX).ceil.int

      template write(x, y: int, alpha: float32) =
        let backdrop = mask.getValueUnsafe(x, y)
        mask.setValueUnsafe(x, y, backdrop + (alpha * 255).uint8)

      let
        nw = vec2(sweep[i+0].atx, cutLines[currCutLine])
        sw = vec2(sweep[i+0].tox, cutLines[currCutLine + 1])
      for x in minWi ..< maxWi:
        var area = pixelCover(nw - vec2(x.float32, y.float32), sw - vec2(x.float32, y.float32))
        write(x, y, area)

      let x = maxWi
      var midArea = pixelCover(nw - vec2(x.float32, y.float32), sw - vec2(x.float32, y.float32))
      for x in maxWi ..< minEi:
        write(x, y, midArea)

      let
        ne = vec2(sweep[i+1].atx, cutLines[currCutLine])
        se = vec2(sweep[i+1].tox, cutLines[currCutLine + 1])
      for x in minEi ..< maxEi:

        var area = midArea - pixelCover(ne - vec2(x.float32, y.float32), se - vec2(x.float32, y.float32))
        write(x, y, area)

      i += 2


    # ## x10 slower
    # for x in 0 ..< mask.width:
    #   for i, line in sweep:
    #     let
    #       segat = vec2(line.atx, cutLines[currCutLine])
    #       segto = vec2(line.tox, cutLines[currCutLine + 1])
    #     var area = pixelCover(segat - vec2(x.float32, y.float32), segto - vec2(x.float32, y.float32))
    #     if i mod 2 == 1:
    #       area = -area
    #     let backdrop = mask.getValueUnsafe(x, y)
    #     mask.setValueUnsafe(x, y, backdrop + (area * 255).uint8)


    # var i = 0
    # let
    #   sweepHeight = cutLines[currCutLine + 1] - cutLines[currCutLine]
    #   yFracTop = (y.float32 - cutLines[currCutLine]) / sweepHeight
    #   yFracBottom = (y.float32 + 1 - cutLines[currCutLine]) / sweepHeight
    # #print "cover", y, sweepHeight, yFrac
    # while i < sweep.len:
    #   #print "fill", sweep[i].at.x, "..", sweep[i+1].at.x


    #   var ay = 1.0.float32
    #   if y.float32 < cutLines[currCutLine]:
    #     let a2 = cutLines[currCutLine] - y.float32
    #     #print "cut from top", y.float, cutLines[currCutLine], a2
    #     ay *= a2
    #   if y.float32 + 1 > cutLines[currCutLine + 1]:
    #     let a2 = (y.float32 + 1) - cutLines[currCutLine + 1]
    #     #print "cut from bottom", y.float, cutLines[currCutLine], a2
    #     ay *= a2

    #   #if y == 20:
    #   # print "--", y

    #   template write(x, y: int, alpha: float32) =
    #     let backdrop = mask.getValueUnsafe(x, y)
    #     mask.setValueUnsafe(x, y, backdrop + (ay * alpha * 255).uint8)

    #   let
    #     nwX = mix(sweep[i+0].atx, sweep[i+0].tox, yFracTop)
    #     neX = mix(sweep[i+1].atx, sweep[i+1].tox, yFracTop)

    #     swX = mix(sweep[i+0].atx, sweep[i+0].tox, yFracBottom)
    #     seX = mix(sweep[i+1].atx, sweep[i+1].tox, yFracBottom)

    #     # minW = min(nwX, swX)
    #     # maxW = max(nwX, swX)
    #     # minE = min(neX, seX)
    #     # maxE = max(neX, seX)



    #   var
    #     endWAt: float32 = 0
    #     endWTo: float32 = 0
    #     endWArea: float32 = 0

    #     slopeWUp = swX < nwX
    #     slopeWAt: float32 = 0
    #     slopeWTo: float32 = 0
    #     slopeWArea: float32 = 0
    #     slopeWRate: float32 = 0

    #     transitionWAt: float32 = 0
    #     transitionWTo: float32 = 0
    #     transitionWArea: float32 = 0

    #     fillAt: float32 = 0
    #     fillTo: float32 = 0

    #     transitionEAt: float32 = 0
    #     transitionETo: float32 = 0
    #     transitionEArea: float32 = 0

    #     slopeEUp = seX < neX
    #     slopeEAt: float32 = 0
    #     slopeETo: float32 = 0
    #     slopeEArea: float32 = 0
    #     slopeERate: float32 = 0

    #     endEAt: float32 = 0
    #     endETo: float32 = 0
    #     endEArea: float32 = 0

    #   if slopeWUp:
    #     endWAt = swX.floor
    #     endWTo = swX.ceil

    #     slopeWAt = endWTo
    #     slopeWTo = nwX.floor

    #     transitionWAt = slopeWAt
    #     transitionWTo = nwX.ceil

    #     fillAt = transitionWTo

    #   else:
    #     endWAt = nwX.floor
    #     endWTo = nwX.ceil

    #     slopeWAt = endWTo
    #     slopeWTo = swX.floor

    #     transitionWAt = slopeWAt
    #     transitionWTo = swX.ceil

    #     fillAt = transitionWTo


    #   if slopeEUp:

    #     fillTo = seX.floor

    #     transitionEAt = fillTo
    #     transitionETo = seX.ceil

    #     slopeEAt = transitionETo
    #     slopeETo = neX.floor

    #     endEAt = slopeETo
    #     endETo = neX.ceil

    #   else:

    #     fillTo = neX.floor

    #     transitionEAt = fillTo
    #     transitionETo = neX.ceil

    #     slopeEAt = transitionETo
    #     slopeETo = seX.floor

    #     endEAt = slopeETo
    #     endETo = seX.ceil


    #   let
    #     segat = vec2(line.atx, cutLines[currCutLine])
    #     segto = vec2(line.tox, cutLines[currCutLine + 1])


    #     var area = pixelCover(segat - vec2(x.float32, y.float32), segto - vec2(x.float32, y.float32))
    #     if i mod 2 == 1:
    #       area = -area


    #   #print endWAt, slopeWAt, transitionWAt, fillAt, fillTo, transitionEAt, slopeEAt, endEAt

    #   # if nwX < swX:
    #   #   print nwX.int, swX.int
    #   #   for x in nwX.int ..< swX.int:
    #   #     var a = 0.5 # ((x.float32 - nwX) / (swX - nwX))
    #   #     #print a
    #   #     write(x, y, a.clamp(0, a))
    #   # else:
    #   #   for x in swX.int ..< nwX.int:
    #   #     var a = 0.5 #((x.float32 - swX) / (nwX - swX))
    #   #     #print a
    #   #     write(x, y, a.clamp(0, a))

    #   #write(wX.int, y, 1 - (wX - wX.floor))

    #   # for x in endWAt.int ..< endWTo.int:
    #   #   write(x, y, 0.1)

    #   # for x in slopeWAt.int ..< slopeWTo.int:
    #   #   write(x, y, 0.25)

    #   # for x in transitionWAt.int ..< transitionWTo.int:
    #   #   write(x, y, 0.50)

    #   for x in fillAt.int ..< fillTo.int:
    #     write(x, y, 1)

    #   # for x in transitionEAt.int ..< transitionETo.int:
    #   #   write(x, y, 0.50)

    #   # for x in slopeEAt.int ..< slopeETo.int:
    #   #   write(x, y, 0.25)

    #   # for x in endEAt.int ..< endETo.int:
    #   #   write(x, y, 0.1)

    #   # print 1 - (eX - eX.floor)
    #   # write(eX.int - 1, y, 1 - (eX - eX.floor))

    #   # if neX < seX:
    #   #   for x in neX.int ..< seX.int:
    #   #     var a = 0.5 # ((neX - x.float32) / (seX - neX))
    #   #     #print a
    #   #     write(x, y, a.clamp(0, a))
    #   # else:
    #   #   for x in seX.int ..< neX.int:
    #   #     var a = 0.5 # ((seX - x.float32) / (neX - seX))
    #   #     #print a
    #   #     write(x, y, a.clamp(0, a))

    #   i += 2

    # let quality = 5
    # for m in 0 ..< quality:
    #   let
    #     sweepHeight = cutLines[currCutLine + 1] - cutLines[currCutLine]
    #     yFrac = (y.float32 + (m.float32 / quality.float32) - cutLines[currCutLine]) / sweepHeight
    #   if yFrac < 0.0 or yFrac >= 1.0:
    #     continue
    #   var i = 0
    #   while i < sweep.len:
    #     let
    #       minXf1 = mix(sweep[i+0].at.x, sweep[i+0].to.x, yFrac)
    #       maxXf1 = mix(sweep[i+1].at.x, sweep[i+1].to.x, yFrac)
    #       minXi1 = minXf1.int
    #       maxXi1 = maxXf1.int
    #     for x in minXi1 ..< maxXi1:
    #       let backdrop = mask.getValueUnsafe(x, y)
    #       mask.setValueUnsafe(x, y, backdrop + (255 div quality).uint8)
    #       # if x == 100 and y == 165:
    #       #   print backdrop, 255 div quality
    #       #   print mask.getValueUnsafe(x, y)
    #     i += 2

    # let
    #   sweepHeight = cutLines[currCutLine + 1] - cutLines[currCutLine]
    #   yFrac = (y.float32 - cutLines[currCutLine]) / sweepHeight
    # var i = 0
    # while i < sweep.len:
    #   let
    #     minXf1 = mix(sweep[i+0].atx, sweep[i+0].tox, yFrac)
    #     maxXf1 = mix(sweep[i+1].atx, sweep[i+1].tox, yFrac)
    #     minXi1 = minXf1.floor.int
    #     maxXi1 = maxXf1.floor.int
    #   for x in minXi1 .. maxXi1:
    #     mask.setValueUnsafe(x, y, 255)
    #   i += 2

  var
    currCutLine = 0
  for scanLine in cutLines[0].int ..< cutLines[^1].ceil.int:
    #print scanLine, "..<", scanLine + 1
    #print "  ", currCutLine, cutLines[currCutLine], "..<", cutLines[currCutLine + 1]
    fillCoverage(scanLine, currCutLine, sweeps[currCutLine])

    while cutLines[currCutLine + 1] < scanLine.float + 1.0:
      inc currCutLine
      if currCutLine == sweeps.len:
        break
      #print "  ", currCutLine, cutLines[currCutLine], "..<", cutLines[currCutLine + 1]
      fillCoverage(scanLine, currCutLine, sweeps[currCutLine])

  # print sweeps[^1]
  # print cutLines




  # var segments: seq[Segment]
  # while segments1.len > 0:
  #   #print segments1.len, segments.len
  #   var s = segments1.pop()
  #   var collision = false
  #   for y in cutLines:
  #     let scanLine = line(vec2(0, y), vec2(1, y))
  #     var at: Vec2
  #     if intersects(scanLine, s, at):
  #       at = at.roundBy(q)
  #       at.y = y
  #       if s.at.y != at.y and s.to.y != at.y:
  #         #print "seg2yline intersects!", a, y, at
  #         collision = true
  #         var s1 = segment(s.at, at)
  #         var s2 = segment(at, s.to)
  #         #print s.length, "->", s1.length, s2.length
  #         segments1.add(s1)
  #         segments1.add(s2)
  #         break

  #   if not collision:
  #     # means its touching, not intersecting
  #     segments.add(s)

  # # sort at/to in segments
  # # for s in segments.mitems:
  # #   if s.at.y > s.to.y:
  # #     swap(s.at, s.to)


  # #let blender = blendMode.blender()

  # for yScanLine in cutLines[0..^2]:

  #   var scanSegments: seq[Segment]
  #   for s in segments:
  #     if s.at.y == yScanLine:
  #       scanSegments.add(s)
  #   scanSegments.sort(proc(a, b: Segment): int =
  #     cmp(a.at.x, b.at.x))

  #   # if scanSegments.len mod 2 != 0:
  #   #   print "error???"
  #   #   print yScanLine
  #   #   print scanSegments
  #   #   quit()

  #   # TODO: winding rules will go here

  #   var trapezoids: seq[Trapezoid]
  #   for i in 0 ..< scanSegments.len div 2:
  #     let
  #       a = scanSegments[i*2+0]
  #       b = scanSegments[i*2+1]

  #     assert a.at.y == b.at.y
  #     assert a.to.y == b.to.y
  #     #assert a.at.x < b.at.x
  #     #assert a.to.x < b.to.x

  #     trapezoids.add(Trapezoid(
  #       nw: a.at,
  #       ne: b.at,
  #       se: b.to, # + vec2(0,0.7),
  #       sw: a.to # + vec2(0,0.7)
  #     ))

  #   var i = 0
  #   while i < trapezoids.len:

  #     let t = trapezoids[i]
  #     # print t
  #     let
  #       nw = t.nw
  #       ne = t.ne
  #       se = t.se
  #       sw = t.sw

  #     let
  #       height = sw.y - nw.y
  #       minYf = nw.y
  #       maxYf = sw.y
  #       minYi = minYf.floor.int
  #       maxYi = maxYf.floor.int

  #     # print t

  #     for y in minYi .. maxYi:
  #       let
  #         yFrac = (y.float - nw.y) / height
  #         minXf = mix(nw.x, sw.x, yFrac)
  #         maxXf = mix(ne.x, se.x, yFrac)
  #         minXi = minXf.floor.int
  #         maxXi = maxXf.floor.int
  #       #print yFrac
  #       # if not(minY.int == 58 or maxY.int == 58) or minX > 100:
  #       #   continue

  #       var ay: float32
  #       if y == minYi and y == maxYi:
  #         ay = maxYf - minYf
  #         # print "middle", maxYf, minYf, a
  #         #print "double", y, a, minY, maxY, round(a * 255)
  #       elif y == minYi:
  #         ay = (1 - (minYf - float32(minYi)))
  #         # print "min y", minYf, minYi, a
  #         #print "s", y, a, minY, round(a * 255)
  #       elif y == maxYi:
  #         ay = (maxYf - float32(maxYi))
  #         #print "max y", maxYf, maxYi, a
  #         # print "e", y, a, maxY, round(a * 255)
  #       else:
  #         ay = 1.0

  #       for x in minXi .. maxXi:
  #         var ax: float32
  #         # if x == minXi:
  #         #   a2 = (1 - (minXf - float32(minXi)))
  #         #   #a2 = 1.0
  #         # elif x == maxXi:
  #         #   a2 = (maxXf - float32(maxXi))
  #         #   #a2 = 1.0
  #         # else:
  #         #   a2 = 1.0

  #         if x.float32 < max(nw.x, sw.x):
  #           ax = 0.5
  #         elif x.float32 > min(ne.x, se.x):
  #           ax = 0.25
  #         else:
  #           ax = 1.0

  #         let backdrop = mask.getValueUnsafe(x, y)
  #         mask.setValueUnsafe(x, y, backdrop + floor(255 * ay * ax).uint8)
  #         # if x == 100 and y == 172:
  #         #   print backdrop, round(255 * a * a2).uint8
  #         #   print mask.getValueUnsafe(x, y)

  #     inc i

block:
  # Rect
  print "rect"
  #var image = newImage(200, 200)

  # rect
  # var p = Path()
  # p.moveTo(50.5, 50.5)
  # p.lineTo(50.5, 150.5)
  # p.lineTo(150.5, 150.5)
  # p.lineTo(150.5, 50.5)
  # p.closePath()

  ## rhobus
  var p = Path()
  p.moveTo(100, 50)
  p.lineTo(150, 100)
  p.lineTo(100, 150)
  p.lineTo(50, 100)
  p.closePath()

  # ## heart
  # var p = parsePath("""
  #   M 20 60
  #   A 40 40 90 0 1 100 60
  #   A 40 40 90 0 1 180 60
  #   Q 180 120 100 180
  #   Q 20 120 20 60
  #   z
  # """)

  ## cricle
  # var p = Path()
  # p.arc(100, 100, 50, 0, PI * 2, true)
  # p.closePath()

  # image.fill(rgba(255, 255, 255, 255))
  #image.fillPath2(p, color(0, 0, 0, 1))

  var mask = newMask(200, 200)
  timeIt "rect sweeps", 100:
    for i in 0 ..< 100:
      mask.fill(0)
      mask.fillPath2(p)
      #image.fillPath2(p, color(0, 0, 0, 1))
  mask.writeFile("experiments/trapezoids/output_sweep.png")

  var mask2 = newMask(200, 200)
  timeIt "rect scanline", 10:
    for i in 0 ..< 100:
      mask2.fill(0)
      mask2.fillPath(p)
  mask2.writeFile("experiments/trapezoids/output_scanline.png")

  let (score, image) = diff(mask.newImage, mask2.newImage)
  print score
  image.writeFile("experiments/trapezoids/output_diff.png")



# block:
#   # Rhombus
#   print "rhombus"
#   var image = newImage(200, 200)
#   image.fill(rgba(255, 255, 255, 255))

#   var p = Path()
#   p.moveTo(100, 50)
#   p.lineTo(150, 100)
#   p.lineTo(100, 150)
#   p.lineTo(50, 100)
#   p.closePath()

#   image.fillPath2(p, color(0, 0, 0, 1))

#   image.writeFile("experiments/trapezoids/rhombus.png")

# block:
#   # heart
#   print "heart"
#   var image = newImage(400, 400)
#   image.fill(rgba(0, 0, 0, 0))

#   var p = parsePath("""
#     M 40 120 A 80 80 90 0 1 200 120 A 80 80 90 0 1 360 120
#     Q 360 240 200 360 Q 40 240 40 120 z
#   """)

#   var mask = newMask(image)
#   mask.fillPath2(p)

#   image.draw(mask, blendMode = OverwriteBlend)

#   image.writeFile("experiments/trapezoids/heart.png")

# block:
#   # l
#   print "l"
#   var image = newImage(500, 800)
#   image.fill(rgba(255, 255, 255, 255))

#   var p = parsePath("""
#     M 236 20 Q 150 22 114 57 T 78 166 V 790 L 171 806 V 181 Q 171 158 175 143 T 188 119 T 212 105.5 T 249 98 Z
#   """)

#   image.fillPath2(p, color(0, 0, 0, 1))

#   image.writeFile("experiments/trapezoids/l.png")

# block:
#   # g
#   print "g"
#   var image = newImage(500, 800)
#   image.fill(rgba(255, 255, 255, 255))

#   var p = parsePath("""
#     M 406 538 Q 394 546 359.5 558.5 T 279 571 Q 232 571 190.5 556 T 118 509.5 T 69 431 T 51 319 Q 51 262 68 214.5 T 117.5 132.5 T 197 78.5 T 303 59 Q 368 59 416.5 68.5 T 498 86 V 550 Q 498 670 436 724 T 248 778 Q 199 778 155.5 770 T 80 751 L 97 670 Q 125 681 165.5 689.5 T 250 698 Q 333 698 369.5 665 T 406 560 V 538 Z M 405 152 Q 391 148 367.5 144.5 T 304 141 Q 229 141 188.5 190 T 148 320 Q 148 365 159.5 397 T 190.5 450 T 235.5 481 T 288 491 Q 325 491 356 480.5 T 405 456 V 152 Z
#   """)

#   image.fillPath2(p, color(0, 0, 0, 1))

#   image.writeFile("experiments/trapezoids/g.png")



================================================
FILE: experiments/sweeps2.nim
================================================

import algorithm, bumpy, chroma, pixie/images, print,
    vmath, benchy, fidget2/measure

import pixie, pixie/paths {.all.}

when defined(release):
  {.push checks: off.}

proc pixelCover(a0, b0: Vec2): float32 =
  ## Returns the amount of area a given segment sweeps to the right
  ## in a [0,0 to 1,1] box.
  var
    a = a0
    b = b0
    aI: Vec2
    bI: Vec2
    area: float32 = 0.0

  # # Sort A on top.
  # if a.y > b.y:
  #   let tmp = a
  #   a = b
  #   b = tmp

  # if (b.y < 0 or a.y > 1) or # Above or bellow, no effect.
  #   (a.x >= 1 and b.x >= 1) or # To the right, no effect.
  #   (a.y == b.y): # Horizontal line, no effect.
  #   return 0

  if (a.x < 0 and b.x < 0) or # Both to the left.
    (a.x == b.x): # Vertical line
    # Area of the rectangle:
    return (1 - clamp(a.x, 0, 1)) * (min(b.y, 1) - max(a.y, 0))

  else:
    # y = mm*x + bb
    let
      mm: float32 = (b.y - a.y) / (b.x - a.x)
      bb: float32 = a.y - mm * a.x

    if a.x >= 0 and a.x <= 1 and a.y >= 0 and a.y <= 1:
      # A is in pixel bounds.
      aI = a
    else:
      aI = vec2((0 - bb) / mm, 0)
      if aI.x < 0:
        let y = mm * 0 + bb
        # Area of the extra rectangle.
        area += (min(bb, 1) - max(a.y, 0)).clamp(0, 1)
        aI = vec2(0, y.clamp(0, 1))
      elif aI.x > 1:
        let y = mm * 1 + bb
        aI = vec2(1, y.clamp(0, 1))

    if b.x >= 0 and b.x <= 1 and b.y >= 0 and b.y <= 1:
      # B is in pixel bounds.
      bI = b
    else:
      bI = vec2((1 - bb) / mm, 1)
      if bI.x < 0:
        let y = mm * 0 + bb
        # Area of the extra rectangle.
        area += (min(b.y, 1) - max(bb, 0)).clamp(0, 1)
        bI = vec2(0, y.clamp(0, 1))
      elif bI.x > 1:
        let y = mm * 1 + bb
        bI = vec2(1, y.clamp(0, 1))

  area += ((1 - aI.x) + (1 - bI.x)) / 2 * (bI.y - aI.y)
  return area

proc intersectsInner*(a, b: Segment, at: var Vec2): bool {.inline.} =
  ## Checks if the a segment intersects b segment.
  ## If it returns true, at will have point of intersection
  let
    s1 = a.to - a.at
    s2 = b.to - b.at
    denominator = (-s2.x * s1.y + s1.x * s2.y)
    s = (-s1.y * (a.at.x - b.at.x) + s1.x * (a.at.y - b.at.y)) / denominator
    t = (s2.x * (a.at.y - b.at.y) - s2.y * (a.at.x - b.at.x)) / denominator

  if s > 0 and s < 1 and t > 0 and t < 1:
    #print s, t
    at = a.at + (t * s1)
    return true

type

  Trapezoid = object
    nw, ne, se, sw: Vec2

  Line = object
    #m, x, b: float32
    atx, tox: float32
    winding: int16

proc toLine(s: (Segment, int16)): Line =
  var line = Line()
  # y = mx + b
  line.atx = s[0].at.x
  line.tox = s[0].to.x
  line.winding = s[1]
  # line.m = (s.at.y - s.to.y) / (s.at.x - s.to.x)
  # line.b = s.at.y - line.m * s.at.x
  return line

proc roundBy*(v: Vec2, n: float32): Vec2 {.inline.} =
  result.x = sign(v.x) * round(abs(v.x) / n) * n
  result.y = sign(v.y) * round(abs(v.y) / n) * n


proc computeBounds(polygons: seq[seq[Vec2]]): Rect =
  ## Compute the bounds of the segments.
  var
    xMin = float32.high
    xMax = float32.low
    yMin = float32.high
    yMax = float32.low
  for segments in polygons:
    for v in segments:
      xMin = min(xMin, v.x)
      xMax = max(xMax, v.x)
      yMin = min(yMin, v.y)
      yMax = max(yMax, v.y)

  if xMin.isNaN() or xMax.isNaN() or yMin.isNaN() or yMax.isNaN():
    discard
  else:
    result.x = xMin
    result.y = yMin
    result.w = xMax - xMin
    result.h = yMax - yMin

proc binaryInsert(arr: var seq[float32], v: float32) =
  if arr.len == 0:
    arr.add(v)
    return
  var
    L = 0
    R = arr.len - 1
  while L < R:
    let m = (L + R) div 2
    if arr[m] ~= v:
      return
    elif arr[m] < v:
      L = m + 1
    else: # arr[m] > v:
      R = m - 1
  if arr[L] ~= v:
    return
  elif arr[L] > v:
    #print "insert", v, arr, L, R
    arr.insert(v, L)
  else:
    #print "insert", v, arr, L, R
    arr.insert(v, L + 1)


proc fillPath2(image: Image, p: Path, color: Color, windingRule = NonZero, blendMode = NormalBlend) =
  const q = 1/256.0
  let rgbx = color.rgbx
  var segments = p.commandsToShapes(true, 1.0).shapesToSegments()
  let
    bounds = computeBounds(segments).snapToPixels()
    startX = max(0, bounds.x.int)

  # Create sorted segments and quantize.
  segments.sort(proc(a, b: (Segment, int16)): int = cmp(a[0].at.y, b[0].at.y))

  # Compute cut lines
  var cutLines: seq[float32]
  for s in segments:
    cutLines.binaryInsert(s[0].at.y)
    cutLines.binaryInsert(s[0].to.y)

  var
    sweeps = newSeq[seq[Line]](cutLines.len - 1) # dont add bottom cutLine
    lastSeg = 0
    i = 0
  while i < sweeps.len:

    #for i, sweep in sweeps.mpairs:
    #print "sweep", i, cutLines[i]

    if lastSeg < segments.len:

      while segments[lastSeg][0].at.y == cutLines[i]:
        let s = segments[lastSeg]

        if s[0].at.y != s[0].to.y:

          #print s
          if s[0].to.y != cutLines[i + 1]:
            #print "needs cut?", s

            #quit("need to cut lines")
            var at: Vec2
            var seg = s[0]
            for j in i ..< sweeps.len:
              let y = cutLines[j + 1]
              if intersects(line(vec2(0, y), vec2(1, y)), seg, at):
                #print "cutting", j, seg
                #print "add cut", j, segment(seg.at, at)
                sweeps[j].add(toLine((segment(seg.at, at), s[1])))
                seg = segment(at, seg.to)
              else:
                if seg.at.y != seg.to.y:
                  #print "add rest", j, segment(seg.at, seg.to)
                  sweeps[j].add(toLine(s))
                # else:
                #   print "micro?"
                break
          else:
            #print "add", s
            sweeps[i].add(toLine(s))

        inc lastSeg

        if lastSeg >= segments.len:
          break
    inc i

  i = 0
  while i < sweeps.len:
    for t in 0 ..< 10:
      # keep cutting sweep
      var needsCut = false
      var cutterLine: float32 = 0
      block doubleFor:
        for a in sweeps[i]:
          let aSeg = segment(vec2(a.atx, cutLines[i]), vec2(a.tox, cutLines[i+1]))
          for b in sweeps[i]:
            let bSeg = segment(vec2(b.atx, cutLines[i]), vec2(b.tox, cutLines[i+1]))
            var at: Vec2
            if intersectsInner(aSeg, bSeg, at):
              needsCut = true
              cutterLine = at.y
              break doubleFor
      if needsCut:
        var
          thisSweep = sweeps[i]
        sweeps[i].setLen(0)
        sweeps.insert(newSeq[Line](), i + 1)
        for a in thisSweep:
          let seg = segment(vec2(a.atx, cutLines[i]), vec2(a.tox, cutLines[i+1]))
          var at: Vec2
          if intersects(line(vec2(0, cutterLine), vec2(1, cutterLine)), seg, at):
            sweeps[i+0].add(toLine((segment(seg.at, at), a.winding)))
            sweeps[i+1].add(toLine((segment(at, seg.to), a.winding)))
        cutLines.binaryInsert(cutterLine)
      else:
        break
    inc i


  i = 0
  while i < sweeps.len:
    # Sort the sweep by X
    sweeps[i].sort proc(a, b: Line): int =
      result = cmp(a.atx, b.atx)
      if result == 0:
        result = cmp(a.tox, b.tox)

    # Do winding order
    var
      pen = 0
      prevFill = false
      j = 0
    # print "sweep", i, "--------------"
    while j < sweeps[i].len:
      let a = sweeps[i][j]
      # print a.winding
      if a.winding == 1:
        inc pen
      if a.winding == -1:
        dec pen
      # print j, pen, prevFill, shouldFill(windingRule, pen)
      let thisFill = shouldFill(windingRule, pen)
      if prevFill == thisFill:
        # remove this line
        # print "remove", j
        sweeps[i].delete(j)
        continue
      prevFill = thisFill
      inc j

    # print sweeps[i]

    inc i

  #print sweeps
  # for s in 0 ..< sweeps.len:
  #   let
  #     y1 = cutLines[s]
  #   echo "M -100 ", y1
  #   echo "L 300 ", y1
  #   for line in sweeps[s]:
  #     let
  #       nw = vec2(line.atx, cutLines[s])
  #       sw = vec2(line.tox, cutLines[s + 1])
  #     echo "M ", nw.x, " ", nw.y
  #     echo "L ", sw.x, " ", sw.y

  proc computeCoverage(
    coverages: var seq[uint8],
    y: int,
    startX: int,
    cutLines: seq[float32],
    currCutLine: int,
    sweep: seq[Line]
  ) =

    # if sweep.len mod 2 != 0:
    #   return

    let
      sweepHeight = cutLines[currCutLine + 1] - cutLines[currCutLine]
      yFracTop = ((y.float32 - cutLines[currCutLine]) / sweepHeight).clamp(0, 1)
      yFracBottom = ((y.float32 + 1 - cutLines[currCutLine]) / sweepHeight).clamp(0, 1)
    var i = 0
    while i < sweep.len:
      let
        nwX = mix(sweep[i+0].atx, sweep[i+0].tox, yFracTop)
        neX = mix(sweep[i+1].atx, sweep[i+1].tox, yFracTop)

        swX = mix(sweep[i+0].atx, sweep[i+0].tox, yFracBottom)
        seX = mix(sweep[i+1].atx, sweep[i+1].tox, yFracBottom)

        minWi = min(nwX, swX).int
        maxWi = max(nwX, swX).ceil.int

        minEi = min(neX, seX).int
        maxEi = max(neX, seX).ceil.int

      let
        nw = vec2(sweep[i+0].atx, cutLines[currCutLine])
        sw = vec2(sweep[i+0].tox, cutLines[currCutLine + 1])
      for x in minWi ..< maxWi:
        var area = pixelCover(nw - vec2(x.float32, y.float32), sw - vec2(x.float32, y.float32))
        coverages[x - startX] += (area * 255).uint8

      let x = maxWi
      var midArea = pixelCover(nw - vec2(x.float32, y.float32), sw - vec2(x.float32, y.float32))
      var midArea8 = (midArea * 255).uint8
      for x in maxWi ..< minEi:
        coverages[x - startX] += midArea8

      let
        ne = vec2(sweep[i+1].atx, cutLines[currCutLine])
        se = vec2(sweep[i+1].tox, cutLines[currCutLine + 1])
      for x in minEi ..< maxEi:
        var area = midArea - pixelCover(ne - vec2(x.float32, y.float32), se - vec2(x.float32, y.float32))
        coverages[x - startX] += (area * 255).uint8

      i += 2

  var
    currCutLine = 0
    coverages = newSeq[uint8](bounds.w.int)
  for scanLine in cutLines[0].int ..< cutLines[^1].ceil.int:
    zeroMem(coverages[0].addr, coverages.len)

    coverages.computeCoverage(scanLine, startX, cutLines, currCutLine, sweeps[currCutLine])
    while cutLines[currCutLine + 1] < scanLine.float + 1.0:
      inc currCutLine
      if currCutLine == sweeps.len:
        break
      coverages.computeCoverage(scanLine, startX, cutLines, currCutLine, sweeps[currCutLine])

    image.fillCoverage(
      rgbx,
      startX = startX,
      y = scanLine,
      coverages,
      blendMode
    )

when defined(release):
  {.pop.}


template test(name: string, p: Path, a: static int = 1, wr = NonZero) =
  echo name
  var image = newImage(200, 200)
  timeIt "  sweeps", a:
    for i in 0 ..< a:
      image.fill(color(0, 0, 0, 0))
      image.fillPath2(p, color(1, 0, 0, 1), windingRule = wr)
  image.writeFile("experiments/trapezoids/output_sweep.png")

  var image2 = newImage(200, 200)
  timeIt "  scanline", a:
    for i in 0 ..< a:
      image2.fill(color(0, 0, 0, 0))
      image2.fillPath(p, color(1, 0, 0, 1), windingRule = wr)
  image2.writeFile("experiments/trapezoids/output_scanline.png")

  let (score, diff) = diff(image, image2)
  if score > 0.05:
    echo "does not appear ot match"
  diff.writeFile("experiments/trapezoids/output_diff.png")


var rect = Path()
rect.moveTo(50.5, 50.5)
rect.lineTo(50.5, 150.5)
rect.lineTo(150.5, 150.5)
rect.lineTo(150.5, 50.5)
rect.closePath()

var rhombus = Path()
rhombus.moveTo(100, 50)
rhombus.lineTo(150, 100)
rhombus.lineTo(100, 150)
rhombus.lineTo(50, 100)
rhombus.closePath()

var heart = parsePath("""
  M 20 60
  A 40 40 90 0 1 100 60
  A 40 40 90 0 1 180 60
  Q 180 120 100 180
  Q 20 120 20 60
  z
""")

var cricle = Path()
cricle.arc(100, 100, 50, 0, PI * 2, true)
cricle.closePath()


# Half arc (test cut lines)
var halfAarc = parsePath("""
  M 25 25 C 85 25 85 125 25 125 z
""")

# Hour glass (test cross lines)
var hourGlass = parsePath("""
  M 20 20 L 180 20 L 20 180 L 180 180 z
""")

# Hole
var hole = parsePath("""
  M 40 40 L 40 160 L 160 160 L 160 40 z
  M 120 80 L 120 120 L 80 120 L 80 80 z
""")

var holeEvenOdd = parsePath("""
  M 40 40 L 40 160 L 160 160 L 160 40 z
  M 80 80 L 80 120 L 120 120 L 120 80 z
""")

## g
var letterG = parsePath("""
  M 406 538 Q 394 546 359.5 558.5 T 279 571 Q 232 571 190.5 556 T 118 509.5 T 69 431 T 51 319 Q 51 262 68 214.5 T 117.5 132.5 T 197 78.5 T 303 59 Q 368 59 416.5 68.5 T 498 86 V 550 Q 498 670 436 724 T 248 778 Q 199 778 155.5 770 T 80 751 L 97 670 Q 125 681 165.5 689.5 T 250 698 Q 333 698 369.5 665 T 406 560 V 538 Z M 405 152 Q 391 148 367.5 144.5 T 304 141 Q 229 141 188.5 190 T 148 320 Q 148 365 159.5 397 T 190.5 450 T 235.5 481 T 288 491 Q 325 491 356 480.5 T 405 456 V 152 Z
""")
letterG.transform(scale(vec2(0.2, 0.2)))

when defined(bench):
  test("rect", rect, 100)
  test("rhombus", rhombus, 100)
  test("heart", heart, 100)
  test("cricle", cricle, 100)
  test("halfAarc", halfAarc, 100)
  test("hourGlass", hourGlass, 100)
  test("hole", hole, 100)
  test("holeNonZero", holeEvenOdd, 100, wr=NonZero)
  test("holeEvenOdd", holeEvenOdd, 100, wr=EvenOdd)
  test("letterG", letterG, 100)
else:
  # test("rect", rect)
  # test("rhombus", rhombus)
  # test("heart", heart)
  # test("cricle", cricle)
  # test("halfAarc", halfAarc)
  # test("hourGlass", hourGlass)
  #test("hole", hole, wr=EvenOdd)
  test("holeNonZero", holeEvenOdd, wr=NonZero)
  test("holeEvenOdd", holeEvenOdd, wr=EvenOdd)
  # test("letterG", letterG)



================================================
FILE: experiments/sweeps3.nim
================================================

import algorithm, chroma, pixie/images, vmath, benchy

import pixie, pixie/paths {.all.}


template test(name: string, p: Path, a: static int = 1, wr = NonZero) =
  echo name
  var image = newImage(200, 200)
  timeIt "  sweeps", a:
    for i in 0 ..< a:
      image.fill(color(0, 0, 0, 0))
      image.fillPath(p, color(1, 0, 0, 1), windingRule = wr)
  image.writeFile("experiments/trapezoids/output_sweep.png")

  # var image2 = newImage(200, 200)
  # timeIt "  scanline", a:
  #   for i in 0 ..< a:
  #     image2.fill(color(0, 0, 0, 0))
  #     image2.fillPath(p, color(1, 0, 0, 1), windingRule = wr)
  # image2.writeFile("experiments/trapezoids/output_scanline.png")

  # let (score, diff) = diff(image, image2)
  # if score > 0.05:
  #   echo "does not appear ot match"
  # diff.writeFile("experiments/trapezoids/output_diff.png")


var rect = Path()
rect.moveTo(50.5, 50.5)
rect.lineTo(50.5, 150.5)
rect.lineTo(150.5, 150.5)
rect.lineTo(150.5, 50.5)
rect.closePath()

var rhombus = Path()
rhombus.moveTo(100, 50)
rhombus.lineTo(150, 100)
rhombus.lineTo(100, 150)
rhombus.lineTo(50, 100)
rhombus.closePath()

var heart = parsePath("""
  M 20 60
  A 40 40 90 0 1 100 60
  A 40 40 90 0 1 180 60
  Q 180 120 100 180
  Q 20 120 20 60
  z
""")

var cricle = Path()
cricle.arc(100, 100, 50, 0, PI * 2, true)
cricle.closePath()


# Half arc (test cut lines)
var halfAarc = parsePath("""
  M 25 25 C 85 25 85 125 25 125 z
""")

# Hour glass (test cross lines)
var hourGlass = parsePath("""
  M 20 20 L 180 20 L 20 180 L 180 180 z
""")

var hourGlass2 = parsePath("""
  M 20 20 L 180 20 L 20 180 L 180 180 z M 62 24 L 132 24 L 50 173 L 156 173 z
""")

# Hole
var hole = parsePath("""
  M 40 40 L 40 160 L 160 160 L 160 40 z
  M 120 80 L 120 120 L 80 120 L 80 80 z
""")

var holeEvenOdd = parsePath("""
  M 40 40 L 40 160 L 160 160 L 160 40 z
  M 80 80 L 80 120 L 120 120 L 120 80 z
""")

## g
var letterG = parsePath("""
  M 406 538 Q 394 546 359.5 558.5 T 279 571 Q 232 571 190.5 556 T 118 509.5 T 69 431 T 51 319 Q 51 262 68 214.5 T 117.5 132.5 T 197 78.5 T 303 59 Q 368 59 416.5 68.5 T 498 86 V 550 Q 498 670 436 724 T 248 778 Q 199 778 155.5 770 T 80 751 L 97 670 Q 125 681 165.5 689.5 T 250 698 Q 333 698 369.5 665 T 406 560 V 538 Z M 405 152 Q 391 148 367.5 144.5 T 304 141 Q 229 141 188.5 190 T 148 320 Q 148 365 159.5 397 T 190.5 450 T 235.5 481 T 288 491 Q 325 491 356 480.5 T 405 456 V 152 Z
""")
letterG.transform(scale(vec2(0.2, 0.2)))

when defined(bench):
  test("rect", rect, 100)
  test("rhombus", rhombus, 100)
  test("heart", heart, 100)
  test("cricle", cricle, 100)
  test("halfAarc", halfAarc, 100)
  test("hourGlass", hourGlass, 100)
  test("hourGlass2", hourGlass2, wr=NonZero)
  test("hourGlass2", hourGlass2, wr=EvenOdd)
  test("hole", hole, 100)
  test("holeEvenOdd", holeEvenOdd, 100, wr=NonZero)
  test("holeEvenOdd", holeEvenOdd, 100, wr=EvenOdd)
  test("letterG", letterG, 100)
else:
  # test("rect", rect)
  # test("rhombus", rhombus)
  # test("heart", heart)
  # test("cricle", cricle)
  # test("halfAarc", halfAarc)
  # test("hourGlass", hourGlass)
  test("hourGlass2", hourGlass2, wr=EvenOdd)
  # test("hole", hole, wr=EvenOdd)
  # test("holeEvenOdd", holeEvenOdd, wr=NonZero)
  # test("holeEvenOdd", holeEvenOdd, wr=EvenOdd)
  # test("letterG", letterG)



================================================
FILE: experiments/sweeps4.nim
================================================

when defined(pixieSweeps):
  import algorithm

  proc pixelCover(a0, b0: Vec2): float32 =
    ## Returns the amount of area a given segment sweeps to the right
    ## in a [0,0 to 1,1] box.
    var
      a = a0
      b = b0
      aI: Vec2
      bI: Vec2
      area: float32 = 0.0

    if (a.x < 0 and b.x < 0) or # Both to the left.
      (a.x == b.x): # Vertical line
      # Area of the rectangle:
      return (1 - clamp(a.x, 0, 1)) * (min(b.y, 1) - max(a.y, 0))

    else:
      # y = mm*x + bb
      let
        mm: float32 = (b.y - a.y) / (b.x - a.x)
        bb: float32 = a.y - mm * a.x

      if a.x >= 0 and a.x <= 1 and a.y >= 0 and a.y <= 1:
        # A is in pixel bounds.
        aI = a
      else:
        aI = vec2((0 - bb) / mm, 0)
        if aI.x < 0:
          let y = mm * 0 + bb
          # Area of the extra rectangle.
          area += (min(bb, 1) - max(a.y, 0)).clamp(0, 1)
          aI = vec2(0, y.clamp(0, 1))
        elif aI.x > 1:
          let y = mm * 1 + bb
          aI = vec2(1, y.clamp(0, 1))

      if b.x >= 0 and b.x <= 1 and b.y >= 0 and b.y <= 1:
        # B is in pixel bounds.
        bI = b
      else:
        bI = vec2((1 - bb) / mm, 1)
        if bI.x < 0:
          let y = mm * 0 + bb
          # Area of the extra rectangle.
          area += (min(b.y, 1) - max(bb, 0)).clamp(0, 1)
          bI = vec2(0, y.clamp(0, 1))
        elif bI.x > 1:
          let y = mm * 1 + bb
          bI = vec2(1, y.clamp(0, 1))

    area += ((1 - aI.x) + (1 - bI.x)) / 2 * (bI.y - aI.y)
    return area

  proc intersectsInner*(a, b: Segment, at: var Vec2): bool {.inline.} =
    ## Checks if the a segment intersects b segment.
    ## If it returns true, at will have point of intersection
    let
      s1 = a.to - a.at
      s2 = b.to - b.at
      denominator = (-s2.x * s1.y + s1.x * s2.y)
      s = (-s1.y * (a.at.x - b.at.x) + s1.x * (a.at.y - b.at.y)) / denominator
      t = (s2.x * (a.at.y - b.at.y) - s2.y * (a.at.x - b.at.x)) / denominator

    if s > 0 and s < 1 and t > 0 and t < 1:
      at = a.at + (t * s1)
      return true

  type

    Trapezoid = object
      nw, ne, se, sw: Vec2

    SweepLine = object
      #m, x, b: float32
      atx, tox: float32
      winding: int16

  proc toLine(s: (Segment, int16)): SweepLine =
    var line = SweepLine()
    line.atx = s[0].at.x
    line.tox = s[0].to.x
    # y = mx + b
    # line.m = (s.at.y - s.to.y) / (s.at.x - s.to.x)
    # line.b = s.at.y - line.m * s.at.x
    line.winding = s[1]
    return line

  proc intersectsYLine(
    y: float32, s: Segment, atx: var float32
  ): bool {.inline.} =
    let
      s2y = s.to.y - s.at.y
      denominator = -s2y
      numerator = s.at.y - y
      u = numerator / denominator
    if u >= 0 and u <= 1:
      let at = s.at + (u * vec2(s.to.x - s.at.x, s2y))
      atx = at.x
      return true

  proc binaryInsert(arr: var seq[float32], v: float32) =
    if arr.len == 0:
      arr.add(v)
      return
    var
      L = 0
      R = arr.len - 1
    while L < R:
      let m = (L + R) div 2
      if arr[m] ~= v:
        return
      elif arr[m] < v:
        L = m + 1
      else: # arr[m] > v:
        R = m - 1
    if arr[L] ~= v:
      return
    elif arr[L] > v:
      arr.insert(v, L)
    else:
      arr.insert(v, L + 1)

  proc sortSegments(segments: var seq[(Segment, int16)], inl, inr: int) =
    ## Quicksort + insertion sort, in-place and faster than standard lib sort.

    let n = inr - inl + 1
    if n < 32: # Use insertion sort for the rest
      for i in inl + 1 .. inr:
        var
          j = i - 1
          k = i
        while j >= 0 and segments[j][0].at.y > segments[k][0].at.y:
          swap(segments[j + 1], segments[j])
          dec j
          dec k
      return
    var
      l = inl
      r = inr
    let p = segments[l + n div 2][0].at.y
    while l <= r:
      if segments[l][0].at.y < p:
        inc l
      elif segments[r][0].at.y > p:
        dec r
      else:
        swap(segments[l], segments[r])
        inc l
        dec r
    sortSegments(segments, inl, r)
    sortSegments(segments, l, inr)

  proc sortSweepLines(segments: var seq[SweepLine], inl, inr: int) =
    ## Quicksort + insertion sort, in-place and faster than standard lib sort.

    proc avg(line: SweepLine): float32 {.inline.} =
      (line.tox + line.atx) / 2.float32

    let n = inr - inl + 1
    if n < 32: # Use insertion sort for the rest
      for i in inl + 1 .. inr:
        var
          j = i - 1
          k = i
        while j >= 0 and segments[j].avg > segments[k].avg:
          swap(segments[j + 1], segments[j])
          dec j
          dec k
      return
    var
      l = inl
      r = inr
    let p = segments[l + n div 2].avg
    while l <= r:
      if segments[l].avg < p:
        inc l
      elif segments[r].avg > p:
        dec r
      else:
        swap(segments[l], segments[r])
        inc l
        dec r
    sortSweepLines(segments, inl, r)
    sortSweepLines(segments, l, inr)

  proc fillShapes(
    image: Image,
    shapes: seq[seq[Vec2]],
    color: SomeColor,
    windingRule: WindingRule,
    blendMode: BlendMode
  ) =

    let rgbx = color.rgbx
    var segments = shapes.shapesToSegments()
    let
      bounds = computeBounds(segments).snapToPixels()
      startX = max(0, bounds.x.int)

    if segments.len == 0 or bounds.w.int == 0 or bounds.h.int == 0:
      return

    # const q = 1/10
    # for i in 0 ..< segments.len:
    #   segments[i][0].at.x = quantize(segments[i][0].at.x, q)
    #   segments[i][0].at.y = quantize(segments[i][0].at.y, q)
    #   segments[i][0].to.x = quantize(segments[i][0].to.x, q)
    #   segments[i][0].to.y = quantize(segments[i][0].to.y, q)

    # Create sorted segments.
    segments.sortSegments(0, segments.high)

    # Compute cut lines
    var cutLines: seq[float32]
    for s in segments:
      cutLines.binaryInsert(s[0].at.y)
      cutLines.binaryInsert(s[0].to.y)

    var
      # Dont add bottom cutLine.
      sweeps = newSeq[seq[SweepLine]](cutLines.len - 1)
      lastSeg = 0
      i = 0
    while i < sweeps.len:

      if lastSeg < segments.len:

        while segments[lastSeg][0].at.y == cutLines[i]:
          let s = segments[lastSeg]

          if s[0].to.y != cutLines[i + 1]:
            var atx: float32
            var seg = s[0]
            for j in i ..< sweeps.len:
              let y = cutLines[j + 1]
              if intersectsYLine(y, seg, atx):
                sweeps[j].add(toLine((segment(seg.at, vec2(atx, y)), s[1])))
                seg = segment(vec2(atx, y), seg.to)
              else:
                if seg.at.y != seg.to.y:
                  sweeps[j].add(toLine(s))
                break
          else:
            sweeps[i].add(toLine(s))

          inc lastSeg
          if lastSeg >= segments.len:
            break
      inc i

    # i = 0
    # while i < sweeps.len:
    #   # TODO: Maybe finds all cuts first, add them to array, cut all lines at once.
    #   var crossCuts: seq[float32]

    #   # echo i, " cut?"

    #   for aIndex in 0 ..< sweeps[i].len:
    #     let a = sweeps[i][aIndex]
    #     # echo i, ":", sweeps.len, ":", cutLines.len
    #     let aSeg = segment(vec2(a.atx, cutLines[i]), vec2(a.tox, cutLines[i+1]))
    #     for bIndex in aIndex + 1 ..< sweeps[i].len:
    #       let b = sweeps[i][bIndex]
    #       let bSeg = segment(vec2(b.atx, cutLines[i]), vec2(b.tox, cutLines[i+1]))
    #       var at: Vec2
    #       if intersectsInner(aSeg, bSeg, at):
    #         crossCuts.binaryInsert(at.y)

    #   if crossCuts.len > 0:
    #     var
    #       thisSweep = sweeps[i]
    #       yTop = cutLines[i]
    #       yBottom = cutLines[i + 1]
    #     sweeps[i].setLen(0)

    #     for k in crossCuts:
    #       let prevLen = cutLines.len
    #       cutLines.binaryInsert(k)
    #       if prevLen != cutLines.len:
    #         sweeps.insert(newSeq[SweepLine](), i + 1)

    #     for a in thisSweep:
    #       var seg = segment(vec2(a.atx, yTop), vec2(a.tox, yBottom))
    #       var at: Vec2
    #       for j, cutterLine in crossCuts:
    #         if intersects(line(vec2(0, cutterLine), vec2(1, cutterLine)), seg, at):
    #           sweeps[i+j].add(toLine((segment(seg.at, at), a.winding)))
    #           seg = segment(at, seg.to)
    #       sweeps[i+crossCuts.len].add(toLine((seg, a.winding)))

    #     i += crossCuts.len

    #   inc i

    i = 0
    while i < sweeps.len:
      # Sort the sweep by X
      sweeps[i].sortSweepLines(0, sweeps[i].high)
      # Do winding order
      var
        pen = 0
        prevFill = false
        j = 0
      while j < sweeps[i].len:
        let a = sweeps[i][j]
        if a.winding == 1:
          inc pen
        if a.winding == -1:
          dec pen
        let thisFill = shouldFill(windingRule, pen)
        if prevFill == thisFill:
          # Remove this sweep line.
          sweeps[i].delete(j)
          continue
        prevFill = thisFill
        inc j
      inc i

    # Used to debug sweeps:
    # for s in 0 ..< sweeps.len:
    #   let
    #     y1 = cutLines[s]
    #   echo "M -100 ", y1
    #   echo "L 300 ", y1
    #   for line in sweeps[s]:
    #     let
    #       nw = vec2(line.atx, cutLines[s])
    #       sw = vec2(line.tox, cutLines[s + 1])
    #     echo "M ", nw.x, " ", nw.y
    #     echo "L ", sw.x, " ", sw.y

    proc computeCoverage(
      coverages: var seq[uint16],
      y: int,
      startX: int,
      cutLines: seq[float32],
      currCutLine: int,
      sweep: seq[SweepLine]
    ) =

      if cutLines[currCutLine + 1] - cutLines[currCutLine] < 1/256:
        # TODO some thing about micro sweeps
        return

      let
        sweepHeight = cutLines[currCutLine + 1] - cutLines[currCutLine]
        yFracTop = ((y.float32 - cutLines[currCutLine]) / sweepHeight).clamp(0, 1)
        yFracBottom = ((y.float32 + 1 - cutLines[currCutLine]) /
            sweepHeight).clamp(0, 1)
      var i = 0
      while i < sweep.len:
        let
          nwX = mix(sweep[i+0].atx, sweep[i+0].tox, yFracTop)
          neX = mix(sweep[i+1].atx, sweep[i+1].tox, yFracTop)

          swX = mix(sweep[i+0].atx, sweep[i+0].tox, yFracBottom)
          seX = mix(sweep[i+1].atx, sweep[i+1].tox, yFracBottom)

          minWi = min(nwX, swX).int      #.clamp(startX, coverages.len + startX)
          maxWi = max(nwX, swX).ceil.int #.clamp(startX, coverages.len + startX)

          minEi = min(neX, seX).int      #.clamp(startX, coverages.len + startX)
          maxEi = max(neX, seX).ceil.int #.clamp(startX, coverages.len + startX)

        let
          nw = vec2(sweep[i+0].atx, cutLines[currCutLine])
          sw = vec2(sweep[i+0].tox, cutLines[currCutLine + 1])
          f16 = (256 * 256 - 1).float32
        for x in minWi ..< maxWi:
          var area = pixelCover(
            nw - vec2(x.float32, y.float32),
            sw - vec2(x.float32, y.float32)
          )
          coverages[x - startX] += (area * f16).uint16

        let x = maxWi
        var midArea = pixelCover(
          nw - vec2(x.float32, y.float32),
          sw - vec2(x.float32, y.float32)
        )
        for x in maxWi ..< maxEi:
          coverages[x - startX] += (midArea * f16).uint16

        let
          ne = vec2(sweep[i+1].atx, cutLines[currCutLine])
          se = vec2(sweep[i+1].tox, cutLines[currCutLine + 1])
        for x in minEi ..< maxEi:
          var area = pixelCover(
            ne - vec2(x.float32, y.float32),
            se - vec2(x.float32, y.float32)
          )
          coverages[x - startX] -= (area * f16).uint16

        i += 2

    var
      currCutLine = 0
      coverages16 = newSeq[uint16](bounds.w.int)
      coverages8 = newSeq[uint8](bounds.w.int)
    for scanLine in max(cutLines[0].int, 0) ..< min(cutLines[^1].ceil.int, image.height):

      zeroMem(coverages16[0].addr, coverages16.len * 2)

      coverages16.computeCoverage(
        scanLine, startX, cutLines, currCutLine, sweeps[currCutLine])
      while cutLines[currCutLine + 1] < scanLine.float + 1.0:
        inc currCutLine
        if currCutLine == sweeps.len:
          break
        coverages16.computeCoverage(
          scanLine, startX, cutLines, currCutLine, sweeps[currCutLine])

      for i in 0 ..< coverages16.len:
        coverages8[i] = (coverages16[i] shr 8).uint8
      image.fillCoverage(
        rgbx,
        startX = startX,
        y = scanLine,
        coverages8,
        blendMode
      )

else:



================================================
FILE: experiments/trapezoid.nim
================================================

import algorithm, bumpy, chroma, pixie/images, print,
    sequtils, vmath, benchy

import pixie, pixie/paths {.all.}


printColors = false

proc intersectsInner*(a, b: Segment, at: var Vec2): bool {.inline.} =
  ## Checks if the a segment intersects b segment.
  ## If it returns true, at will have point of intersection
  let
    s1 = a.to - a.at
    s2 = b.to - b.at
    denominator = (-s2.x * s1.y + s1.x * s2.y)
    s = (-s1.y * (a.at.x - b.at.x) + s1.x * (a.at.y - b.at.y)) / denominator
    t = (s2.x * (a.at.y - b.at.y) - s2.y * (a.at.x - b.at.x)) / denominator

  if s > 0 and s < 1 and t >= 0 and t <= 1:
    at = a.at + (t * s1)
    return true

type Trapezoid = object
  nw, ne, se, sw: Vec2

proc roundBy*(v: Vec2, n: float32): Vec2 {.inline.} =
  result.x = sign(v.x) * round(abs(v.x) / n) * n
  result.y = sign(v.y) * round(abs(v.y) / n) * n

proc fillPath2(mask: Mask, p: Path) =

  var polygons = p.commandsToShapes()

  const q = 1/256.0

  # Creates segment q, quantize and remove verticals.
  var segments1: seq[Segment]
  for shape in polygons:
    for s in shape.segments:
      var s = s
      s.at = s.at.roundBy(q)
      s.to = s.to.roundBy(q)
      if s.at.y != s.to.y:
        if s.at.y > s.to.y:
          # make sure segments always are at.y higher
          swap(s.at, s.to)
        segments1.add(s)

  # There is probably a clever way to insert-sort them.
  var yScanLines: seq[float32]
  for s in segments1:
    if s.at.y notin yScanLines:
      yScanLines.add s.at.y
    if s.to.y notin yScanLines:
      yScanLines.add s.to.y
  yScanLines.sort()
  print yScanLines

  var segments: seq[Segment]
  while segments1.len > 0:
    #print segments1.len, segments.len
    var s = segments1.pop()
    var collision = false
    for y in yScanLines:
      let scanLine = line(vec2(0, y), vec2(1, y))
      var at: Vec2
      if intersects(scanLine, s, at):
        at = at.roundBy(q)
        at.y = y
        if s.at.y != at.y and s.to.y != at.y:
          #print "seg2yline intersects!", a, y, at
          collision = true
          var s1 = segment(s.at, at)
          var s2 = segment(at, s.to)
          #print s.length, "->", s1.length, s2.length
          segments1.add(s1)
          segments1.add(s2)
          break

    if not collision:
      # means its touching, not intersecting
      segments.add(s)

  # sort at/to in segments
  # for s in segments.mitems:
  #   if s.at.y > s.to.y:
  #     swap(s.at, s.to)


  #let blender = blendMode.blender()

  for yScanLine in yScanLines[0..^2]:

    var scanSegments: seq[Segment]
    for s in segments:
      if s.at.y == yScanLine:
        scanSegments.add(s)
    scanSegments.sort(proc(a, b: Segment): int =
      cmp(a.at.x, b.at.x))

    # if scanSegments.len mod 2 != 0:
    #   print "error???"
    #   print yScanLine
    #   print scanSegments
    #   quit()

    # TODO: winding rules will go here

    var trapezoids: seq[Trapezoid]
    for i in 0 ..< scanSegments.len div 2:
      let
        a = scanSegments[i*2+0]
        b = scanSegments[i*2+1]

      assert a.at.y == b.at.y
      assert a.to.y == b.to.y
      #assert a.at.x < b.at.x
      #assert a.to.x < b.to.x

      trapezoids.add(Trapezoid(
        nw: a.at,
        ne: b.at,
        se: b.to, # + vec2(0,0.7),
        sw: a.to # + vec2(0,0.7)
      ))

    var i = 0
    while i < trapezoids.len:

      let t = trapezoids[i]
      # print t
      let
        nw = t.nw
        ne = t.ne
        se = t.se
        sw = t.sw

      let
        height = sw.y - nw.y
        minYf = nw.y
        maxYf = sw.y
        minYi = minYf.floor.int
        maxYi = maxYf.floor.int

      # print t

      for y in minYi .. maxYi:
        let
          yFrac = (y.float - nw.y) / height
          minXf = mix(nw.x, sw.x, yFrac)
          maxXf = mix(ne.x, se.x, yFrac)
          minXi = minXf.floor.int
          maxXi = maxXf.floor.int
        #print yFrac
        # if not(minY.int == 58 or maxY.int == 58) or minX > 100:
        #   continue

        var ay: float32
        if y == minYi and y == maxYi:
          ay = maxYf - minYf
          # print "middle", maxYf, minYf, a
          #print "double", y, a, minY, maxY, round(a * 255)
        elif y == minYi:
          ay = (1 - (minYf - float32(minYi)))
          # print "min y", minYf, minYi, a
          #print "s", y, a, minY, round(a * 255)
        elif y == maxYi:
          ay = (maxYf - float32(maxYi))
          #print "max y", maxYf, maxYi, a
          # print "e", y, a, maxY, round(a * 255)
        else:
          ay = 1.0

        for x in minXi .. maxXi:
          var ax: float32
          # if x == minXi:
          #   a2 = (1 - (minXf - float32(minXi)))
          #   #a2 = 1.0
          # elif x == maxXi:
          #   a2 = (maxXf - float32(maxXi))
          #   #a2 = 1.0
          # else:
          #   a2 = 1.0

          if x.float32 < max(nw.x, sw.x):
            ax = 0.5
          elif x.float32 > min(ne.x, se.x):
            ax = 0.25
          else:
            ax = 1.0

          let backdrop = mask.getValueUnsafe(x, y)
          mask.setValueUnsafe(x, y, backdrop + floor(255 * ay * ax).uint8)
          # if x == 100 and y == 172:
          #   print backdrop, round(255 * a * a2).uint8
          #   print mask.getValueUnsafe(x, y)

      inc i

block:
  # Rect
  print "rect"
  #var image = newImage(200, 200)

  # var p = Path()
  # p.moveTo(50.25, 50.25)
  # p.lineTo(50.25, 150.25)
  # p.lineTo(150.25, 150.25)
  # p.lineTo(150.25, 50.25)
  # p.closePath()

  var p = parsePath("""
    M 20 60
    A 40 40 90 0 1 100 60
    A 40 40 90 0 1 180 60
    Q 180 120 100 180
    Q 20 120 20 60
    z
  """)

  # image.fill(rgba(255, 255, 255, 255))
  #image.fillPath2(p, color(0, 0, 0, 1))

  var mask = newMask(200, 200)
  timeIt "rect trapezoids", 1:
    #for i in 0 ..< 100:
      mask.fill(0)
      mask.fillPath2(p)
      #image.fillPath2(p, color(0, 0, 0, 1))
  mask.writeFile("experiments/trapezoids/rect_trapesoid.png")

  var mask2 = newMask(200, 200)
  timeIt "rect normal", 1:
    #for i in 0 ..< 100:
      mask2.fill(0)
      mask2.fillPath(p)
  mask2.writeFile("experiments/trapezoids/rect_scanline.png")

  let (score, image) = diff(mask.newImage, mask2.newImage)
  print score
  image.writeFile("experiments/trapezoids/rect_diff.png")



# block:
#   # Rhombus
#   print "rhombus"
#   var image = newImage(200, 200)
#   image.fill(rgba(255, 255, 255, 255))

#   var p = Path()
#   p.moveTo(100, 50)
#   p.lineTo(150, 100)
#   p.lineTo(100, 150)
#   p.lineTo(50, 100)
#   p.closePath()

#   image.fillPath2(p, color(0, 0, 0, 1))

#   image.writeFile("experiments/trapezoids/rhombus.png")

# block:
#   # heart
#   print "heart"
#   var image = newImage(400, 400)
#   image.fill(rgba(0, 0, 0, 0))

#   var p = parsePath("""
#     M 40 120 A 80 80 90 0 1 200 120 A 80 80 90 0 1 360 120
#     Q 360 240 200 360 Q 40 240 40 120 z
#   """)

#   var mask = newMask(image)
#   mask.fillPath2(p)

#   image.draw(mask, blendMode = OverwriteBlend)

#   image.writeFile("experiments/trapezoids/heart.png")

# block:
#   # l
#   print "l"
#   var image = newImage(500, 800)
#   image.fill(rgba(255, 255, 255, 255))

#   var p = parsePath("""
#     M 236 20 Q 150 22 114 57 T 78 166 V 790 L 171 806 V 181 Q 171 158 175 143 T 188 119 T 212 105.5 T 249 98 Z
#   """)

#   image.fillPath2(p, color(0, 0, 0, 1))

#   image.writeFile("experiments/trapezoids/l.png")

# block:
#   # g
#   print "g"
#   var image = newImage(500, 800)
#   image.fill(rgba(255, 255, 255, 255))

#   var p = parsePath("""
#     M 406 538 Q 394 546 359.5 558.5 T 279 571 Q 232 571 190.5 556 T 118 509.5 T 69 431 T 51 319 Q 51 262 68 214.5 T 117.5 132.5 T 197 78.5 T 303 59 Q 368 59 416.5 68.5 T 498 86 V 550 Q 498 670 436 724 T 248 778 Q 199 778 155.5 770 T 80 751 L 97 670 Q 125 681 165.5 689.5 T 250 698 Q 333 698 369.5 665 T 406 560 V 538 Z M 405 152 Q 391 148 367.5 144.5 T 304 141 Q 229 141 188.5 190 T 148 320 Q 148 365 159.5 397 T 190.5 450 T 235.5 481 T 288 491 Q 325 491 356 480.5 T 405 456 V 152 Z
#   """)

#   image.fillPath2(p, color(0, 0, 0, 1))

#   image.writeFile("experiments/trapezoids/g.png")



================================================
FILE: experiments/trapezoid0.nim
================================================

import algorithm, bumpy, chroma, pixie, pixie/images, pixie/paths, print,
    sequtils, vmath

printColors = false

proc intersectsInner*(a, b: Segment, at: var Vec2): bool {.inline.} =
  ## Checks if the a segment intersects b segment.
  ## If it returns true, at will have point of intersection
  let
    s1 = a.to - a.at
    s2 = b.to - b.at
    denominator = (-s2.x * s1.y + s1.x * s2.y)
    s = (-s1.y * (a.at.x - b.at.x) + s1.x * (a.at.y - b.at.y)) / denominator
    t = (s2.x * (a.at.y - b.at.y) - s2.y * (a.at.x - b.at.x)) / denominator

  if s > 0 and s < 1 and t >= 0 and t <= 1:
    at = a.at + (t * s1)
    return true

type Trapezoid = object
  nw, ne, se, sw: Vec2

proc roundBy*(v: Vec2, n: float32): Vec2 {.inline.} =
  result.x = sign(v.x) * round(abs(v.x) / n) * n
  result.y = sign(v.y) * round(abs(v.y) / n) * n

proc pathToTrapezoids(p: Path): seq[Trapezoid] =

  var polygons = p.commandsToShapes()

  const q = 1/256.0

  # Creates segment q, quantize and remove verticals.
  var segments1: seq[Segment]
  for shape in polygons:
    for s in shape.segments:
      var s = s
      s.at = s.at.roundBy(q)
      s.to = s.to.roundBy(q)
      if s.at.y != s.to.y:
        segments1.add(s)
  #print segments1

  # Handle segments overlapping each other:
  # var segments1: seq[Segment]
  # while segments0.len > 0:
  #   var a = segments0.pop()
  #   var collision = false
  #   for b in segments0:
  #     if a != b:
  #       var at: Vec2
  #       if a.intersectsInner(b, at):
  #         print "seg2seg intersects!", a, b, at
  #         quit()
  #   if not collision:
  #     segments1.add(a)

  # There is probably a clever way to insert-sort them.
  var yScanLines: seq[float32]
  for s in segments1:
    if s.at.y notin yScanLines:
      yScanLines.add s.at.y
    if s.to.y notin yScanLines:
      yScanLines.add s.to.y
  yScanLines.sort()

  var segments: seq[Segment]
  while segments1.len > 0:
    #print segments1.len, segments.len
    var s = segments1.pop()
    var collision = false
    for y in yScanLines:
      var at: Vec2
      if intersects(line(vec2(0, y), vec2(1, y)), s, at):
        at = at.roundBy(q)
        at.y = y
        if s.at.y != at.y and s.to.y != at.y:
          #print "seg2yline intersects!", a, y, at
          collision = true
          var s1 = segment(s.at, at)
          var s2 = segment(at, s.to)
          #print s.length, "->", s1.length, s2.length
          segments1.add(s1)
          segments1.add(s2)
          break

    if not collision:
      segments.add(s)

  #print segments

  # sort at/to in segments
  for s in segments.mitems:
    if s.at.y > s.to.y:
      swap(s.at, s.to)

  #print segments
  #print yScanLines

  for yScanLine in yScanLines[0..^2]:

    var scanSegments: seq[Segment]
    for s in segments:
      if s.at.y == yScanLine:
        scanSegments.add(s)
    scanSegments.sort(proc(a, b: Segment): int =
      cmp(a.at.x, b.at.x))

    if scanSegments.len mod 2 != 0:
      print "error???"
      print yScanLine
      print scanSegments
      quit()

    # if scanSegments.len == 0:
    #   print "error???"
    #   print yScanLine
    #   print scanSegments
    #   quit()

    # TODO: winding rules will go here

    for i in 0 ..< scanSegments.len div 2:
      let
        a = scanSegments[i*2+0]
        b = scanSegments[i*2+1]

      assert a.at.y == b.at.y
      assert a.to.y == b.to.y
      #assert a.at.x < b.at.x
      #assert a.to.x < b.to.x

      result.add(
        Trapezoid(
          nw: a.at,
          ne: b.at,
          se: b.to, # + vec2(0,0.7),
        sw: a.to # + vec2(0,0.7)
      )
      )

proc trapFill(image: Image, t: Trapezoid, color: ColorRGBA) =
  # assert t.nw.y == t.ne.y
  # assert t.sw.y == t.se.y

  let
    height = t.sw.y - t.nw.y
    minY = clamp(t.nw.y, 0, image.height.float)
    maxY = clamp(t.sw.y, 0, image.height.float)
  for y in minY.int ..< maxY.int:
    var yRate, minX, maxX: float32

    yRate = clamp((y.float - t.nw.y) / height, 0, 1)
    minX = clamp(lerp(t.nw.x, t.sw.x, yRate).round, 0, image.width.float)
    maxX = clamp(lerp(t.ne.x, t.se.x, yRate).round, 0, image.width.float)

    for x in minX.int ..< maxX.int:
      image.setRgbaUnsafe(x, y, color)

proc drawTrapezoids(image: Image, trapezoids: seq[Trapezoid]) =

  for trapezoid in trapezoids:
    image.trapFill(trapezoid, rgba(0, 0, 0, 255))

  # for trapezoid in trapezoids:
  #   var p = newPath()
  #   p.moveTo(trapezoid.nw)
  #   p.lineTo(trapezoid.ne)
  #   p.lineTo(trapezoid.se)
  #   p.lineTo(trapezoid.sw)
  #   p.closePath()
  #   image.fillPath(p, rgba(0, 0, 0, 255))
  #   image.strokePath(p, rgba(255, 0, 0, 255))

block:
  # Rect
  print "rect"
  var image = newImage(200, 200)
  image.fill(rgba(255, 255, 255, 255))

  var p: Path
  p.moveTo(50, 50)
  p.lineTo(50, 150)
  p.lineTo(150, 150)
  p.lineTo(150, 50)
  p.closePath()

  var trapezoids = p.pathToTrapezoids()
  image.drawTrapezoids(trapezoids)

  image.writeFile("experiments/trapezoids/rect.png")

block:
  # Rhombus
  print "rhombus"
  var image = newImage(200, 200)
  image.fill(rgba(255, 255, 255, 255))

  var p: Path
  p.moveTo(100, 50)
  p.lineTo(150, 100)
  p.lineTo(100, 150)
  p.lineTo(50, 100)
  p.closePath()

  var trapezoids = p.pathToTrapezoids()
  image.drawTrapezoids(trapezoids)

  image.writeFile("experiments/trapezoids/rhombus.png")

block:
  # heart
  print "heart"
  var image = newImage(400, 400)
  image.fill(rgba(255, 255, 255, 255))

  var p = parsePath("""
    M 40 120 A 80 80 90 0 1 200 120 A 80 80 90 0 1 360 120
    Q 360 240 200 360 Q 40 240 40 120 z
  """)

  var trapezoids = p.pathToTrapezoids()
  image.drawTrapezoids(trapezoids)

  image.writeFile("experiments/trapezoids/heart.png")

block:
  # l
  print "l"
  var image = newImage(500, 800)
  image.fill(rgba(255, 255, 255, 255))

  var p = parsePath("""
    M 236 20 Q 150 22 114 57 T 78 166 V 790 L 171 806 V 181 Q 171 158 175 143 T 188 119 T 212 105.5 T 249 98 Z
  """)

  #image.strokePath(p, rgba(0, 0, 0, 255))

  var trapezoids = p.pathToTrapezoids()
  image.drawTrapezoids(trapezoids)

  image.writeFile("experiments/trapezoids/l.png")

block:
  # g
  print "g"
  var image = newImage(500, 800)
  image.fill(rgba(255, 255, 255, 255))

  var p = parsePath("""
    M 406 538 Q 394 546 359.5 558.5 T 279 571 Q 232 571 190.5 556 T 118 509.5 T 69 431 T 51 319 Q 51 262 68 214.5 T 117.5 132.5 T 197 78.5 T 303 59 Q 368 59 416.5 68.5 T 498 86 V 550 Q 498 670 436 724 T 248 778 Q 199 778 155.5 770 T 80 751 L 97 670 Q 125 681 165.5 689.5 T 250 698 Q 333 698 369.5 665 T 406 560 V 538 Z M 405 152 Q 391 148 367.5 144.5 T 304 141 Q 229 141 188.5 190 T 148 320 Q 148 365 159.5 397 T 190.5 450 T 235.5 481 T 288 491 Q 325 491 356 480.5 T 405 456 V 152 Z
  """)

  #image.strokePath(p, rgba(0, 0, 0, 255))

  var trapezoids = p.pathToTrapezoids()
  image.drawTrapezoids(trapezoids)

  image.writeFile("experiments/trapezoids/g.png")



================================================
FILE: experiments/trapezoid2.nim
================================================

import algorithm, bumpy, chroma, pixie/images, print,
    sequtils, vmath, benchy

import pixie, pixie/paths {.all.}


printColors = false

proc pixelCover(a0, b0: Vec2): float32 =
  ## Returns the amount of area a given segment sweeps to the right
  ## in a [0,0 to 1,1] box.
  var
    a = a0
    b = b0
    aI: Vec2
    bI: Vec2
    area: float32 = 0.0

  # # Sort A on top.
  # if a.y > b.y:
  #   let tmp = a
  #   a = b
  #   b = tmp

  # if (b.y < 0 or a.y > 1) or # Above or bellow, no effect.
  #   (a.x >= 1 and b.x >= 1) or # To the right, no effect.
  #   (a.y == b.y): # Horizontal line, no effect.
  #   return 0

  if (a.x < 0 and b.x < 0) or # Both to the left.
    (a.x == b.x): # Vertical line
    # Area of the rectangle:
    return (1 - clamp(a.x, 0, 1)) * (min(b.y, 1) - max(a.y, 0))

  else:
    # y = mm*x + bb
    let
      mm: float32 = (b.y - a.y) / (b.x - a.x)
      bb: float32 = a.y - mm * a.x

    if a.x >= 0 and a.x <= 1 and a.y >= 0 and a.y <= 1:
      # A is in pixel bounds.
      aI = a
    else:
      aI = vec2((0 - bb) / mm, 0)
      if aI.x < 0:
        let y = mm * 0 + bb
        # Area of the extra rectangle.
        area += (min(bb, 1) - max(a.y, 0)).clamp(0, 1)
        aI = vec2(0, y.clamp(0, 1))
      elif aI.x > 1:
        let y = mm * 1 + bb
        aI = vec2(1, y.clamp(0, 1))

    if b.x >= 0 and b.x <= 1 and b.y >= 0 and b.y <= 1:
      # B is in pixel bounds.
      bI = b
    else:
      bI = vec2((1 - bb) / mm, 1)
      if bI.x < 0:
        let y = mm * 0 + bb
        # Area of the extra rectangle.
        area += (min(b.y, 1) - max(bb, 0)).clamp(0, 1)
        bI = vec2(0, y.clamp(0, 1))
      elif bI.x > 1:
        let y = mm * 1 + bb
        bI = vec2(1, y.clamp(0, 1))

  area += ((1 - aI.x) + (1 - bI.x)) / 2 * (bI.y - aI.y)
  return area

proc intersectsInner*(a, b: Segment, at: var Vec2): bool {.inline.} =
  ## Checks if the a segment intersects b segment.
  ## If it returns true, at will have point of intersection
  let
    s1 = a.to - a.at
    s2 = b.to - b.at
    denominator = (-s2.x * s1.y + s1.x * s2.y)
    s = (-s1.y * (a.at.x - b.at.x) + s1.x * (a.at.y - b.at.y)) / denominator
    t = (s2.x * (a.at.y - b.at.y) - s2.y * (a.at.x - b.at.x)) / denominator

  if s > 0 and s < 1 and t >= 0 and t <= 1:
    at = a.at + (t * s1)
    return true

type

  Trapezoid = object
    nw, ne, se, sw: Vec2

proc roundBy*(v: Vec2, n: float32): Vec2 {.inline.} =
  result.x = sign(v.x) * round(abs(v.x) / n) * n
  result.y = sign(v.y) * round(abs(v.y) / n) * n

proc fillPath2(mask: Mask, p: Path) =

  var polygons = p.commandsToShapes()

  const q = 1/256.0

  # Creates segment q, quantize and remove horizontal lines.
  var segments1: seq[Segment]
  for shape in polygons:
    for s in shape.segments:
      var s = s
      s.at = s.at.roundBy(q)
      s.to = s.to.roundBy(q)
      if s.at.y != s.to.y:
        if s.at.y > s.to.y:
          # make sure segments always are at.y higher
          swap(s.at, s.to)
        segments1.add(s)
  segments1.sort(proc(a, b: Segment): int = cmp(a.at.y, b.at.y))

  # Dumb way to compute cutLines
  # var cutLines: seq[float32]
  # for s in segments1:
  #   if s.at.y notin cutLines:
  #     cutLines.add s.at.y
  #   if s.to.y notin cutLines:
  #     cutLines.add s.to.y
  # cutLines.sort()

  # Compute cutLines
  var
    cutLines: seq[float32]
    last = segments1[0].at.y
    bottom = segments1[0].to.y
  cutLines.add(last)
  for s in segments1:
    if s.at.y != last:
      last = s.at.y
      cutLines.add(last)
    if bottom < s.to.y:
      bottom = s.to.y
  cutLines.add(bottom)
  #print cutLines

  var
    sweeps = newSeq[seq[Segment]](cutLines.len - 1) # dont add bottom cutLine
    lastSeg = 0

  for i, sweep in sweeps.mpairs:
    #print "sweep", i, cutLines[i]
    while segments1[lastSeg].at.y == cutLines[i]:
      let s = segments1[lastSeg]
      #print s
      if s.to.y != cutLines[i + 1]:
        #print "needs cut?"
        quit()
      sweep.add(segments1[lastSeg])
      inc lastSeg
      if lastSeg >= segments1.len:
        # Sort the last sweep by X
        break
    # Sort the sweep by X
    sweep.sort(proc(a, b: Segment): int = cmp(a.at.x, b.at.x))

  proc fillCoverage(y: int, currCutLine: int, sweep: seq[Segment]) =


    # var i = 0
    # let
    #   sweepHeight = cutLines[currCutLine + 1] - cutLines[currCutLine]
    #   yFracTop = (y.float - cutLines[currCutLine]) / sweepHeight
    #   yFracBottom = (y.float + 1 - cutLines[currCutLine]) / sweepHeight
    # #print "cover", y, sweepHeight, yFrac
    # while i < sweep.len:
    #   #print "fill", sweep[i].at.x, "..", sweep[i+1].at.x
    #   let
    #     minXf1 = mix(sweep[i+0].at.x, sweep[i+0].to.x, yFracTop)
    #     maxXf1 = mix(sweep[i+1].at.x, sweep[i+1].to.x, yFracTop)

    #     minXf2 = mix(sweep[i+0].at.x, sweep[i+0].to.x, yFracBottom)
    #     maxXf2 = mix(sweep[i+1].at.x, sweep[i+1].to.x, yFracBottom)

    #     minXi1 = minXf1.floor.int
    #     maxXi1 = maxXf1.floor.int

    #     minXi2 = minXf2.floor.int
    #     maxXi2 = maxXf2.floor.int

    #   for x in min(minXi1, minXi2) .. max(maxXi1, maxXi2):
    #     var a = 1.0f
    #     # if x < max(minXi1, minXi2):
    #     #   a = 0.1
    #     # elif x > min(maxXi1, maxXi2):
    #     #   a = 0.1
    #     # else:
    #     #   a = 0.5
    #     let backdrop = mask.getValueUnsafe(x, y)
    #     mask.setValueUnsafe(x, y, backdrop + (a * 255).uint8)
    #   i += 2

    # x10 slower
    # for x in 0 ..< mask.width:
    #   for i, seg in sweep:
    #     var area = pixelCover(seg.at - vec2(x.float32, y.float32), seg.to - vec2(x.float32, y.float32))
    #     if i mod 2 == 1:
    #       area = -area
    #     let backdrop = mask.getValueUnsafe(x, y)
    #     mask.setValueUnsafe(x, y, backdrop + (area * 255).uint8)

    let quality = 5
    for m in 0 ..< quality:
      let
        sweepHeight = cutLines[currCutLine + 1] - cutLines[currCutLine]
        yFrac = (y.float32 + (m.float32 / quality.float32) - cutLines[currCutLine]) / sweepHeight
      if yFrac < 0.0 or yFrac >= 1.0:
        continue
      var i = 0
      while i < sweep.len:
        let
          minXf1 = mix(sweep[i+0].at.x, sweep[i+0].to.x, yFrac)
          maxXf1 = mix(sweep[i+1].at.x, sweep[i+1].to.x, yFrac)
          minXi1 = minXf1.int
          maxXi1 = maxXf1.int
        for x in minXi1 ..< maxXi1:
          let backdrop = mask.getValueUnsafe(x, y)
          mask.setValueUnsafe(x, y, backdrop + (255 div quality).uint8)
          # if x == 100 and y == 165:
          #   print backdrop, 255 div quality
          #   print mask.getValueUnsafe(x, y)
        i += 2

    # let
    #   sweepHeight = cutLines[currCutLine + 1] - cutLines[currCutLine]
    #   yFrac = (y.float32 - cutLines[currCutLine]) / sweepHeight
    # var i = 0
    # while i < sweep.len:
    #   let
    #     minXf1 = mix(sweep[i+0].at.x, sweep[i+0].to.x, yFrac)
    #     maxXf1 = mix(sweep[i+1].at.x, sweep[i+1].to.x, yFrac)
    #     minXi1 = minXf1.floor.int
    #     maxXi1 = maxXf1.floor.int
    #   for x in minXi1 .. maxXi1:
    #     mask.setValueUnsafe(x, y, 255)
    #   i += 2

  var
    currCutLine = 0
  for scanLine in cutLines[0].int ..< cutLines[^1].ceil.int:
    print scanLine, "..<", scanLine + 1
    print "  ", currCutLine, cutLines[currCutLine], "..<", cutLines[currCutLine + 1]
    fillCoverage(scanLine, currCutLine, sweeps[currCutLine])
    while cutLines[currCutLine + 1] < scanLine.float + 1.0:
      inc currCutLine
      print "  ", currCutLine, cutLines[currCutLine], "..<", cutLines[currCutLine + 1]
      fillCoverage(scanLine, currCutLine, sweeps[currCutLine])

  # print sweeps[^1]
  # print cutLines




  # var segments: seq[Segment]
  # while segments1.len > 0:
  #   #print segments1.len, segments.len
  #   var s = segments1.pop()
  #   var collision = false
  #   for y in cutLines:
  #     let scanLine = line(vec2(0, y), vec2(1, y))
  #     var at: Vec2
  #     if intersects(scanLine, s, at):
  #       at = at.roundBy(q)
  #       at.y = y
  #       if s.at.y != at.y and s.to.y != at.y:
  #         #print "seg2yline intersects!", a, y, at
  #         collision = true
  #         var s1 = segment(s.at, at)
  #         var s2 = segment(at, s.to)
  #         #print s.length, "->", s1.length, s2.length
  #         segments1.add(s1)
  #         segments1.add(s2)
  #         break

  #   if not collision:
  #     # means its touching, not intersecting
  #     segments.add(s)

  # # sort at/to in segments
  # # for s in segments.mitems:
  # #   if s.at.y > s.to.y:
  # #     swap(s.at, s.to)


  # #let blender = blendMode.blender()

  # for yScanLine in cutLines[0..^2]:

  #   var scanSegments: seq[Segment]
  #   for s in segments:
  #     if s.at.y == yScanLine:
  #       scanSegments.add(s)
  #   scanSegments.sort(proc(a, b: Segment): int =
  #     cmp(a.at.x, b.at.x))

  #   # if scanSegments.len mod 2 != 0:
  #   #   print "error???"
  #   #   print yScanLine
  #   #   print scanSegments
  #   #   quit()

  #   # TODO: winding rules will go here

  #   var trapezoids: seq[Trapezoid]
  #   for i in 0 ..< scanSegments.len div 2:
  #     let
  #       a = scanSegments[i*2+0]
  #       b = scanSegments[i*2+1]

  #     assert a.at.y == b.at.y
  #     assert a.to.y == b.to.y
  #     #assert a.at.x < b.at.x
  #     #assert a.to.x < b.to.x

  #     trapezoids.add(Trapezoid(
  #       nw: a.at,
  #       ne: b.at,
  #       se: b.to, # + vec2(0,0.7),
  #       sw: a.to # + vec2(0,0.7)
  #     ))

  #   var i = 0
  #   while i < trapezoids.len:

  #     let t = trapezoids[i]
  #     # print t
  #     let
  #       nw = t.nw
  #       ne = t.ne
  #       se = t.se
  #       sw = t.sw

  #     let
  #       height = sw.y - nw.y
  #       minYf = nw.y
  #       maxYf = sw.y
  #       minYi = minYf.floor.int
  #       maxYi = maxYf.floor.int

  #     # print t

  #     for y in minYi .. maxYi:
  #       let
  #         yFrac = (y.float - nw.y) / height
  #         minXf = mix(nw.x, sw.x, yFrac)
  #         maxXf = mix(ne.x, se.x, yFrac)
  #         minXi = minXf.floor.int
  #         maxXi = maxXf.floor.int
  #       #print yFrac
  #       # if not(minY.int == 58 or maxY.int == 58) or minX > 100:
  #       #   continue

  #       var ay: float32
  #       if y == minYi and y == maxYi:
  #         ay = maxYf - minYf
  #         # print "middle", maxYf, minYf, a
  #         #print "double", y, a, minY, maxY, round(a * 255)
  #       elif y == minYi:
  #         ay = (1 - (minYf - float32(minYi)))
  #         # print "min y", minYf, minYi, a
  #         #print "s", y, a, minY, round(a * 255)
  #       elif y == maxYi:
  #         ay = (maxYf - float32(maxYi))
  #         #print "max y", maxYf, maxYi, a
  #         # print "e", y, a, maxY, round(a * 255)
  #       else:
  #         ay = 1.0

  #       for x in minXi .. maxXi:
  #         var ax: float32
  #         # if x == minXi:
  #         #   a2 = (1 - (minXf - float32(minXi)))
  #         #   #a2 = 1.0
  #         # elif x == maxXi:
  #         #   a2 = (maxXf - float32(maxXi))
  #         #   #a2 = 1.0
  #         # else:
  #         #   a2 = 1.0

  #         if x.float32 < max(nw.x, sw.x):
  #           ax = 0.5
  #         elif x.float32 > min(ne.x, se.x):
  #           ax = 0.25
  #         else:
  #           ax = 1.0

  #         let backdrop = mask.getValueUnsafe(x, y)
  #         mask.setValueUnsafe(x, y, backdrop + floor(255 * ay * ax).uint8)
  #         # if x == 100 and y == 172:
  #         #   print backdrop, round(255 * a * a2).uint8
  #         #   print mask.getValueUnsafe(x, y)

  #     inc i

block:
  # Rect
  print "rect"
  #var image = newImage(200, 200)

  # var p = Path()
  # p.moveTo(50.25, 50.25)
  # p.lineTo(50.25, 150.25)
  # p.lineTo(150.25, 150.25)
  # p.lineTo(150.25, 50.25)
  # p.closePath()

  var p = parsePath("""
    M 20 60
    A 40 40 90 0 1 100 60
    A 40 40 90 0 1 180 60
    Q 180 120 100 180
    Q 20 120 20 60
    z
  """)

  # image.fill(rgba(255, 255, 255, 255))
  #image.fillPath2(p, color(0, 0, 0, 1))

  var mask = newMask(200, 200)
  timeIt "rect trapezoids", 1:
    #for i in 0 ..< 100:
      mask.fill(0)
      mask.fillPath2(p)
      #image.fillPath2(p, color(0, 0, 0, 1))
  mask.writeFile("experiments/trapezoids/rect_trapesoid.png")

  var mask2 = newMask(200, 200)
  timeIt "rect normal", 1:
    #for i in 0 ..< 100:
      mask2.fill(0)
      mask2.fillPath(p)
  mask2.writeFile("experiments/trapezoids/rect_scanline.png")

  let (score, image) = diff(mask.newImage, mask2.newImage)
  print score
  image.writeFile("experiments/trapezoids/rect_diff.png")



# block:
#   # Rhombus
#   print "rhombus"
#   var image = newImage(200, 200)
#   image.fill(rgba(255, 255, 255, 255))

#   var p = Path()
#   p.moveTo(100, 50)
#   p.lineTo(150, 100)
#   p.lineTo(100, 150)
#   p.lineTo(50, 100)
#   p.closePath()

#   image.fillPath2(p, color(0, 0, 0, 1))

#   image.writeFile("experiments/trapezoids/rhombus.png")

# block:
#   # heart
#   print "heart"
#   var image = newImage(400, 400)
#   image.fill(rgba(0, 0, 0, 0))

#   var p = parsePath("""
#     M 40 120 A 80 80 90 0 1 200 120 A 80 80 90 0 1 360 120
#     Q 360 240 200 360 Q 40 240 40 120 z
#   """)

#   var mask = newMask(image)
#   mask.fillPath2(p)

#   image.draw(mask, blendMode = OverwriteBlend)

#   image.writeFile("experiments/trapezoids/heart.png")

# block:
#   # l
#   print "l"
#   var image = newImage(500, 800)
#   image.fill(rgba(255, 255, 255, 255))

#   var p = parsePath("""
#     M 236 20 Q 150 22 114 57 T 78 166 V 790 L 171 806 V 181 Q 171 158 175 143 T 188 119 T 212 105.5 T 249 98 Z
#   """)

#   image.fillPath2(p, color(0, 0, 0, 1))

#   image.writeFile("experiments/trapezoids/l.png")

# block:
#   # g
#   print "g"
#   var image = newImage(500, 800)
#   image.fill(rgba(255, 255, 255, 255))

#   var p = parsePath("""
#     M 406 538 Q 394 546 359.5 558.5 T 279 571 Q 232 571 190.5 556 T 118 509.5 T 69 431 T 51 319 Q 51 262 68 214.5 T 117.5 132.5 T 197 78.5 T 303 59 Q 368 59 416.5 68.5 T 498 86 V 550 Q 498 670 436 724 T 248 778 Q 199 778 155.5 770 T 80 751 L 97 670 Q 125 681 165.5 689.5 T 250 698 Q 333 698 369.5 665 T 406 560 V 538 Z M 405 152 Q 391 148 367.5 144.5 T 304 141 Q 229 141 188.5 190 T 148 320 Q 148 365 159.5 397 T 190.5 450 T 235.5 481 T 288 491 Q 325 491 356 480.5 T 405 456 V 152 Z
#   """)

#   image.fillPath2(p, color(0, 0, 0, 1))

#   image.writeFile("experiments/trapezoids/g.png")



================================================
FILE: src/pixie.nim
================================================
import bumpy, chroma, flatty/binny, os, pixie/common, pixie/contexts,
    pixie/fileformats/bmp, pixie/fileformats/gif, pixie/fileformats/jpeg,
    pixie/fileformats/png, pixie/fileformats/ppm, pixie/fileformats/qoi,
    pixie/fileformats/svg, pixie/fonts, pixie/images, pixie/internal,
    pixie/paints, pixie/paths, strutils, vmath

export bumpy, chroma, common, contexts, fonts, images, paints, paths, vmath

type
  FileFormat* = enum
    PngFormat, BmpFormat, JpegFormat, GifFormat, QoiFormat, PpmFormat

converter autoStraightAlpha*(c: ColorRGBX): ColorRGBA {.inline, raises: [].} =
  ## Convert a premultiplied alpha RGBA to a straight alpha RGBA.
  c.rgba()

converter autoPremultipliedAlpha*(c: ColorRGBA): ColorRGBX {.inline, raises: [].} =
  ## Convert a straight alpha RGBA to a premultiplied alpha RGBA.
  c.rgbx()

proc decodeImageDimensions*(
  data: pointer, len: int
): ImageDimensions {.raises: [PixieError].} =
  ## Decodes an image's dimensions from memory.
  if len > 8 and equalMem(data, pngSignature[0].unsafeAddr, 8):
    decodePngDimensions(data, len)
  elif len > 2 and equalMem(data, jpegStartOfImage[0].unsafeAddr, 2):
    decodeJpegDimensions(data, len)
  elif len > 2 and equalMem(data, bmpSignature.cstring, 2):
    decodeBmpDimensions(data, len)
  elif len > 6 and (
    equalMem(data, gifSignatures[0].cstring, 6) or
    equalMem(data, gifSignatures[1].cstring, 6)
  ):
    decodeGifDimensions(data, len)
  elif len > (14 + 8) and equalMem(data, qoiSignature.cstring, 4):
    decodeQoiDimensions(data, len)
  elif len > 9 and (
    equalMem(data, ppmSignatures[0].cstring, 2) or
    equalMem(data, ppmSignatures[1].cstring, 2)
  ):
    decodePpmDimensions(data, len)
  else:
    raise newException(PixieError, "Unsupported image file format")

proc decodeImageDimensions*(
  data: string
): ImageDimensions {.raises: [PixieError].} =
  ## Decodes an image's dimensions from memory.
  decodeImageDimensions(data.cstring, data.len)

proc decodeImage*(data: string): Image {.raises: [PixieError].} =
  ## Loads an image from memory.
  if data.len > 8 and data.readUint64(0) == cast[uint64](pngSignature):
    decodePng(data).convertToImage()
  elif data.len > 2 and data.readUint16(0) == cast[uint16](jpegStartOfImage):
    decodeJpeg(data)
  elif data.len > 2 and data.readStr(0, 2) == bmpSignature:
    decodeBmp(data)
  elif data.len > 5 and
    (data.readStr(0, 5) == xmlSignature or data.readStr(0, 4) == svgSignature):
    newImage(parseSvg(data))
  elif data.len > 6 and data.readStr(0, 6) in gifSignatures:
    newImage(decodeGif(data))
  elif data.len > (14+8) and data.readStr(0, 4) == qoiSignature:
    decodeQoi(data).convertToImage()
  elif data.len > 9 and data.readStr(0, 2) in ppmSignatures:
    decodePpm(data)
  else:
    raise newException(PixieError, "Unsupported image file format")

proc readImageDimensions*(
  filePath: string
): ImageDimensions {.inline, raises: [PixieError].} =
  ## Decodes an image's dimensions from a file.
  try:
    decodeImageDimensions(readFile(filePath))
  except IOError as e:
    raise newException(PixieError, e.msg, e)

proc readImage*(filePath: string): Image {.inline, raises: [PixieError].} =
  ## Loads an image from a file.
  try:
    decodeImage(readFile(filePath))
  except IOError as e:
    raise newException(PixieError, e.msg, e)

proc encodeImage*(image: Image, fileFormat: FileFormat): string {.raises: [PixieError].} =
  ## Encodes an image into memory.
  case fileFormat:
  of PngFormat:
    image.encodePng()
  of JpegFormat:
    raise newException(PixieError, "Unsupported file format")
  of BmpFormat:
    image.encodeBmp()
  of QoiFormat:
    image.encodeQoi()
  of GifFormat:
    raise newException(PixieError, "Unsupported file format")
  of PpmFormat:
    image.encodePpm()

proc writeFile*(image: Image, filePath: string) {.raises: [PixieError].} =
  ## Writes an image to a file.
  let fileFormat = case splitFile(filePath).ext.toLowerAscii():
    of ".png": PngFormat
    of ".bmp": BmpFormat
    of ".jpg", ".jpeg": JpegFormat
    of ".qoi": QoiFormat
    of ".ppm": PpmFormat
    else:
      raise newException(PixieError, "Unsupported file extension")

  try:
    writeFile(filePath, image.encodeImage(fileFormat))
  except IOError as e:
    raise newException(PixieError, e.msg, e)

proc fill*(image: Image, paint: Paint) {.raises: [PixieError].} =
  ## Fills the image with the paint.
  case paint.kind:
  of SolidPaint:
    fillUnsafe(image.data, paint.color, 0, image.data.len)
  of ImagePaint, TiledImagePaint:
    fillUnsafe(image.data, rgbx(0, 0, 0, 0), 0, image.data.len)
    let path = newPath()
    path.rect(0, 0, image.width.float32, image.height.float32)
    image.fillPath(path, paint)
  of LinearGradientPaint, RadialGradientPaint, AngularGradientPaint:
    image.fillGradient(paint)



================================================
FILE: src/pixie/blends.nim
================================================
## Blending modes.

import chroma, common

# See https://www.w3.org/TR/compositing-1/
# See https://www.khronos.org/registry/OpenGL/extensions/KHR/KHR_blend_equation_advanced.txt

type
  Blender* = proc(backdrop, source: ColorRGBX): ColorRGBX {.gcsafe, raises: [].}
    ## Function signature returned by blender.

when defined(release):
  {.push checks: off.}

proc min(a, b: uint32): uint32 {.inline.} =
  if a < b: a else: b

proc alphaFix(backdrop, source, mixed: ColorRGBA): ColorRGBA =
  ## After mixing an image, adjust its alpha value to be correct.
  let
    sa = source.a.uint32
    ba = backdrop.a.uint32
    t0 = sa * (255 - ba)
    t1 = sa * ba
    t2 = (255 - sa) * ba

  let
    r = t0 * source.r.uint32 + t1 * mixed.r.uint32 + t2 * backdrop.r.uint32
    g = t0 * source.g.uint32 + t1 * mixed.g.uint32 + t2 * backdrop.g.uint32
    b = t0 * source.b.uint32 + t1 * mixed.b.uint32 + t2 * backdrop.b.uint32
    a = sa + ba * (255 - sa) div 255

  if a == 0:
    return

  result.r = (r div a div 255).uint8
  result.g = (g div a div 255).uint8
  result.b = (b div a div 255).uint8
  result.a = a.uint8

proc blendAlpha*(backdrop, source: uint8): uint8 {.inline.} =
  ## Blends alphas of backdrop, source.
  source + ((backdrop.uint32 * (255 - source)) div 255).uint8

proc screen(backdrop, source: uint32): uint8 {.inline.} =
  ((backdrop + source).int32 - ((backdrop * source) div 255).int32).uint8

proc hardLight(
  backdropColor, backdropAlpha, sourceColor, sourceAlpha: uint32
): uint8 {.inline.} =
  if sourceColor * 2 <= sourceAlpha:
    ((
      2 * sourceColor * backdropColor +
      (sourceColor * (255 - backdropAlpha)) +
      (backdropColor * (255 - sourceAlpha))
    ) div 255).uint8
  else:
    screen(backdropColor, sourceColor)

proc blendNormal*(backdrop, source: ColorRGBX): ColorRGBX {.inline.} =
  if backdrop.a == 0 or source.a == 255:
    return source
  if source.a == 0:
    return backdrop

  let k = (255 - source.a.uint32)
  result.r = source.r + ((backdrop.r.uint32 * k) div 255).uint8
  result.g = source.g + ((backdrop.g.uint32 * k) div 255).uint8
  result.b = source.b + ((backdrop.b.uint32 * k) div 255).uint8
  result.a = blendAlpha(backdrop.a, source.a)

proc blendDarken*(backdrop, source: ColorRGBX): ColorRGBX {.inline.} =
  proc blend(
    backdropColor, backdropAlpha, sourceColor, sourceAlpha: uint8
  ): uint8 {.inline.} =
    min(
      backdropColor + ((255 - backdropAlpha).uint32 * sourceColor) div 255,
      sourceColor + ((255 - sourceAlpha).uint32 * backdropColor) div 255
    ).uint8

  result.r = blend(backdrop.r, backdrop.a, source.r, source.a)
  result.g = blend(backdrop.g, backdrop.a, source.g, source.a)
  result.b = blend(backdrop.b, backdrop.a, source.b, source.a)
  result.a = blendAlpha(backdrop.a, source.a)

proc blendMultiply*(backdrop, source: ColorRGBX): ColorRGBX {.inline.} =
  proc blend(
    backdropColor, backdropAlpha, sourceColor, sourceAlpha: uint8
  ): uint8 {.inline.} =
    ((
      (255 - backdropAlpha).uint32 * sourceColor +
      (255 - sourceAlpha).uint32 * backdropColor +
      backdropColor.uint32 * sourceColor
    ) div 255).uint8

  result.r = blend(backdrop.r, backdrop.a, source.r, source.a)
  result.g = blend(backdrop.g, backdrop.a, source.g, source.a)
  result.b = blend(backdrop.b, backdrop.a, source.b, source.a)
  result.a = blendAlpha(backdrop.a, source.a)

# proc blendLinearBurn(backdrop, source: ColorRGBX): ColorRGBX =
#   let
#     backdrop = backdrop.toStraightAlpha()
#     source = source.toStraightAlpha()
#   result.r = min(0, backdrop.r.int32 + source.r.int32 - 255).uint8
#   result.g = min(0, backdrop.g.int32 + source.g.int32 - 255).uint8
#   result.b = min(0, backdrop.b.int32 + source.b.int32 - 255).uint8
#   result = alphaFix(backdrop, source, result)
#   result = result.toPremultipliedAlpha()

proc blendColorBurn*(backdrop, source: ColorRGBX): ColorRGBX =
  let
    backdrop = backdrop.rgba()
    source = source.rgba()
  proc blend(backdrop, source: uint32): uint8 {.inline.} =
    if backdrop == 255:
      255.uint8
    elif source == 0:
      0
    else:
      255 - min(255, (255 * (255 - backdrop)) div source).uint8
  var blended: ColorRGBA
  blended.r = blend(backdrop.r, source.r)
  blended.g = blend(backdrop.g, source.g)
  blended.b = blend(backdrop.b, source.b)
  result = alphaFix(backdrop, source, blended).rgbx()

proc blendLighten*(backdrop, source: ColorRGBX): ColorRGBX {.inline.} =
  proc blend(
    backdropColor, backdropAlpha, sourceColor, sourceAlpha: uint8
  ): uint8 {.inline.} =
    max(
      backdropColor + ((255 - backdropAlpha).uint32 * sourceColor) div 255,
      sourceColor + ((255 - sourceAlpha).uint32 * backdropColor) div 255
    ).uint8

  result.r = blend(backdrop.r, backdrop.a, source.r, source.a)
  result.g = blend(backdrop.g, backdrop.a, source.g, source.a)
  result.b = blend(backdrop.b, backdrop.a, source.b, source.a)
  result.a = blendAlpha(backdrop.a, source.a)

proc blendScreen*(backdrop, source: ColorRGBX): ColorRGBX {.inline.} =
  result.r = screen(backdrop.r, source.r)
  result.g = screen(backdrop.g, source.g)
  result.b = screen(backdrop.b, source.b)
  result.a = blendAlpha(backdrop.a, source.a)

# proc blendLinearDodge(backdrop, source: ColorRGBX): ColorRGBX =
#   let
#     backdrop = backdrop.toStraightAlpha()
#     source = source.toStraightAlpha()
#   result.r = min(backdrop.r.uint32 + source.r, 255).uint8
#   result.g = min(backdrop.g.uint32 + source.g, 255).uint8
#   result.b = min(backdrop.b.uint32 + source.b, 255).uint8
#   result = alphaFix(backdrop, source, result)
#   result = result.toPremultipliedAlpha()

proc blendColorDodge*(backdrop, source: ColorRGBX): ColorRGBX =
  let
    backdrop = backdrop.rgba()
    source = source.rgba()
  proc blend(backdrop, source: uint32): uint8 {.inline.} =
    if backdrop == 0:
      0.uint8
    elif source == 255:
      255
    else:
      min(255, (255 * backdrop) div (255 - source)).uint8
  var blended: ColorRGBA
  blended.r = blend(backdrop.r, source.r)
  blended.g = blend(backdrop.g, source.g)
  blended.b = blend(backdrop.b, source.b)
  result = alphaFix(backdrop, source, blended).rgbx()

proc blendOverlay*(backdrop, source: ColorRGBX): ColorRGBX =
  result.r = hardLight(source.r, source.a, backdrop.r, backdrop.a)
  result.g = hardLight(source.g, source.a, backdrop.g, backdrop.a)
  result.b = hardLight(source.b, source.a, backdrop.b, backdrop.a)
  result.a = blendAlpha(backdrop.a, source.a)

proc blendSoftLight*(backdrop, source: ColorRGBX): ColorRGBX =
  blendSoftLight(backdrop.color, source.color).rgbx

proc blendHardLight*(backdrop, source: ColorRGBX): ColorRGBX =
  result.r = hardLight(backdrop.r, backdrop.a, source.r, source.a)
  result.g = hardLight(backdrop.g, backdrop.a, source.g, source.a)
  result.b = hardLight(backdrop.b, backdrop.a, source.b, source.a)
  result.a = blendAlpha(backdrop.a, source.a)

proc blendDifference*(backdrop, source: ColorRGBX): ColorRGBX =
  proc blend(
    backdropColor, backdropAlpha, sourceColor, sourceAlpha: uint8
  ): uint8 {.inline.} =
    ((backdropColor + sourceColor).int32 - 2 *
      (min(
        backdropColor.uint32 * sourceAlpha,
        sourceColor.uint32 * backdropAlpha
      ) div 255).int32
    ).uint8

  result.r = blend(backdrop.r, backdrop.a, source.r, source.a)
  result.g = blend(backdrop.g, backdrop.a, source.g, source.a)
  result.b = blend(backdrop.b, backdrop.a, source.b, source.a)
  result.a = blendAlpha(backdrop.a, source.a)

proc blendExclusion*(backdrop, source: ColorRGBX): ColorRGBX =
  proc blend(backdrop, source: uint32): uint8 {.inline.} =
    let v = (backdrop + source).int32 - ((2 * backdrop * source) div 255).int32
    max(0, v).uint8
  result.r = blend(backdrop.r.uint32, source.r.uint32)
  result.g = blend(backdrop.g.uint32, source.g.uint32)
  result.b = blend(backdrop.b.uint32, source.b.uint32)
  result.a = blendAlpha(backdrop.a, source.a)

proc blendColor*(backdrop, source: ColorRGBX): ColorRGBX =
  blendColor(backdrop.color, source.color).rgbx

proc blendLuminosity*(backdrop, source: ColorRGBX): ColorRGBX =
  blendLuminosity(backdrop.color, source.color).rgbx

proc blendHue*(backdrop, source: ColorRGBX): ColorRGBX =
  blendHue(backdrop.color, source.color).rgbx

proc blendSaturation*(backdrop, source: ColorRGBX): ColorRGBX =
  blendSaturation(backdrop.color, source.color).rgbx

proc blendMask*(backdrop, source: ColorRGBX): ColorRGBX {.inline.} =
  let k = source.a.uint32
  result.r = ((backdrop.r * k) div 255).uint8
  result.g = ((backdrop.g * k) div 255).uint8
  result.b = ((backdrop.b * k) div 255).uint8
  result.a = ((backdrop.a * k) div 255).uint8

proc blendSubtractMask*(backdrop, source: ColorRGBX): ColorRGBX {.inline.} =
  let a = (backdrop.a.uint32 * (255 - source.a)) div 255
  result.r = ((backdrop.r * a) div 255).uint8
  result.g = ((backdrop.g * a) div 255).uint8
  result.b = ((backdrop.b * a) div 255).uint8
  result.a = a.uint8

proc blendExcludeMask*(backdrop, source: ColorRGBX): ColorRGBX {.inline.} =
  let a = max(backdrop.a, source.a).uint32 - min(backdrop.a, source.a)
  result.r = ((source.r * a) div 255).uint8
  result.g = ((source.g * a) div 255).uint8
  result.b = ((source.b * a) div 255).uint8
  result.a = a.uint8

proc normalBlender(backdrop, source: ColorRGBX): ColorRGBX =
  blendNormal(backdrop, source)

proc darkenBlender(backdrop, source: ColorRGBX): ColorRGBX =
  blendDarken(backdrop, source)

proc multiplyBlender(backdrop, source: ColorRGBX): ColorRGBX =
  blendMultiply(backdrop, source)

proc lightenBlender(backdrop, source: ColorRGBX): ColorRGBX =
  blendLighten(backdrop, source)

proc screenBlender(backdrop, source: ColorRGBX): ColorRGBX =
  blendScreen(backdrop, source)

proc maskBlender(backdrop, source: ColorRGBX): ColorRGBX =
  blendMask(backdrop, source)

proc overwriteBlender(backdrop, source: ColorRGBX): ColorRGBX =
  source

proc subtractMaskBlender(backdrop, source: ColorRGBX): ColorRGBX =
  blendSubtractMask(backdrop, source)

proc excludeMaskBlender(backdrop, source: ColorRGBX): ColorRGBX =
  blendExcludeMask(backdrop, source)

proc blender*(blendMode: BlendMode): Blender {.raises: [].} =
  ## Returns a blend function for a given blend mode.
  case blendMode:
  of NormalBlend: normalBlender
  of DarkenBlend: darkenBlender
  of MultiplyBlend: multiplyBlender
  # of BlendLinearBurn: blendLinearBurn
  of ColorBurnBlend: blendColorBurn
  of LightenBlend: lightenBlender
  of ScreenBlend: screenBlender
  # of BlendLinearDodge: blendLinearDodge
  of ColorDodgeBlend: blendColorDodge
  of OverlayBlend: blendOverlay
  of SoftLightBlend: blendSoftLight
  of HardLightBlend: blendHardLight
  of DifferenceBlend: blendDifference
  of ExclusionBlend: blendExclusion
  of HueBlend: blendHue
  of SaturationBlend: blendSaturation
  of ColorBlend: blendColor
  of LuminosityBlend: blendLuminosity
  of MaskBlend: maskBlender
  of OverwriteBlend: overwriteBlender
  of SubtractMaskBlend: subtractMaskBlender
  of ExcludeMaskBlend: excludeMaskBlender

when defined(release):
  {.pop.}



================================================
FILE: src/pixie/common.nim
================================================
import bumpy, chroma, vmath

type
  PixieError* = object of CatchableError ## Raised if an operation fails.

  BlendMode* = enum
    NormalBlend
    DarkenBlend
    MultiplyBlend
    # BlendLinearBurn
    ColorBurnBlend
    LightenBlend
    ScreenBlend
    # BlendLinearDodge
    ColorDodgeBlend
    OverlayBlend
    SoftLightBlend
    HardLightBlend
    DifferenceBlend
    ExclusionBlend
    HueBlend
    SaturationBlend
    ColorBlend
    LuminosityBlend

    MaskBlend         ## Special blend mode that is used for masking
    OverwriteBlend    ## Special blend mode that just copies pixels
    SubtractMaskBlend ## Inverse mask
    ExcludeMaskBlend

  ImageDimensions* = object
    width*, height*: int

  Image* = ref object
    ## Image object that holds bitmap data in premultiplied alpha RGBA format.
    width*, height*: int
    data*: seq[ColorRGBX]

proc newImage*(width, height: int): Image {.raises: [PixieError].} =
  ## Creates a new image with the parameter dimensions.
  if width <= 0 or height <= 0:
    raise newException(PixieError, "Image width and height must be > 0")

  result = Image()
  result.width = width
  result.height = height
  result.data = newSeq[ColorRGBX](width * height)

proc copy*(image: Image): Image {.raises: [].} =
  ## Copies the image data into a new image.
  result = Image()
  result.width = image.width
  result.height = image.height
  result.data = image.data

template dataIndex*(image: Image, x, y: int): int =
  image.width * y + x

proc mix*(a, b: ColorRGBX, t: float32): ColorRGBX {.inline, raises: [].} =
  ## Linearly interpolate between a and b using t.
  let x = round(t * 255).uint32
  result.r = ((a.r.uint32 * (255 - x) + b.r.uint32 * x + 127) div 255).uint8
  result.g = ((a.g.uint32 * (255 - x) + b.g.uint32 * x + 127) div 255).uint8
  result.b = ((a.b.uint32 * (255 - x) + b.b.uint32 * x + 127) div 255).uint8
  result.a = ((a.a.uint32 * (255 - x) + b.a.uint32 * x + 127) div 255).uint8

proc `*`*(color: ColorRGBX, opacity: float32): ColorRGBX {.raises: [].} =
  if opacity == 0:
    rgbx(0, 0, 0, 0)
  else:
    let
      x = round(opacity * 255).uint32
      r = ((color.r * x + 127) div 255).uint8
      g = ((color.g * x + 127) div 255).uint8
      b = ((color.b * x + 127) div 255).uint8
      a = ((color.a * x + 127) div 255).uint8
    rgbx(r, g, b, a)

proc `*`*(rgbx: ColorRGBX, opacity: uint8): ColorRGBX {.inline.} =
  if opacity == 0:
    discard
  elif opacity == 255:
    result = rgbx
  else:
    result = rgbx(
      ((rgbx.r.uint32 * opacity + 127) div 255).uint8,
      ((rgbx.g.uint32 * opacity + 127) div 255).uint8,
      ((rgbx.b.uint32 * opacity + 127) div 255).uint8,
      ((rgbx.a.uint32 * opacity + 127) div 255).uint8
    )

proc snapToPixels*(rect: Rect): Rect {.raises: [].} =
  let
    xMin = rect.x
    xMax = rect.x + rect.w
    yMin = rect.y
    yMax = rect.y + rect.h
  result.x = floor(xMin)
  result.w = ceil(xMax) - result.x
  result.y = floor(yMin)
  result.h = ceil(yMax) - result.y



================================================
FILE: src/pixie/contexts.nim
================================================
import bumpy, chroma, common, fonts, images, paints, paths, tables, vmath

## This file provides a Nim version of the Canvas 2D API commonly used on the
## web. The goal is to make picking up Pixie easy for developers familiar with
## using CanvasRenderingContext2D on the web. For more info, see:
## https://developer.mozilla.org/en-US/docs/Web/API/ContextRenderingContext2D

type
  BaselineAlignment* = enum
    TopBaseline
    HangingBaseline
    MiddleBaseline
    AlphabeticBaseline
    IdeographicBaseline
    BottomBaseline

  Context* = ref object
    image*: Image
    fillStyle*, strokeStyle*: Paint
    globalAlpha*: float32
    lineWidth*: float32
    miterLimit*: float32
    lineCap*: LineCap
    lineJoin*: LineJoin
    font*: string ## File path to a .ttf or .otf file.
    fontSize*: float32
    textAlign*: HorizontalAlignment
    textBaseline*: BaselineAlignment
    lineDash: seq[float32]
    path: Path
    mat: Mat3
    mask, layer: Image
    stateStack: seq[ContextState]
    typefaces: Table[string, Typeface]

  ContextState = object
    fillStyle, strokeStyle: Paint
    globalAlpha: float32
    lineWidth: float32
    miterLimit: float32
    lineCap: LineCap
    lineJoin: LineJoin
    font: string
    fontSize*: float32
    textAlign: HorizontalAlignment
    lineDash: seq[float32]
    mat: Mat3
    mask, layer: Image

  TextMetrics* = object
    width*: float32

proc newContext*(image: Image): Context {.raises: [].} =
  ## Create a new Context that will draw to the parameter image.
  result = Context()
  result.image = image
  result.mat = mat3()
  result.path = newPath()
  result.globalAlpha = 1
  result.lineWidth = 1
  result.miterLimit = 10
  result.fillStyle = newPaint(SolidPaint)
  result.fillStyle.color = color(0, 0, 0, 1)
  result.strokeStyle = newPaint(SolidPaint)
  result.strokeStyle.color = color(0, 0, 0, 1)
  result.fontSize = 12
  result.textBaseline = AlphabeticBaseline

proc newContext*(width, height: int): Context {.inline, raises: [PixieError].} =
  ## Create a new Context that will draw to a new image of width and height.
  newContext(newImage(width, height))

proc state(ctx: Context): ContextState =
  result.fillStyle = ctx.fillStyle
  result.strokeStyle = ctx.strokeStyle
  result.globalAlpha = ctx.globalAlpha
  result.lineWidth = ctx.lineWidth
  result.miterLimit = ctx.miterLimit
  result.lineCap = ctx.lineCap
  result.lineJoin = ctx.lineJoin
  result.font = ctx.font
  result.fontSize = ctx.fontSize
  result.textAlign = ctx.textAlign
  result.lineDash = ctx.lineDash
  result.mat = ctx.mat
  result.mask = if ctx.mask != nil: ctx.mask.copy() else: nil

proc save*(ctx: Context) {.inline, raises: [].} =
  ## Saves the entire state of the context by pushing the current state onto
  ## a stack.
  ctx.stateStack.add(ctx.state())
  ctx.fillStyle = ctx.fillStyle.copy()
  ctx.strokeStyle = ctx.strokeStyle.copy()

proc saveLayer*(ctx: Context) {.raises: [PixieError].} =
  ## Saves the entire state of the context by pushing the current state onto
  ## a stack and allocates a new image layer for subsequent drawing. Calling
  ## restore blends the current layer image onto the prior layer or root image.
  var state = ctx.state()
  state.layer = ctx.layer
  ctx.stateStack.add(state)
  ctx.layer = newImage(ctx.image.width, ctx.image.height)

proc restore*(ctx: Context) {.raises: [PixieError].} =
  ## Restores the most recently saved context state by popping the top entry
  ## in the drawing state stack. If there is no saved state, this method does
  ## nothing.
  if ctx.stateStack.len == 0:
    return

  let
    poppedLayer = ctx.layer
    poppedMask = ctx.mask

  let state = ctx.stateStack.pop()
  ctx.fillStyle = state.fillStyle
  ctx.strokeStyle = state.strokeStyle
  ctx.globalAlpha = state.globalAlpha
  ctx.lineWidth = state.lineWidth
  ctx.miterLimit = state.miterLimit
  ctx.lineCap = state.lineCap
  ctx.lineJoin = state.lineJoin
  ctx.font = state.font
  ctx.fontSize = state.fontSize
  ctx.textAlign = state.textAlign
  ctx.lineDash = state.lineDash
  ctx.mat = state.mat
  ctx.mask = state.mask
  ctx.layer = state.layer

  if poppedLayer != nil: # If there is a layer being popped
    if poppedMask != nil: # If there is a mask, apply it
      poppedLayer.draw(poppedMask, blendMode = MaskBlend)
    if ctx.layer != nil: # If we popped to another layer, draw to it
      ctx.layer.draw(poppedLayer)
    else: # Otherwise draw to the root image
      ctx.image.draw(poppedLayer)

proc fill(ctx: Context, image: Image, path: Path, windingRule: WindingRule) =
  var image = image

  if ctx.globalAlpha != 1:
    ctx.saveLayer()
    image = ctx.layer

  image.fillPath(
    path,
    ctx.fillStyle,
    ctx.mat,
    windingRule
  )

  if ctx.globalAlpha != 1:
    ctx.layer.applyOpacity(ctx.globalAlpha)
    ctx.restore()

proc stroke(ctx: Context, image: Image, path: Path) =
  var image = image

  if ctx.globalAlpha != 1:
    ctx.saveLayer()
    image = ctx.layer

  image.strokePath(
    path,
    ctx.strokeStyle,
    ctx.mat,
    ctx.lineWidth,
    ctx.lineCap,
    ctx.lineJoin,
    ctx.miterLimit,
    ctx.lineDash
  )

  if ctx.globalAlpha != 1:
    ctx.layer.applyOpacity(ctx.globalAlpha)
    ctx.restore()

proc newFont(ctx: Context): Font =
  if ctx.font == "":
    raise newException(PixieError, "No font has been set on this Context")

  if ctx.font notin ctx.typefaces:
    ctx.typefaces[ctx.font] = readTypeface(ctx.font)

  result = newFont(ctx.typefaces.getOrDefault(ctx.font, nil))
  result.size = ctx.fontSize

proc fillText(ctx: Context, image: Image, text: string, at: Vec2) =
  let font = newFont(ctx)

  # Canvas positions text relative to the alphabetic baseline by default
  var at = at

  case ctx.textBaseline:
    of TopBaseline:
      discard
    of HangingBaseline:
      # TODO: make accurate (Used by Tibetan and other Indic scripts.)
      discard
    of MiddleBaseline:
      at.y -= round((font.typeface.ascent - font.typeface.descent) / 2 * font.scale)
    of AlphabeticBaseline:
      at.y -= round(font.typeface.ascent * font.scale)
    of IdeographicBaseline:
      # TODO: make accurate (Used by Chinese, Japanese, and Korean scripts.)
      at.y -= round((font.typeface.ascent - font.typeface.descent) * font.scale)
    of BottomBaseline:
      at.y -= round((font.typeface.ascent - font.typeface.descent) * font.scale)

  font.paint = ctx.fillStyle

  var image = image

  if ctx.globalAlpha != 1:
    ctx.saveLayer()
    image = ctx.layer

  image.fillText(
    font,
    text,
    ctx.mat * translate(at),
    hAlign = ctx.textAlign
  )

  if ctx.globalAlpha != 1:
    ctx.layer.applyOpacity(ctx.globalAlpha)
    ctx.restore()

proc strokeText(ctx: Context, image: Image, text: string, at: Vec2) =
  let font = newFont(ctx)

  # Canvas positions text relative to the alphabetic baseline by default
  var at = at
  at.y -= round(font.typeface.ascent * font.scale)

  font.paint = ctx.strokeStyle

  var image = image

  if ctx.globalAlpha != 1:
    ctx.saveLayer()
    image = ctx.layer

  image.strokeText(
    font,
    text,
    ctx.mat * translate(at),
    ctx.lineWidth,
    hAlign = ctx.textAlign,
    lineCap = ctx.lineCap,
    lineJoin = ctx.lineJoin,
    miterLimit = ctx.miterLimit,
    dashes = ctx.lineDash
  )

  if ctx.globalAlpha != 1:
    ctx.layer.applyOpacity(ctx.globalAlpha)
    ctx.restore()

proc beginPath*(ctx: Context) {.inline, raises: [].} =
  ## Starts a new path by emptying the list of sub-paths.
  ctx.path = newPath()

proc moveTo*(ctx: Context, v: Vec2) {.inline, raises: [].} =
  ## Begins a new sub-path at the point (x, y).
  ctx.path.moveTo(v)

proc moveTo*(ctx: Context, x, y: float32) {.inline, raises: [].} =
  ## Begins a new sub-path at the point (x, y).
  ctx.moveTo(vec2(x, y))

proc lineTo*(ctx: Context, v: Vec2) {.inline, raises: [].} =
  ## Adds a straight line to the current sub-path by connecting the sub-path's
  ## last point to the specified (x, y) coordinates.
  ctx.path.lineTo(v)

proc lineTo*(ctx: Context, x, y: float32) {.inline, raises: [].} =
  ## Adds a straight line to the current sub-path by connecting the sub-path's
  ## last point to the specified (x, y) coordinates.
  ctx.lineTo(vec2(x, y))

proc bezierCurveTo*(ctx: Context, cp1, cp2, to: Vec2) {.inline, raises: [].} =
  ## Adds a cubic BÃ©zier curve to the current sub-path. It requires three
  ## points: the first two are control points and the third one is the end
  ## point. The starting point is the latest point in the current path,
  ## which can be changed using moveTo() before creating the BÃ©zier curve.
  ctx.path.bezierCurveTo(cp1, cp2, to)

proc bezierCurveTo*(
  ctx: Context, cp1x, cp1y, cp2x, cp2y, x, y: float32
) {.inline, raises: [].} =
  ## Adds a cubic BÃ©zier curve to the current sub-path. It requires three
  ## points: the first two are control points and the third one is the end
  ## point. The starting point is the latest point in the current path,
  ## which can be changed using moveTo() before creating the BÃ©zier curve.
  ctx.bezierCurveTo(vec2(cp1x, cp1y), vec2(cp2x, cp2y), vec2(x, y))

proc quadraticCurveTo*(
  ctx: Context, cpx, cpy, x, y: float32
) {.inline, raises: [].} =
  ## Adds a quadratic BÃ©zier curve to the current sub-path. It requires two
  ## points: the first one is a control point and the second one is the end
  ## point. The starting point is the latest point in the current path,
  ## which can be changed using moveTo() before creating the quadratic
  ## BÃ©zier curve.
  ctx.path.quadraticCurveTo(cpx, cpy, x, y)

proc quadraticCurveTo*(
  ctx: Context, ctrl, to: Vec2
) {.inline, raises: [].} =
  ## Adds a quadratic BÃ©zier curve to the current sub-path. It requires two
  ## points: the first one is a control point and the second one is the end
  ## point. The starting point is the latest point in the current path,
  ## which can be changed using moveTo() before creating the quadratic
  ## BÃ©zier curve.
  ctx.path.quadraticCurveTo(ctrl, to)

proc arc*(
  ctx: Context, x, y, r, a0, a1: float32, ccw: bool = false
) {.raises: [PixieError].} =
  ## Draws a circular arc.
  ctx.path.arc(x, y, r, a0, a1, ccw)

proc arc*(
  ctx: Context, pos: Vec2, r: float32, a: Vec2, ccw: bool = false
) {.raises: [PixieError].} =
  ## Adds a circular arc to the current sub-path.
  ctx.path.arc(pos, r, a, ccw)

proc arcTo*(
  ctx: Context, x1, y1, x2, y2, radius: float32
) {.raises: [PixieError].} =
  ## Draws a circular arc using the given control points and radius.
  ctx.path.arcTo(x1, y1, x2, y2, radius)

proc arcTo*(
  ctx: Context, a, b: Vec2, r: float32
) {.raises: [PixieError].} =
  ## Adds a circular arc using the given control points and radius.
  ctx.path.arcTo(a, b, r)

proc closePath*(ctx: Context) {.inline, raises: [].} =
  ## Attempts to add a straight line from the current point to the start of
  ## the current sub-path. If the shape has already been closed or has only
  ## one point, this function does nothing.
  ctx.path.closePath()

proc rect*(ctx: Context, rect: Rect) {.inline, raises: [].} =
  ## Adds a rectangle to the current path.
  ctx.path.rect(rect)

proc rect*(ctx: Context, x, y, width, height: float32) {.inline, raises: [].} =
  ## Adds a rectangle to the current path.
  ctx.path.rect(x, y, width, height)

proc ellipse*(ctx: Context, center: Vec2, rx, ry: float32) {.inline, raises: [].} =
  ## Adds an ellipse to the current sub-path.
  ctx.path.ellipse(center, rx, ry)

proc ellipse*(ctx: Context, x, y, rx, ry: float32) {.inline, raises: [].} =
  ## Adds an ellipse to the current sub-path.
  ctx.path.ellipse(x, y, rx, ry)

proc fill*(
  ctx: Context, path: Path, windingRule = NonZero
) {.raises: [PixieError].} =
  ## Fills the path with the current fillStyle.
  if ctx.mask != nil and ctx.layer == nil:
    ctx.saveLayer()
    ctx.fill(ctx.layer, path, windingRule)
    ctx.restore()
  elif ctx.layer != nil:
    ctx.fill(ctx.layer, path, windingRule)
  else:
    ctx.fill(ctx.image, path, windingRule)

proc fill*(
  ctx: Context, windingRule = NonZero
) {.inline, raises: [PixieError].} =
  ## Fills the current path with the current fillStyle.
  ctx.fill(ctx.path, windingRule)

proc clip*(
  ctx: Context, path: Path, windingRule = NonZero
) {.raises: [PixieError].} =
  ## Turns the path into the current clipping region. The previous clipping
  ## region, if any, is intersected with the current or given path to create
  ## the new clipping region.
  if ctx.mask == nil:
    ctx.mask = newImage(ctx.image.width, ctx.image.height)
    let maskPaint = newPaint(SolidPaint)
    maskPaint.color = color(1, 1, 1, 1)
    maskPaint.blendMode = OverwriteBlend
    ctx.mask.fillPath(path, maskPaint, windingRule = windingRule)
  else:
    let maskPaint = newPaint(SolidPaint)
    maskPaint.color = color(1, 1, 1, 1)
    maskPaint.blendMode = MaskBlend
    ctx.mask.fillPath(path, maskPaint, windingRule = windingRule)

proc clip*(
  ctx: Context, windingRule = NonZero
) {.inline, raises: [PixieError].} =
  ## Turns the current path into the current clipping region. The previous
  ## clipping region, if any, is intersected with the current or given path
  ## to create the new clipping region.
  ctx.clip(ctx.path, windingRule)

proc stroke*(ctx: Context, path: Path) {.raises: [PixieError].} =
  ## Strokes (outlines) the current or given path with the current strokeStyle.
  if ctx.mask != nil and ctx.layer == nil:
    ctx.saveLayer()
    ctx.stroke(ctx.layer, path)
    ctx.restore()
  elif ctx.layer != nil:
    ctx.stroke(ctx.layer, path)
  else:
    ctx.stroke(ctx.image, path)

proc stroke*(ctx: Context) {.inline, raises: [PixieError].} =
  ## Strokes (outlines) the current or given path with the current strokeStyle.
  ctx.stroke(ctx.path)

proc clearRect*(ctx: Context, rect: Rect) {.raises: [PixieError].} =
  ## Erases the pixels in a rectangular area.
  let paint = newPaint(SolidPaint)
  paint.blendMode = OverwriteBlend

  let path = newPath()
  path.rect(rect)
  if ctx.layer != nil:
    ctx.layer.fillPath(path, paint, ctx.mat)
  else:
    ctx.image.fillPath(path, paint, ctx.mat)

proc clearRect*(
  ctx: Context, x, y, width, height: float32
) {.inline, raises: [PixieError].} =
  ## Erases the pixels in a rectangular area.
  ctx.clearRect(rect(x, y, width, height))

proc fillRect*(ctx: Context, rect: Rect) {.raises: [PixieError].} =
  ## Draws a rectangle that is filled according to the current fillStyle.
  let path = newPath()
  path.rect(rect)
  ctx.fill(path)

proc fillRect*(
  ctx: Context, x, y, width, height: float32
) {.inline, raises: [PixieError].} =
  ## Draws a rectangle that is filled according to the current fillStyle.
  ctx.fillRect(rect(x, y, width, height))

proc strokeRect*(ctx: Context, rect: Rect) {.raises: [PixieError].} =
  ## Draws a rectangle that is stroked (outlined) according to the current
  ## strokeStyle and other context settings.
  let path = newPath()
  path.rect(rect)
  ctx.stroke(path)

proc strokeRect*(
  ctx: Context, x, y, width, height: float32
) {.inline, raises: [PixieError].} =
  ## Draws a rectangle that is stroked (outlined) according to the current
  ## strokeStyle and other context settings.
  ctx.strokeRect(rect(x, y, width, height))

proc fillText*(ctx: Context, text: string, at: Vec2) {.raises: [PixieError].} =
  ## Draws a text string at the specified coordinates, filling the string's
  ## characters with the current fillStyle
  if ctx.mask != nil and ctx.layer == nil:
    ctx.saveLayer()
    ctx.fillText(ctx.layer, text, at)
    ctx.restore()
  elif ctx.layer != nil:
    ctx.fillText(ctx.layer, text, at)
  else:
    ctx.fillText(ctx.image, text, at)

proc fillText*(
  ctx: Context, text: string, x, y: float32
) {.inline, raises: [PixieError].} =
  ## Draws a text string at the specified coordinates, filling the string's
  ## characters with the current fillStyle
  ctx.fillText(text, vec2(x, y))

proc strokeText*(ctx: Context, text: string, at: Vec2) {.raises: [PixieError].} =
  ## Draws the outlines of the characters of a text string at the specified
  ## coordinates.
  if ctx.mask != nil and ctx.layer == nil:
    ctx.saveLayer()
    ctx.strokeText(ctx.layer, text, at)
    ctx.restore()
  elif ctx.layer != nil:
    ctx.strokeText(ctx.layer, text, at)
  else:
    ctx.strokeText(ctx.image, text, at)

proc strokeText*(
  ctx: Context, text: string, x, y: float32
) {.inline, raises: [PixieError].} =
  ## Draws the outlines of the characters of a text string at the specified
  ## coordinates.
  ctx.strokeText(text, vec2(x, y))

proc measureText*(ctx: Context, text: string): TextMetrics {.raises: [PixieError].} =
  ## Returns a TextMetrics object that contains information about the measured
  ## text (such as its width, for example).
  let
    font = newFont(ctx)
    bounds = typeset(font, text).layoutBounds()
  result.width = bounds.x

proc getLineDash*(ctx: Context): seq[float32] {.inline, raises: [].} =
  ctx.lineDash

proc setLineDash*(ctx: Context, lineDash: seq[float32]) {.inline, raises: [].} =
  ctx.lineDash = lineDash

proc getTransform*(ctx: Context): Mat3 {.inline, raises: [].} =
  ## Retrieves the current transform matrix being applied to the context.
  ctx.mat

proc setTransform*(ctx: Context, transform: Mat3) {.inline, raises: [].} =
  ## Overrides the transform matrix being applied to the context.
  ctx.mat = transform

proc transform*(ctx: Context, transform: Mat3) {.inline, raises: [].} =
  ## Multiplies the current transform with the matrix described by the
  ## arguments of this method.
  ctx.mat = ctx.mat * transform

proc translate*(ctx: Context, v: Vec2) {.inline, raises: [].} =
  ## Adds a translation transformation to the current matrix.
  ctx.mat = ctx.mat * translate(v)

proc translate*(ctx: Context, x, y: float32) {.inline, raises: [].} =
  ## Adds a translation transformation to the current matrix.
  ctx.mat = ctx.mat * translate(vec2(x, y))

proc scale*(ctx: Context, v: Vec2) {.inline, raises: [].} =
  ## Adds a scaling transformation to the context units horizontally and/or
  ## vertically.
  ctx.mat = ctx.mat * scale(v)

proc scale*(ctx: Context, x, y: float32) {.inline, raises: [].} =
  ## Adds a scaling transformation to the context units horizontally and/or
  ## vertically.
  ctx.mat = ctx.mat * scale(vec2(x, y))

proc rotate*(ctx: Context, angle: float32) {.inline, raises: [].} =
  ## Adds a rotation to the transformation matrix.
  ctx.mat = ctx.mat * rotate(-angle)

proc resetTransform*(ctx: Context) {.inline, raises: [].} =
  ## Resets the current transform to the identity matrix.
  ctx.mat = mat3()

proc drawImage*(
  ctx: Context, image: Image, dx, dy, dWidth, dHeight: float32
) {.raises: [PixieError].} =
  ## Draws a source image onto the destination image.
  let
    imageMat = ctx.mat * translate(vec2(dx, dy)) * scale(vec2(
      dWidth / image.width.float32,
      dHeight / image.height.float32
    ))
    savedFillStyle = ctx.fillStyle

  ctx.fillStyle = newPaint(ImagePaint)
  ctx.fillStyle.image = image
  ctx.fillStyle.imageMat = imageMat

  let path = newPath()
  path.rect(rect(dx, dy, dWidth, dHeight))
  ctx.fill(path)

  ctx.fillStyle = savedFillStyle

proc drawImage*(
  ctx: Context, image: Image, dx, dy: float32
) {.raises: [PixieError].} =
  ## Draws a source image onto the destination image.
  ctx.drawImage(image, dx, dy, image.width.float32, image.height.float32)

proc drawImage*(ctx: Context, image: Image, pos: Vec2) {.raises: [PixieError].} =
  ## Draws a source image onto the destination image.
  ctx.drawImage(image, pos.x, pos.y)

proc drawImage*(ctx: Context, image: Image, rect: Rect) {.raises: [PixieError].} =
  ## Draws a source image onto the destination image.
  ctx.drawImage(image, rect.x, rect.y, rect.w, rect.h)

proc drawImage*(
  ctx: Context,
  image: Image,
  sx, sy, sWidth, sHeight,
  dx, dy, dWidth, dHeight: float32
) {.raises: [PixieError].} =
  ## Draws a source image onto the destination image.
  let image = image.subImage(sx.int, sy.int, sWidth.int, sHeight.int)
  ctx.drawImage(image, dx, dy, image.width.float32, image.height.float32)

proc drawImage*(ctx: Context, image: Image, src, dest: Rect) {.raises: [PixieError].} =
  ## Draws a source image onto the destination image.
  ctx.drawImage(
    image,
    src.x, src.y, src.w, src.h,
    dest.x, dest.y, dest.w, dest.h
  )

proc isPointInPath*(
  ctx: Context, path: Path, pos: Vec2, windingRule = NonZero
): bool {.raises: [PixieError].} =
  ## Returns whether or not the specified point is contained in the current path.
  path.fillOverlaps(pos, ctx.mat, windingRule)

proc isPointInPath*(
  ctx: Context, path: Path, x, y: float32, windingRule = NonZero
): bool {.inline, raises: [PixieError].} =
  ## Returns whether or not the specified point is contained in the current path.
  ctx.isPointInPath(path, vec2(x, y), windingRule)

proc isPointInPath*(
  ctx: Context, pos: Vec2, windingRule = NonZero
): bool {.inline, raises: [PixieError].} =
  ## Returns whether or not the specified point is contained in the current path.
  ctx.isPointInPath(ctx.path, pos, windingRule)

proc isPointInPath*(
  ctx: Context, x, y: float32, windingRule = NonZero
): bool {.inline, raises: [PixieError].} =
  ## Returns whether or not the specified point is contained in the current path.
  ctx.isPointInPath(ctx.path, vec2(x, y), windingRule)

proc isPointInStroke*(
  ctx: Context, path: Path, pos: Vec2
): bool {.raises: [PixieError].} =
  ## Returns whether or not the specified point is inside the area contained
  ## by the stroking of a path.
  path.strokeOverlaps(
    pos,
    ctx.mat,
    ctx.lineWidth,
    ctx.lineCap,
    ctx.lineJoin,
    ctx.miterLimit,
    ctx.lineDash
  )

proc isPointInStroke*(
  ctx: Context, path: Path, x, y: float32
): bool {.inline, raises: [PixieError].} =
  ## Returns whether or not the specified point is inside the area contained
  ## by the stroking of a path.
  ctx.isPointInStroke(path, vec2(x, y))

proc isPointInStroke*(
  ctx: Context, pos: Vec2
): bool {.inline, raises: [PixieError].} =
  ## Returns whether or not the specified point is inside the area contained
  ## by the stroking of a path.
  ctx.isPointInStroke(ctx.path, pos)

proc isPointInStroke*(
  ctx: Context, x, y: float32
): bool {.inline, raises: [PixieError].} =
  ## Returns whether or not the specified point is inside the area contained
  ## by the stroking of a path.
  ctx.isPointInStroke(ctx.path, vec2(x, y))

#
# Additional procs that are not part of the JS API
#

proc roundedRect*(
  ctx: Context, x, y, w, h, nw, ne, se, sw: float32
) {.inline, raises: [].} =
  ## Adds a rounded rectangle to the current path.
  ctx.path.roundedRect(x, y, w, h, nw, ne, se, sw)

proc roundedRect*(
  ctx: Context, rect: Rect, nw, ne, se, sw: float32
) {.inline, raises: [].} =
  ## Adds a rounded rectangle to the current path.
  ctx.path.roundedRect(rect, nw, ne, se, sw)

proc circle*(ctx: Context, cx, cy, r: float32) {.inline, raises: [].} =
  ## Adds a circle to the current path.
  ctx.path.circle(cx, cy, r)

proc circle*(ctx: Context, circle: Circle) {.inline, raises: [].} =
  ## Adds a circle to the current path.
  ctx.path.circle(circle)

proc polygon*(
  ctx: Context, x, y, size: float32, sides: int
) {.inline, raises: [PixieError].} =
  ## Adds an n-sided regular polygon at (x, y) of size to the current path.
  ctx.path.polygon(x, y, size, sides)

proc polygon*(
  ctx: Context, pos: Vec2, size: float32, sides: int
) {.inline, raises: [PixieError].} =
  ## Adds an n-sided regular polygon at (x, y) of size to the current path.
  ctx.path.polygon(pos, size, sides)

proc strokeSegment*(ctx: Context, segment: Segment) {.raises: [PixieError].} =
  ## Strokes a segment (draws a line from segment.at to segment.to) according
  ## to the current strokeStyle and other context settings.
  let path = newPath()
  path.moveTo(segment.at)
  path.lineTo(segment.to)
  ctx.stroke(path)

proc strokeSegment*(ctx: Context, ax, ay, bx, by: float32) {.raises: [PixieError].} =
  ## Strokes a segment (draws a line from ax, ay to bx, by) according
  ## to the current strokeStyle and other context settings.
  ctx.strokeSegment(segment(vec2(ax, ay), vec2(bx, by)))

proc fillRoundedRect*(
  ctx: Context, rect: Rect, nw, ne, se, sw: float32
) {.raises: [PixieError].} =
  ## Draws a rounded rectangle that is filled according to the current fillStyle.
  let path = newPath()
  path.roundedRect(rect, nw, ne, se, sw)
  ctx.fill(path)

proc fillRoundedRect*(
  ctx: Context, rect: Rect, radius: float32
) {.inline, raises: [PixieError].} =
  ## Draws a rounded rectangle that is filled according to the current fillStyle.
  ctx.fillRoundedRect(rect, radius, radius, radius, radius)

proc strokeRoundedRect*(
  ctx: Context, rect: Rect, nw, ne, se, sw: float32
) {.raises: [PixieError].} =
  ## Draws a rounded rectangle that is stroked (outlined) according to the
  ## current strokeStyle and other context settings.
  let path = newPath()
  path.roundedRect(rect, nw, ne, se, sw)
  ctx.stroke(path)

proc strokeRoundedRect*(
  ctx: Context, rect: Rect, radius: float32
) {.inline, raises: [PixieError].} =
  ## Draws a rounded rectangle that is stroked (outlined) according to the
  ## current strokeStyle and other context settings.
  ctx.strokeRoundedRect(rect, radius, radius, radius, radius)

proc fillEllipse*(
  ctx: Context, center: Vec2, rx, ry: float32
) {.raises: [PixieError].} =
  ## Draws an ellipse that is filled according to the current fillStyle.
  let path = newPath()
  path.ellipse(center, rx, ry)
  ctx.fill(path)

proc strokeEllipse*(
  ctx: Context, center: Vec2, rx, ry: float32
) {.raises: [PixieError].} =
  ## Draws an ellipse that is stroked (outlined) according to the current
  ## strokeStyle and other context settings.
  let path = newPath()
  path.ellipse(center, rx, ry)
  ctx.stroke(path)

proc fillCircle*(
  ctx: Context, circle: Circle
) {.raises: [PixieError].} =
  ## Draws a circle that is filled according to the current fillStyle
  let path = newPath()
  path.circle(circle)
  ctx.fill(path)

proc strokeCircle*(
  ctx: Context, circle: Circle
) {.raises: [PixieError].} =
  ## Draws a circle that is stroked (outlined) according to the current
  ## strokeStyle and other context settings.
  let path = newPath()
  path.circle(circle)
  ctx.stroke(path)

proc fillPolygon*(
  ctx: Context, pos: Vec2, size: float32, sides: int
) {.raises: [PixieError].} =
  ## Draws an n-sided regular polygon at (x, y) of size that is filled according
  ## to the current fillStyle.
  let path = newPath()
  path.polygon(pos, size, sides)
  ctx.fill(path)

proc strokePolygon*(
  ctx: Context, pos: Vec2, size: float32, sides: int
) {.raises: [PixieError].} =
  ## Draws an n-sided regular polygon at (x, y) of size that is stroked
  ## (outlined) according to the current strokeStyle and other context settings.
  let path = newPath()
  path.polygon(pos, size, sides)
  ctx.stroke(path)



================================================
FILE: src/pixie/fonts.nim
================================================
import bumpy, chroma, common, os, fontformats/opentype,
    fontformats/svgfont, images, paints, paths,
    strutils, unicode, vmath

const
  autoLineHeight*: float32 = -1 ## Use default line height for the font size
  LF = Rune(10)
  SP = Rune(32)

type
  Typeface* = ref object
    opentype: OpenType
    svgFont: SvgFont
    filePath*: string
    fallbacks*: seq[Typeface]

  Font* = ref object
    typeface*: Typeface
    size*: float32              ## Font size in pixels.
    lineHeight*: float32 ## The line height in pixels or autoLineHeight for the font's default line height.
    paints*: seq[Paint]
    textCase*: TextCase
    underline*: bool            ## Apply an underline.
    strikethrough*: bool        ## Apply a strikethrough.
    noKerningAdjustments*: bool ## Optionally disable kerning pair adjustments

  Span* = ref object
    text*: string
    font*: Font

  Arrangement* = ref object
    lines*: seq[(int, int)]    ## The (start, stop) of the lines of text.
    spans*: seq[(int, int)]    ## The (start, stop) of the spans in the text.
    fonts*: seq[Font]          ## The font for each span.
    runes*: seq[Rune]          ## The runes of the text.
    positions*: seq[Vec2]      ## The positions of the glyphs for each rune.
    selectionRects*: seq[Rect] ## The selection rects for each glyph.

  HorizontalAlignment* = enum
    LeftAlign
    CenterAlign
    RightAlign

  VerticalAlignment* = enum
    TopAlign
    MiddleAlign
    BottomAlign

  TextCase* = enum
    NormalCase
    UpperCase
    LowerCase
    TitleCase
    # tcSmallCaps
    # tcSmallCapsForced

proc scale*(typeface: Typeface): float32 {.inline, raises: [].} =
  ## The scale factor to transform font units into pixels.
  if typeface.opentype != nil:
    typeface.opentype.head.unitsPerEm.float32
  else:
    typeface.svgFont.unitsPerEm

proc ascent*(typeface: Typeface): float32 {.raises: [].} =
  ## The font ascender value in font units.
  if typeface.opentype != nil:
    typeface.opentype.hhea.ascender.float32
  else:
    typeface.svgFont.ascent

proc descent*(typeface: Typeface): float32 {.raises: [].} =
  ## The font descender value in font units.
  if typeface.opentype != nil:
    typeface.opentype.hhea.descender.float32
  else:
    typeface.svgFont.descent

proc lineGap*(typeface: Typeface): float32 {.raises: [].} =
  ## The font line gap value in font units.
  if typeface.opentype != nil:
    result = typeface.opentype.hhea.lineGap.float32

proc lineHeight*(typeface: Typeface): float32 {.inline, raises: [].} =
  ## The default line height in font units.
  # The descent is negative number, so this is really ascent + descent + lineGap.
  typeface.ascent - typeface.descent + typeface.lineGap

proc capHeight*(typeface: Typeface): float32 {.raises: [].} =
  ## The font cap height value in font units.
  if typeface.opentype != nil:
    result = typeface.opentype.os2.sCapHeight.float32

proc underlinePosition(typeface: Typeface): float32 =
  if typeface.opentype != nil:
    result = typeface.opentype.post.underlinePosition.float32

proc underlineThickness(typeface: Typeface): float32 =
  if typeface.opentype != nil:
    result = typeface.opentype.post.underlineThickness.float32

proc strikeoutPosition(typeface: Typeface): float32 =
  if typeface.opentype != nil:
    result = typeface.opentype.os2.yStrikeoutPosition.float32

proc strikeoutThickness(typeface: Typeface): float32 =
  if typeface.opentype != nil:
    result = typeface.opentype.os2.yStrikeoutSize.float32

proc isCCW(typeface: Typeface): bool {.inline.} =
  ## Returns the expected winding order of a font.
  if typeface.opentype != nil:
    return typeface.opentype.isCCW()

proc hasGlyph*(typeface: Typeface, rune: Rune): bool {.inline.} =
  ## Returns if there is a glyph for this rune.
  if typeface.opentype != nil:
    typeface.opentype.hasGlyph(rune)
  else:
    typeface.svgFont.hasGlyph(rune)

proc fallbackTypeface*(typeface: Typeface, rune: Rune): Typeface =
  ## Looks through fallback typefaces to find one that has the glyph.
  if typeface.hasGlyph(rune):
    return typeface
  for fallback in typeface.fallbacks:
    let typeface = fallback.fallbackTypeface(rune)
    if typeface != nil:
      return typeface

proc getGlyphPath*(
  typeface: Typeface, rune: Rune
): Path {.inline, raises: [PixieError].} =
  ## The glyph path for the rune.
  result = newPath()

  let typeface2 = typeface.fallbackTypeface(rune)
  if typeface2 == nil:
    return

  if typeface2.opentype != nil:
    result.addPath(typeface2.opentype.getGlyphPath(rune))
  else:
    result.addPath(typeface2.svgFont.getGlyphPath(rune))

  # Apply typeface ratio.
  let ratio = typeface.scale / typeface2.scale
  if ratio != 1.0:
    result.transform(scale(vec2(ratio, ratio)))

proc getAdvance*(typeface: Typeface, rune: Rune): float32 {.inline, raises: [].} =
  ## The advance for the rune in pixels.
  var typeface2 = typeface.fallbackTypeface(rune)
  if typeface2 == nil:
    # Get tofu advance, see tofu_advance test.
    typeface2 = typeface

  if typeface2.opentype != nil:
    result = typeface2.opentype.getAdvance(rune)
  else:
    result = typeface2.svgFont.getAdvance(rune)

  # Apply typeface ratio.
  result *= typeface.scale / typeface2.scale

proc getKerningAdjustment*(
  typeface: Typeface, left, right: Rune
): float32 {.inline, raises: [].} =
  ## The kerning adjustment for the rune pair, in pixels.
  let
    typefaceRight = typeface.fallbackTypeface(right)
    typefaceLeft = typeface.fallbackTypeface(left)
  # Is there a type face that matches?
  if typefaceRight == nil or typefaceLeft == nil:
    return
  # Only do kerning if both typefaces are the same.
  if typefaceRight == typefaceLeft:
    if typefaceRight.opentype != nil:
      result = typefaceRight.opentype.getKerningAdjustment(left, right)
    else:
      result = typefaceRight.svgfont.getKerningAdjustment(left, right)

    # Apply typeface ratio.
    result *= typeface.scale / typefaceRight.scale

proc scale*(font: Font): float32 {.inline, raises: [].} =
  ## The scale factor to transform font units into pixels.
  font.size / font.typeface.scale

proc defaultLineHeight*(font: Font): float32 {.inline, raises: [].} =
  ## The default line height in pixels for the current font size.
  let fontUnits =
    font.typeface.ascent - font.typeface.descent + font.typeface.lineGap
  round(fontUnits * font.scale)

proc lineGap(font: Font): float32 =
  ## The line gap in font units for the current font size and line-height.
  let lineHeight =
    if font.lineHeight >= 0:
      font.lineHeight
    else:
      font.defaultLineHeight
  if lineHeight == font.defaultLineHeight:
    font.typeface.lineGap
  else:
    (lineHeight / font.scale) - font.typeface.ascent + font.typeface.descent

proc paint*(font: Font): Paint {.inline, raises: [].} =
  font.paints[0]

proc `paint=`*(font: Font, paint: Paint) {.inline, raises: [].} =
  font.paints = @[paint]

proc newFont*(typeface: Typeface): Font {.raises: [].} =
  result = Font()
  result.typeface = typeface
  result.size = 12
  result.lineHeight = autoLineHeight
  result.paint = newPaint(SolidPaint)
  result.paint.color = color(0, 0, 0, 1)

proc copy*(font: Font): Font {.raises: [].} =
  result = Font()
  result.typeface = font.typeface
  result.size = font.size
  result.lineHeight = font.lineHeight
  result.paints = font.paints
  result.textCase = font.textCase
  result.underline = font.underline
  result.strikethrough = font.strikethrough
  result.noKerningAdjustments = font.noKerningAdjustments

proc newSpan*(text: sink string, font: Font): Span {.raises: [].} =
  ## Creates a span, associating a font with the text.
  result = Span(text: text, font: font)

proc convertTextCase(runes: var seq[Rune], textCase: TextCase) =
  case textCase:
  of NormalCase:
    discard
  of UpperCase:
    for rune in runes.mitems:
      rune = rune.toUpper()
  of LowerCase:
    for rune in runes.mitems:
      rune = rune.toLower()
  of TitleCase:
    var prevRune = SP
    for rune in runes.mitems:
      if prevRune.isWhiteSpace:
        rune = rune.toUpper()
      prevRune = rune

proc canWrap(rune: Rune): bool {.inline.} =
  rune == Rune(32) or rune.isWhiteSpace()

proc typeset*(
  spans: openarray[Span],
  bounds = vec2(0, 0),
  hAlign = LeftAlign,
  vAlign = TopAlign,
  wrap = true
): Arrangement {.raises: [].} =
  ## Lays out the character glyphs and returns the arrangement.
  ## Optional parameters:
  ## bounds: width determines wrapping and hAlign, height for vAlign
  ## hAlign: horizontal alignment of the text
  ## vAlign: vertical alignment of the text
  ## wrap: enable/disable text wrapping

  result = Arrangement()

  block: # Walk and filter the spans
    var start: int
    for span in spans:
      var
        i = 0
        rune: Rune
        runes: seq[Rune]
      while i < span.text.len:
        fastRuneAt(span.text, i, rune, true)
        # Ignore control runes (0 - 31) except LF for now
        if rune.uint32 >= SP.uint32 or rune.uint32 == LF.uint32:
          runes.add(rune)

      if runes.len > 0:
        runes.convertTextCase(span.font.textCase)
        result.runes.add(runes)
        result.spans.add((start, start + runes.len - 1))
        result.fonts.add(span.font)
        start += runes.len

  if result.runes.len == 0:
    return

  result.positions.setLen(result.runes.len)
  result.selectionRects.setLen(result.runes.len)

  result.lines = @[(0, 0)] # (start, stop)

  block: # Arrange the glyphs horizontally first (handling line breaks)
    proc advance(font: Font, runes: seq[Rune], i: int): float32 {.inline.} =
      if not font.noKerningAdjustments and i + 1 < runes.len:
        result += font.typeface.getKerningAdjustment(runes[i], runes[i + 1])
      result += font.typeface.getAdvance(runes[i])
      result *= font.scale

    var
      at: Vec2
      prevCanWrap: int
    for spanIndex, (start, stop) in result.spans:
      let font = result.fonts[spanIndex]
      for runeIndex in start .. stop:
        let rune = result.runes[runeIndex]
        if rune == LF:
          let advance = font.typeface.getAdvance(SP) * font.scale
          result.positions[runeIndex] = at
          result.selectionRects[runeIndex] = rect(at.x, at.y, advance, 0)
          at.x = 0
          at.y += 1
          prevCanWrap = 0
          result.lines[^1][1] = runeIndex
          # Start a new line if we are not at the end
          if runeIndex + 1 < result.runes.len:
            result.lines.add((runeIndex + 1, 0))
        else:
          let advance = advance(font, result.runes, runeIndex)
          if wrap and rune != SP and bounds.x > 0 and at.x + advance > bounds.x:
            # Wrap to new line
            at.x = 0
            at.y += 1

            var lineStart = runeIndex

            # Go back and wrap glyphs after the wrap index down to the next line
            if prevCanWrap > 0 and prevCanWrap != runeIndex:
              for i in prevCanWrap + 1 ..< runeIndex:
                result.positions[i] = at
                result.selectionRects[i].xy = vec2(at.x, at.y)
                at.x += advance(font, result.runes, i)
                dec lineStart
              prevCanWrap = 0

            result.lines[^1][1] = lineStart - 1
            result.lines.add((lineStart, 0))

          if rune.canWrap():
            prevCanWrap = runeIndex

          result.positions[runeIndex] = at
          result.selectionRects[runeIndex] = rect(at.x, at.y, advance, 0)
          at.x += advance

    result.lines[^1][1] = result.runes.len - 1

    if hAlign != LeftAlign:
      # Since horizontal alignment adjustments are different for each line,
      # find the start and stop of each line of text.
      for (start, stop) in result.lines:
        var furthestX: float32
        for i in countdown(stop, start):
          if result.runes[i] != SP and result.runes[i] != LF:
            furthestX = result.selectionRects[i].x + result.selectionRects[i].w
            break

        var xAdjustment: float32
        case hAlign:
          of LeftAlign:
            discard
          of CenterAlign:
            xAdjustment = (bounds.x - furthestX) / 2
          of RightAlign:
            xAdjustment = bounds.x - furthestX

        if xAdjustment != 0:
          for i in start .. stop:
            result.positions[i].x += xAdjustment
            result.selectionRects[i].x += xAdjustment

  block: # Arrange the lines vertically
    let initialY = block:
      var maxInitialY: float32
      block outer:
        for spanIndex, (start, stop) in result.spans:
          let
            font = result.fonts[spanIndex]
            fontUnitInitialY = font.typeface.ascent + font.lineGap / 2
          maxInitialY = max(maxInitialY, round(fontUnitInitialY * font.scale))
          if stop >= result.lines[0][1]:
            break outer
      maxInitialY

    var lineHeights = newSeq[float32](result.lines.len)
    block: # Compute each line's line height
      var line: int
      for spanIndex, (start, stop) in result.spans:
        let
          font = result.fonts[spanIndex]
          fontLineHeight =
            if font.lineHeight >= 0:
              font.lineHeight
            else:
              font.defaultLineHeight
        lineHeights[line] = max(lineHeights[line], fontLineHeight)
        for runeIndex in start .. stop:
          # This span could be many lines. This check can be made faster by
          # hopping based on line endings instead of checking each index.
          if line + 1 < result.lines.len and
            runeIndex == result.lines[line + 1][0]:
            inc line
            lineHeights[line] = max(lineHeights[line], fontLineHeight)
        # Handle when span and line endings coincide
        if line + 1 < result.lines.len and stop == result.lines[line][1]:
          inc line

    block: # Vertically position the glyphs
      var
        line: int
        baseline = initialY
      for spanIndex, (start, stop) in result.spans:
        let
          font = result.fonts[spanIndex]
          lineHeight =
            if font.lineHeight >= 0:
              font.lineHeight
            else:
              font.defaultLineHeight
        for runeIndex in start .. stop:
          if line + 1 < result.lines.len and
            runeIndex == result.lines[line + 1][0]:
            inc line
            baseline += lineHeights[line]
          result.positions[runeIndex].y = baseline
          result.selectionRects[runeIndex].y = baseline -
            round((font.typeface.ascent + font.lineGap / 2) * font.scale)
          result.selectionRects[runeIndex].h = lineHeight

    if vAlign != TopAlign:
      let
        finalSelectionRect = result.selectionRects[^1]
        furthestY = finalSelectionRect.y + finalSelectionRect.h

      var yAdjustment: float32
      case vAlign:
        of TopAlign:
          discard
        of MiddleAlign:
          yAdjustment = round((bounds.y - furthestY) / 2)
        of BottomAlign:
          yAdjustment = bounds.y - furthestY

      if yAdjustment != 0:
        for i in 0 ..< result.positions.len:
          result.positions[i].y += yAdjustment
          result.selectionRects[i].y += yAdjustment

  block: # Nudge selection rects to pixel grid
    for rect in result.selectionRects.mitems:
      let
        minX = round(rect.x)
        maxX = round(rect.x + rect.w)
        minY = round(rect.y)
        maxY = round(rect.y + rect.h)
      rect.x = minX
      rect.w = maxX - minX
      rect.y = minY
      rect.h = maxY - minY

proc typeset*(
  font: Font,
  text: sink string,
  bounds = vec2(0, 0),
  hAlign = LeftAlign,
  vAlign = TopAlign,
  wrap = true
): Arrangement {.inline, raises: [].} =
  ## Lays out the character glyphs and returns the arrangement.
  ## Optional parameters:
  ## bounds: width determines wrapping and hAlign, height for vAlign
  ## hAlign: horizontal alignment of the text
  ## vAlign: vertical alignment of the text
  ## wrap: enable/disable text wrapping
  typeset([newSpan(text, font)], bounds, hAlign, vAlign, wrap)

proc layoutBounds*(arrangement: Arrangement): Vec2 {.raises: [].} =
  ## Computes the width and height of the arrangement in pixels.
  if arrangement.runes.len > 0:
    for i in 0 ..< arrangement.runes.len:
      if arrangement.runes[i] != LF:
        # Don't add width of a new line rune.
        let rect = arrangement.selectionRects[i]
        result.x = max(result.x, rect.x + rect.w)
    let finalRect = arrangement.selectionRects[^1]
    result.y = finalRect.y + finalRect.h
    if arrangement.runes[^1] == LF:
      # If the text ends with a new line, we need add another line height.
      result.y += finalRect.h

proc layoutBounds*(font: Font, text: string): Vec2 {.inline, raises: [].} =
  ## Computes the width and height of the text in pixels.
  font.typeset(text).layoutBounds()

proc layoutBounds*(spans: seq[Span]): Vec2 {.inline, raises: [].} =
  ## Computes the width and height of the spans in pixels.
  typeset(spans).layoutBounds()

proc parseOtf*(buf: string): Typeface {.raises: [PixieError].} =
  result = Typeface()
  result.opentype = parseOpenType(buf)

proc parseTtf*(buf: string): Typeface {.raises: [PixieError].} =
  parseOtf(buf)

proc parseSvgFont*(buf: string): Typeface {.raises: [PixieError].} =
  result = Typeface()
  result.svgFont = svgfont.parseSvgFont(buf)

proc computePaths(arrangement: Arrangement): seq[Path] =
  ## Takes an Arrangement and computes Paths for drawing.
  ## Returns a seq of paths that match the seq of Spans in the arrangement.
  ## If you only have one Span you will only get one Path.
  var line: int
  for spanIndex, (start, stop) in arrangement.spans:
    let
      spanPath = newPath()
      font = arrangement.fonts[spanIndex]
      underlineThickness = font.typeface.underlineThickness * font.scale
      underlinePosition = font.typeface.underlinePosition * font.scale
      strikeoutThickness = font.typeface.strikeoutThickness * font.scale
      strikeoutPosition = font.typeface.strikeoutPosition * font.scale
    for runeIndex in start .. stop:
      let
        position = arrangement.positions[runeIndex]
        path = font.typeface.getGlyphPath(arrangement.runes[runeIndex])
      path.transform(
        translate(position) *
        scale(vec2(font.scale))
      )
      var applyDecoration = true
      if runeIndex == arrangement.lines[line][1]:
        inc line
        if arrangement.runes[runeIndex] == SP:
          # Do not apply decoration to the space at end of lines
          applyDecoration = false

      if applyDecoration:
        if font.underline:
          path.rect(
            arrangement.selectionRects[runeIndex].x,
            position.y - underlinePosition + underlineThickness / 2,
            arrangement.selectionRects[runeIndex].w,
            underlineThickness,
            font.typeface.isCCW()
          )
        if font.strikethrough:
          path.rect(
            arrangement.selectionRects[runeIndex].x,
            position.y - strikeoutPosition,
            arrangement.selectionRects[runeIndex].w,
            strikeoutThickness,
            font.typeface.isCCW()
          )

      spanPath.addPath(path)
    result.add(spanPath)

proc textUber(
  target: Image,
  arrangement: Arrangement,
  transform = mat3(),
  strokeWidth: float32 = 1.0,
  lineCap = ButtCap,
  lineJoin = MiterJoin,
  miterLimit = defaultMiterLimit,
  dashes: seq[float32] = @[],
  stroke: static[bool] = false
) =
  let spanPaths = arrangement.computePaths()
  for spanIndex in 0 ..< arrangement.spans.len:
    let path = spanPaths[spanIndex]
    when stroke:
      let font = arrangement.fonts[spanIndex]
      for paint in font.paints:
        target.strokePath(
          path,
          paint,
          transform,
          strokeWidth,
          lineCap,
          lineJoin,
          miterLimit,
          dashes
        )
    else:
      let font = arrangement.fonts[spanIndex]
      for paint in font.paints:
        target.fillPath(path, paint, transform)

proc computeBounds*(
  arrangement: Arrangement,
  transform = mat3()
): Rect {.raises: [PixieError].} =
  let fullPath = newPath()
  for path in arrangement.computePaths():
    fullPath.addPath(path)
  fullPath.transform(transform)
  fullPath.computeBounds()

proc fillText*(
  target: Image,
  arrangement: Arrangement,
  transform = mat3()
) {.inline, raises: [PixieError].} =
  ## Fills the text arrangement.
  textUber(
    target,
    arrangement,
    transform
  )

proc fillText*(
  target: Image,
  font: Font,
  text: sink string,
  transform = mat3(),
  bounds = vec2(0, 0),
  hAlign = LeftAlign,
  vAlign = TopAlign
) {.inline, raises: [PixieError].} =
  ## Typesets and fills the text. Optional parameters:
  ## transform: translation or matrix to apply
  ## bounds: width determines wrapping and hAlign, height for vAlign
  ## hAlign: horizontal alignment of the text
  ## vAlign: vertical alignment of the text
  fillText(target, font.typeset(text, bounds, hAlign, vAlign), transform)

proc strokeText*(
  target: Image,
  arrangement: Arrangement,
  transform = mat3(),
  strokeWidth: float32 = 1.0,
  lineCap = ButtCap,
  lineJoin = MiterJoin,
  miterLimit = defaultMiterLimit,
  dashes: seq[float32] = @[]
) {.inline, raises: [PixieError].} =
  ## Strokes the text arrangement.
  textUber(
    target,
    arrangement,
    transform,
    strokeWidth,
    lineCap,
    lineJoin,
    miterLimit,
    dashes,
    true
  )

proc strokeText*(
  target: Image,
  font: Font,
  text: sink string,
  transform = mat3(),
  strokeWidth: float32 = 1.0,
  bounds = vec2(0, 0),
  hAlign = LeftAlign,
  vAlign = TopAlign,
  lineCap = ButtCap,
  lineJoin = MiterJoin,
  miterLimit = defaultMiterLimit,
  dashes: seq[float32] = @[]
) {.inline, raises: [PixieError].} =
  ## Typesets and strokes the text. Optional parameters:
  ## transform: translation or matrix to apply
  ## bounds: width determines wrapping and hAlign, height for vAlign
  ## hAlign: horizontal alignment of the text
  ## vAlign: vertical alignment of the text
  ## lineCap: stroke line cap shape
  ## lineJoin: stroke line join shape
  strokeText(
    target,
    font.typeset(text, bounds, hAlign, vAlign),
    transform,
    strokeWidth,
    lineCap,
    lineJoin,
    miterLimit,
    dashes
  )

proc readTypeface*(filePath: string): Typeface {.raises: [PixieError].} =
  ## Loads a typeface from a file.
  try:
    result =
      case splitFile(filePath).ext.toLowerAscii():
        of ".ttf":
          parseTtf(readFile(filePath))
        of ".otf":
          parseOtf(readFile(filePath))
        of ".svg":
          parseSvgFont(readFile(filePath))
        else:
          raise newException(PixieError, "Unsupported font format")
  except IOError as e:
    raise newException(PixieError, e.msg, e)

  result.filePath = filePath

proc readTypefaces*(filePath: string): seq[Typeface] {.raises: [PixieError].} =
  ## Loads a OpenType Collection (.ttc).
  try:
    for opentype in parseOpenTypeCollection(readFile(filePath)):
      let typeface = Typeface()
      typeface.opentype = opentype
      result.add(typeface)
  except IOError as e:
    raise newException(PixieError, e.msg, e)

proc name*(typeface: Typeface): string =
  ## Returns the name of the font.
  if typeface.opentype != nil:
    return typeface.opentype.fullName

proc readFont*(filePath: string): Font {.raises: [PixieError].} =
  ## Loads a font from a file.
  newFont(readTypeface(filePath))



================================================
FILE: src/pixie/images.nim
================================================
import blends, bumpy, chroma, common, internal, simd, vmath

export Image, copy, dataIndex, newImage

const h = 0.5.float32

type UnsafeImage = distinct Image

when defined(release):
  {.push checks: off.}

proc `$`*(image: Image): string {.raises: [].} =
  ## Prints the image size.
  "<Image " & $image.width & "x" & $image.height & ">"

proc inside*(image: Image, x, y: int): bool {.inline, raises: [].} =
  ## Returns true if (x, y) is inside the image.
  x >= 0 and x < image.width and y >= 0 and y < image.height

template unsafe*(src: Image): UnsafeImage =
  cast[UnsafeImage](src)

template `[]`*(view: UnsafeImage, x, y: int): var ColorRGBX =
  ## Gets a color from (x, y) coordinates.
  ## * No bounds checking *
  ## Make sure that x, y are in bounds.
  ## Failure in the assumptions will cause unsafe memory reads.
  cast[Image](view).data[cast[Image](view).dataIndex(x, y)]

template `[]=`*(view: UnsafeImage, x, y: int, color: ColorRGBX) =
  ## Sets a color from (x, y) coordinates.
  ## * No bounds checking *
  ## Make sure that x, y are in bounds.
  ## Failure in the assumptions will cause unsafe memory writes.
  cast[Image](view).data[cast[Image](view).dataIndex(x, y)] = color

proc `[]`*(image: Image, x, y: int): ColorRGBX {.inline, raises: [].} =
  ## Gets a pixel at (x, y) or returns transparent black if outside of bounds.
  if image.inside(x, y):
    return image.unsafe[x, y]

proc `[]=`*(image: Image, x, y: int, color: SomeColor) {.inline, raises: [].} =
  ## Sets a pixel at (x, y) or does nothing if outside of bounds.
  if image.inside(x, y):
    image.unsafe[x, y] = color.asRgbx()

proc getColor*(image: Image, x, y: int): Color {.inline, raises: [].} =
  ## Gets a color at (x, y) or returns transparent black if outside of bounds.
  image[x, y].color()

proc setColor*(image: Image, x, y: int, color: Color) {.inline, raises: [].} =
  ## Sets a color at (x, y) or does nothing if outside of bounds.
  image[x, y] = color.rgbx()

proc fill*(image: Image, color: SomeColor) {.inline, raises: [].} =
  ## Fills the image with the color.
  fillUnsafe(image.data, color, 0, image.data.len)

proc isOneColor*(image: Image): bool {.hasSimd, raises: [].} =
  ## Checks if the entire image is the same color.
  result = true
  let color = cast[uint32](image.data[0])
  for i in 0 ..< image.data.len:
    if cast[uint32](image.data[i]) != color:
      return false

proc isTransparent*(image: Image): bool {.hasSimd, raises: [].} =
  ## Checks if this image is fully transparent or not.
  result = true
  for i in 0 ..< image.data.len:
    if image.data[i].a != 0:
      return false

proc isOpaque*(image: Image): bool {.raises: [].} =
  ## Checks if the entire image is opaque (alpha values are all 255).
  isOpaque(image.data, 0, image.data.len)

proc flipHorizontal*(image: Image) {.raises: [].} =
  ## Flips the image around the Y axis.
  let halfWidth = image.width div 2
  for y in 0 ..< image.height:
    var
      left = image.dataIndex(0, y)
      right = left + image.width - 1
    for x in 0 ..< halfWidth:
      swap(image.data[left], image.data[right])
      inc left
      dec right

proc flipVertical*(image: Image) {.raises: [].} =
  ## Flips the image around the X axis.
  let halfHeight = image.height div 2
  for y in 0 ..< halfHeight:
    let
      topStart = image.dataIndex(0, y)
      bottomStart = image.dataIndex(0, image.height - y - 1)
    for x in 0 ..< image.width:
      swap(image.data[topStart + x], image.data[bottomStart + x])

proc rotate90*(image: Image) {.raises: [PixieError].} =
  ## Rotates the image 90 degrees clockwise.
  let rotated = newImage(image.height, image.width)
  for y in 0 ..< rotated.height:
    for x in 0 ..< rotated.width:
      rotated.data[rotated.dataIndex(x, y)] =
        image.data[image.dataIndex(y, image.height - x - 1)]
  image.width = rotated.width
  image.height = rotated.height
  image.data = move rotated.data

proc subImage*(image: Image, x, y, w, h: int): Image {.raises: [PixieError].} =
  ## Gets a sub image from this image.
  if x < 0 or x + w > image.width:
    raise newException(
      PixieError,
      "Params x: " & $x & " w: " & $w & " invalid, image width is " & $image.width
    )
  if y < 0 or y + h > image.height:
    raise newException(
      PixieError,
      "Params y: " & $y & " h: " & $h & " invalid, image height is " & $image.height
    )

  result = newImage(w, h)
  for y2 in 0 ..< h:
    copyMem(
      result.data[result.dataIndex(0, y2)].addr,
      image.data[image.dataIndex(x, y + y2)].addr,
      w * 4
    )

proc subImage*(image: Image, rect: Rect): Image {.raises: [PixieError].} =
  ## Gets a sub image from this image via rectangle.
  ## Rectangle is snapped/expanded to whole pixels first.
  let r = rect.snapToPixels()
  image.subImage(r.x.int, r.y.int, r.w.int, r.h.int)

proc diff*(master, image: Image): (float32, Image) {.raises: [PixieError].} =
  ## Compares the parameters and returns a score and image of the difference.
  let
    w = max(master.width, image.width)
    h = max(master.height, image.height)
    diffImage = newImage(w, h)

  var
    diffScore = 0
    diffTotal = 0
  for x in 0 ..< w:
    for y in 0 ..< h:
      let
        m = master[x, y]
        u = image[x, y]
        diff = (m.r.int - u.r.int) + (m.g.int - u.g.int) + (m.b.int - u.b.int)
      var c: ColorRGBX
      c.r = abs(m.a.int - u.a.int).clamp(0, 255).uint8
      c.g = diff.clamp(0, 255).uint8
      c.b = (-diff).clamp(0, 255).uint8
      c.a = 255
      diffImage.unsafe[x, y] = c
      diffScore += abs(m.r.int - u.r.int) +
        abs(m.g.int - u.g.int) +
        abs(m.b.int - u.b.int) +
        abs(m.a.int - u.a.int)
      diffTotal += 255 * 4

  (100 * diffScore.float32 / diffTotal.float32, diffImage)

proc minifyBy2*(
  image: Image, power = 1
): Image {.hasSimd, raises: [PixieError].} =
  ## Scales the image down by an integer scale.
  if power < 0:
    raise newException(PixieError, "Cannot minifyBy2 with negative power")
  if power == 0:
    return image.copy()

  var src = image
  for _ in 1 .. power:
    # When minifying an image of odd size, round the result image size up
    # so a 99 x 99 src image returns a 50 x 50 image.
    let
      srcWidthIsOdd = (src.width mod 2) != 0
      srcHeightIsOdd = (src.height mod 2) != 0
      resultEvenWidth = src.width div 2
      resultEvenHeight = src.height div 2
    result = newImage(
      if srcWidthIsOdd: resultEvenWidth + 1 else: resultEvenWidth,
      if srcHeightIsOdd: resultEvenHeight + 1 else: resultEvenHeight
    )
    for y in 0 ..< resultEvenHeight:
      let
        topRowStart = src.dataIndex(0, y * 2)
        bottomRowStart = src.dataIndex(0, y * 2 + 1)
      for x in 0 ..< resultEvenWidth:
        let
          a = src.data[topRowStart + x * 2]
          b = src.data[topRowStart + x * 2 + 1]
          c = src.data[bottomRowStart + x * 2 + 1]
          d = src.data[bottomRowStart + x * 2]
          mixed = rgbx(
            ((a.r.uint32 + b.r + c.r + d.r + 2) div 4).uint8,
            ((a.g.uint32 + b.g + c.g + d.g + 2) div 4).uint8,
            ((a.b.uint32 + b.b + c.b + d.b + 2) div 4).uint8,
            ((a.a.uint32 + b.a + c.a + d.a + 2) div 4).uint8
          )
        result.data[result.dataIndex(x, y)] = mixed

      if srcWidthIsOdd:
        let rgbx = mix(
          src.data[src.dataIndex(src.width - 1, y * 2 + 0)],
          src.data[src.dataIndex(src.width - 1, y * 2 + 1)],
          0.5
        ) * 0.5
        result.data[result.dataIndex(result.width - 1, y)] = rgbx

    if srcHeightIsOdd:
      for x in 0 ..< resultEvenWidth:
        let rgbx = mix(
          src.data[src.dataIndex(x * 2 + 0, src.height - 1)],
          src.data[src.dataIndex(x * 2 + 1, src.height - 1)],
          0.5
        ) * 0.5
        result.data[result.dataIndex(x, result.height - 1)] = rgbx

      if srcWidthIsOdd:
        result.data[result.dataIndex(result.width - 1, result.height - 1)] =
          src.data[src.dataIndex(src.width - 1, src.height - 1)] * 0.25

    # Set src as this result for if we do another power
    src = result

proc magnifyBy2*(
  image: Image, power = 1
): Image {.hasSimd, raises: [PixieError].} =
  ## Scales image up by 2 ^ power.
  if power < 0:
    raise newException(PixieError, "Cannot magnifyBy2 with negative power")

  let scale = 2 ^ power
  result = newImage(image.width * scale, image.height * scale)

  for y in 0 ..< image.height:
    # Write one row of pixels duplicated by scale
    let
      sourceRowStart = image.dataIndex(0, y)
      resultRowStart = result.dataIndex(0, y * scale)
    for x in 0 ..< image.width:
      let
        rgbx = image.data[sourceRowStart + x]
        resultIdx = resultRowStart + x * scale
      for i in 0 ..< scale:
        result.data[resultIdx + i] = rgbx
    # Copy that row of pixels into (scale - 1) more rows
    for i in 1 ..< scale:
      copyMem(
        result.data[resultRowStart + result.width * i].addr,
        result.data[resultRowStart].addr,
        result.width * 4
      )

proc applyOpacity*(image: Image, opacity: float32) {.hasSimd, raises: [].} =
  ## Multiplies alpha of the image by opacity.
  let opacity = round(255 * opacity).uint16
  if opacity == 255:
    return

  if opacity == 0:
    image.fill(rgbx(0, 0, 0, 0))
    return

  for i in 0 ..< image.data.len:
    var rgbx = image.data[i]
    rgbx.r = ((rgbx.r * opacity) div 255).uint8
    rgbx.g = ((rgbx.g * opacity) div 255).uint8
    rgbx.b = ((rgbx.b * opacity) div 255).uint8
    rgbx.a = ((rgbx.a * opacity) div 255).uint8
    image.data[i] = rgbx

proc invert*(image: Image) {.hasSimd, raises: [].} =
  ## Inverts all of the colors and alpha.
  for i in 0 ..< image.data.len:
    var rgbx = image.data[i]
    rgbx.r = 255 - rgbx.r
    rgbx.g = 255 - rgbx.g
    rgbx.b = 255 - rgbx.b
    rgbx.a = 255 - rgbx.a
    image.data[i] = rgbx

  # Inverting rgbx(50, 100, 150, 200) becomes rgbx(205, 155, 105, 55). This
  # is not a valid premultiplied alpha color.
  # We need to convert back to premultiplied alpha after inverting.
  image.data.toPremultipliedAlpha()

proc ceil*(image: Image) {.hasSimd, raises: [].} =
  ## A value of 0 stays 0. Anything else turns into 255.
  for i in 0 ..< image.data.len:
    var rgbx = image.data[i]
    rgbx.r = if rgbx.r == 0: 0 else: 255
    rgbx.g = if rgbx.g == 0: 0 else: 255
    rgbx.b = if rgbx.b == 0: 0 else: 255
    rgbx.a = if rgbx.a == 0: 0 else: 255
    image.data[i] = rgbx

proc blur*(
  image: Image, radius: float32, outOfBounds: SomeColor = color(0, 0, 0, 0)
) {.raises: [PixieError].} =
  ## Applies Gaussian blur to the image given a radius.
  let radius = round(radius).int
  if radius == 0:
    return
  if radius < 0:
    raise newException(PixieError, "Cannot apply negative blur")

  let
    kernel = gaussianKernel(radius)
    outOfBounds = outOfBounds.asRgbx()

  proc `*`(sample: ColorRGBX, a: uint32): array[4, uint32] {.inline.} =
    [
      sample.r * a,
      sample.g * a,
      sample.b * a,
      sample.a * a
    ]

  template `+=`(values: var array[4, uint32], sample: array[4, uint32]) =
    values[0] += sample[0]
    values[1] += sample[1]
    values[2] += sample[2]
    values[3] += sample[3]

  template rgbx(values: array[4, uint32]): ColorRGBX =
    rgbx(
      (values[0] div 256 div 255).uint8,
      (values[1] div 256 div 255).uint8,
      (values[2] div 256 div 255).uint8,
      (values[3] div 256 div 255).uint8
    )

  # Blur in the X direction. Store with dimensions swapped for reading later.
  let blurX = newImage(image.height, image.width)
  for y in 0 ..< image.height:
    for x in 0 ..< image.width:
      var values: array[4, uint32]
      for xx in x - radius ..< min(x + radius, 0):
        values += outOfBounds * kernel[xx - x + radius]
      var idx = image.dataIndex(0, y)
      for xx in max(x - radius, 0) .. min(x + radius, image.width - 1):
        values += image.data[idx + xx] * kernel[xx - x + radius]
      for xx in max(x - radius, image.width) .. x + radius:
        values += outOfBounds * kernel[xx - x + radius]
      blurX.unsafe[y, x] = rgbx(values)

  # Blur in the Y direction.
  for y in 0 ..< image.height:
    for x in 0 ..< image.width:
      var values: array[4, uint32]
      for yy in y - radius ..< min(y + radius, 0):
        values += outOfBounds * kernel[yy - y + radius]
      var idx = blurX.dataIndex(0, x)
      for yy in max(y - radius, 0) .. min(y + radius, image.height - 1):
        values += blurX.data[idx + yy] * kernel[yy - y + radius]
      for yy in max(y - radius, image.height) .. y + radius:
        values += outOfBounds * kernel[yy - y + radius]
      image.unsafe[x, y] = rgbx(values)

proc getRgbaSmooth*(
  image: Image, x, y: float32, wrapped = false
): ColorRGBX {.raises: [].} =
  ## Gets a interpolated color with float point coordinates.
  ## Pixels outside the image are transparent.
  let
    x0 = x.floor.int
    y0 = y.floor.int
    x1 = x0 + 1
    y1 = y0 + 1
    xFractional = x - x.floor
    yFractional = y - y.floor

  var x0y0, x1y0, x0y1, x1y1: ColorRGBX
  if wrapped:
    x0y0 = image.unsafe[x0 mod image.width, y0 mod image.height]
    x1y0 = image.unsafe[x1 mod image.width, y0 mod image.height]
    x0y1 = image.unsafe[x0 mod image.width, y1 mod image.height]
    x1y1 = image.unsafe[x1 mod image.width, y1 mod image.height]
  else:
    x0y0 = image[x0, y0]
    x1y0 = image[x1, y0]
    x0y1 = image[x0, y1]
    x1y1 = image[x1, y1]

  var topMix = x0y0
  if xFractional > 0 and x0y0 != x1y0:
    topMix = mix(x0y0, x1y0, xFractional)

  var bottomMix = x0y1
  if xFractional > 0 and x0y1 != x1y1:
    bottomMix = mix(x0y1, x1y1, xFractional)

  if yFractional != 0 and topMix != bottomMix:
    mix(topMix, bottomMix, yFractional)
  else:
    topMix

proc drawCorrect(
  a, b: Image, transform = mat3(), blendMode: BlendMode, tiled: bool
) =
  ## Draws one image onto another using a matrix transform and color blending.
  ## This proc is not about performance, it should be as simple as possible.
  var
    inverseTransform = transform.inverse()
    # Compute movement vectors
    p = inverseTransform * vec2(0 + h, 0 + h)
    dx = inverseTransform * vec2(1 + h, 0 + h) - p
    dy = inverseTransform * vec2(0 + h, 1 + h) - p
    filterBy2 = max(dx.length, dy.length)
    b = b

  while filterBy2 >= 2.0:
    b = b.minifyBy2()
    p /= 2
    dx /= 2
    dy /= 2
    filterBy2 /= 2
    inverseTransform = scale(vec2(0.5, 0.5)) * inverseTransform

  while filterBy2 <= 0.5:
    b = b.magnifyBy2()
    p *= 2
    dx *= 2
    dy *= 2
    filterBy2 *= 2
    inverseTransform = scale(vec2(2, 2)) * inverseTransform

  let blender = blendMode.blender()
  for y in 0 ..< a.height:
    for x in 0 ..< a.width:
      let
        samplePos = inverseTransform * vec2(x.float32 + h, y.float32 + h)
        xFloat = samplePos.x - h
        yFloat = samplePos.y - h
        backdrop = a.unsafe[x, y]
        sample = b.getRgbaSmooth(xFloat, yFloat, tiled)
        blended = blender(backdrop, sample)
      a.unsafe[x, y] = blended

proc blendLine(
  a, b: ptr UncheckedArray[ColorRGBX], len: int, blender: Blender
) {.inline.} =
  for i in 0 ..< len:
    a[i] = blender(a[i], b[i])

proc blendLineOverwrite(
  a, b: ptr UncheckedArray[ColorRGBX], len: int
) {.inline.} =
  copyMem(a[0].addr, b[0].addr, len * 4)

proc blendLineNormal(
  a, b: ptr UncheckedArray[ColorRGBX], len: int
) {.hasSimd.} =
  for i in 0 ..< len:
    a[i] = blendNormal(a[i], b[i])

proc blendLineMask(a, b: ptr UncheckedArray[ColorRGBX], len: int) {.hasSimd.} =
  for i in 0 ..< len:
    a[i] = blendMask(a[i], b[i])

proc blendRect(a, b: Image, pos: Ivec2, blendMode: BlendMode) =
  let
    px = pos.x.int
    py = pos.y.int

  if px >= a.width or px + b.width <= 0 or py >= a.height or py + b.height <= 0:
    if blendMode == MaskBlend:
      a.fill(rgbx(0, 0, 0, 0))
    return

  let
    xStart = max(-px, 0)
    yStart = max(-py, 0)
    xEnd = min(b.width, a.width - px)
    yEnd = min(b.height, a.height - py)

  case blendMode:
  of NormalBlend:
    for y in yStart ..< yEnd:
      blendLineNormal(
        a.getUncheckedArray(xStart + px, y + py),
        b.getUncheckedArray(xStart, y),
        xEnd - xStart
      )
  of OverwriteBlend:
    for y in yStart ..< yEnd:
      blendLineOverwrite(
        a.getUncheckedArray(xStart + px, y + py),
        b.getUncheckedArray(xStart, y),
        xEnd - xStart
      )
  of MaskBlend:
    {.linearScanEnd.}
    if yStart + py > 0:
      zeroMem(a.data[0].addr, (yStart + py) * a.width * 4)
    for y in yStart ..< yEnd:
      if xStart + px > 0:
        zeroMem(a.data[a.dataIndex(0, y + py)].addr, (xStart + px) * 4)
      blendLineMask(
        a.getUncheckedArray(xStart + px, y + py),
        b.getUncheckedArray(xStart, y),
        xEnd - xStart
      )
      if xEnd + px < a.width:
        zeroMem(
          a.data[a.dataIndex(xEnd + px, y + py)].addr,
          (a.width - (xEnd + px)) * 4
        )
    if yEnd + py < a.height:
      zeroMem(
        a.data[a.dataIndex(0, yEnd + py)].addr,
        (a.height - (yEnd + py)) * a.width * 4
      )
  else:
    let blender = blendMode.blender()
    for y in yStart ..< yEnd:
      blendLine(
        a.getUncheckedArray(xStart + px, y + py),
        b.getUncheckedArray(xStart, y),
        xEnd - xStart,
        blender
      )

proc drawSmooth(a, b: Image, transform: Mat3, blendMode: BlendMode) =
  let
    corners = [
      transform * vec2(0, 0),
      transform * vec2(b.width.float32, 0),
      transform * vec2(b.width.float32, b.height.float32),
      transform * vec2(0, b.height.float32)
    ]
    perimeter = [
      segment(corners[0], corners[1]),
      segment(corners[1], corners[2]),
      segment(corners[2], corners[3]),
      segment(corners[3], corners[0])
    ]
    inverseTransform = transform.inverse()
    # Compute movement vectors
    p = inverseTransform * vec2(0 + h, 0 + h)
    dx = inverseTransform * vec2(1 + h, 0 + h) - p
    dy = inverseTransform * vec2(0 + h, 1 + h) - p

  # Determine where we should start and stop drawing in the y dimension
  var
    yStart = a.height
    yEnd = 0
  for segment in perimeter:
    yStart = min(yStart, segment.at.y.floor.int)
    yEnd = max(yEnd, segment.at.y.ceil.int)
  yStart = yStart.clamp(0, a.height)
  yEnd = yEnd.clamp(0, a.height)

  if blendMode == MaskBlend and yStart > 0:
    zeroMem(a.data[0].addr, yStart * a.width * 4)

  var sampleLine = newSeq[ColorRGBX](a.width)
  for y in yStart ..< yEnd:
    # Determine where we should start and stop drawing in the x dimension
    var
      xMin = a.width.float32
      xMax = 0.float32
    for yOffset in [0.float32, 1]:
      let scanLine = Line(
        a: vec2(-1000, y.float32 + yOffset),
        b: vec2(1000, y.float32 + yOffset)
      )
      for segment in perimeter:
        var at: Vec2
        if scanline.intersects(segment, at) and segment.to != at:
          xMin = min(xMin, at.x)
          xMax = max(xMax, at.x)

    let
      xStart = clamp(xMin.floor.int, 0, a.width)
      xEnd = clamp(xMax.ceil.int, 0, a.width)

    if xEnd - xStart == 0:
      continue

    var srcPos = p + dx * xStart.float32 + dy * y.float32
    srcPos = vec2(srcPos.x - h, srcPos.y - h)
    for x in xStart ..< xEnd:
      sampleLine[x] = b.getRgbaSmooth(srcPos.x, srcPos.y)
      srcPos += dx

    case blendMode:
    of NormalBlend:
      blendLineNormal(
        a.getUncheckedArray(xStart, y),
        cast[ptr UncheckedArray[ColorRGBX]](sampleLine[xStart].addr),
        xEnd - xStart
      )

    of OverwriteBlend:
      blendLineOverwrite(
        a.getUncheckedArray(xStart, y),
        cast[ptr UncheckedArray[ColorRGBX]](sampleLine[xStart].addr),
        xEnd - xStart
      )

    of MaskBlend:
      {.linearScanEnd.}
      if blendMode == MaskBlend and xStart > 0:
        zeroMem(a.data[a.dataIndex(0, y)].addr, xStart * 4)

      blendLineMask(
        a.getUncheckedArray(xStart, y),
        cast[ptr UncheckedArray[ColorRGBX]](sampleLine[xStart].addr),
        xEnd - xStart
      )

      if blendMode == MaskBlend and a.width - xEnd > 0:
        zeroMem(a.data[a.dataIndex(xEnd, y)].addr, (a.width - xEnd) * 4)
    else:
      blendLine(
        a.getUncheckedArray(xStart, y),
        cast[ptr UncheckedArray[ColorRGBX]](sampleLine[xStart].addr),
        xEnd - xStart,
        blendMode.blender()
      )

  if blendMode == MaskBlend and a.height - yEnd > 0:
    zeroMem(
      a.data[a.dataIndex(0, yEnd)].addr,
      a.width * (a.height - yEnd) * 4
    )

proc draw*(
  a, b: Image, transform = mat3(), blendMode = NormalBlend
) {.raises: [PixieError].} =
  ## Draws one image onto another using a matrix transform and color blending.
  var
    transform = transform
    inverseTransform = transform.inverse()
    # Compute movement vectors
    p = inverseTransform * vec2(0 + h, 0 + h)
    dx = inverseTransform * vec2(1 + h, 0 + h) - p
    dy = inverseTransform * vec2(0 + h, 1 + h) - p
    filterBy2 = max(dx.length, dy.length)
    b = b

  while filterBy2 >= 2.0:
    b = b.minifyBy2()
    p /= 2
    dx /= 2
    dy /= 2
    filterBy2 /= 2
    transform = transform * scale(vec2(2, 2))

  while filterBy2 <= 0.5:
    b = b.magnifyBy2()
    p *= 2
    dx *= 2
    dy *= 2
    filterBy2 *= 2
    transform = transform * scale(vec2(1/2, 1/2))

  let
    hasRotationOrScaling = not(dx == vec2(1, 0) and dy == vec2(0, 1))
    smooth = not(
      dx.length == 1.0 and
      dy.length == 1.0 and
      transform[2, 0].fractional == 0.0 and
      transform[2, 1].fractional == 0.0
    )

  if hasRotationOrScaling or smooth:
    a.drawSmooth(b, transform, blendMode)
  else:
    a.blendRect(b, ivec2(transform[2, 0].int32, transform[2, 1].int32), blendMode)

proc drawTiled*(
  dst, src: Image, mat: Mat3, blendMode = NormalBlend
) {.raises: [PixieError].} =
  dst.drawCorrect(src, mat, blendMode, true)

proc resize*(srcImage: Image, width, height: int): Image {.raises: [PixieError].} =
  ## Resize an image to a given height and width.
  if width == srcImage.width and height == srcImage.height:
    result = srcImage.copy()
  else:
    result = newImage(width, height)
    result.draw(
      srcImage,
      scale(vec2(
        width.float32 / srcImage.width.float32,
        height.float32 / srcImage.height.float32
      )),
      OverwriteBlend
    )

proc spread(image: Image, spread: float32) {.raises: [PixieError].} =
  ## Grows the mask by spread.
  let spread = round(spread).int
  if spread == 0:
    return

  if spread > 0:
    # Spread in the X direction. Store with dimensions swapped for reading later.
    let spreadX = newImage(image.height, image.width)
    for y in 0 ..< image.height:
      for x in 0 ..< image.width:
        var maxValue: uint8
        for xx in max(x - spread, 0) .. min(x + spread, image.width - 1):
          let value = image.unsafe[xx, y].a
          if value > maxValue:
            maxValue = value
          if maxValue == 255:
            break
        spreadX.unsafe[y, x].a = maxValue

    # Spread in the Y direction and modify mask.
    for y in 0 ..< image.height:
      for x in 0 ..< image.width:
        var maxValue: uint8
        for yy in max(y - spread, 0) .. min(y + spread, image.height - 1):
          let value = spreadX.unsafe[yy, x].a
          if value > maxValue:
            maxValue = value
          if maxValue == 255:
            break
        image.unsafe[x, y] = rgbx(0, 0, 0, maxValue)

  elif spread < 0:
    let spread = -spread

    # Spread in the X direction. Store with dimensions swapped for reading later.
    let spreadX = newImage(image.height, image.width)
    for y in 0 ..< image.height:
      for x in 0 ..< image.width:
        var minValue: uint8 = 255
        for xx in max(x - spread, 0) .. min(x + spread, image.width - 1):
          let value = image.unsafe[xx, y].a
          if value < minValue:
            minValue = value
          if minValue == 0:
            break
        spreadX.unsafe[y, x] = rgbx(0, 0, 0, minValue)

    # Spread in the Y direction and modify mask.
    for y in 0 ..< image.height:
      for x in 0 ..< image.width:
        var minValue: uint8 = 255
        for yy in max(y - spread, 0) .. min(y + spread, image.height - 1):
          let value = spreadX.unsafe[yy, x].a
          if value < minValue:
            minValue = value
          if minValue == 0:
            break
        image.unsafe[x, y] = rgbx(0, 0, 0, minValue)

proc shadow*(
  image: Image, offset: Vec2, spread, blur: float32, color: SomeColor
): Image {.raises: [PixieError].} =
  ## Create a shadow of the image with the offset, spread and blur.
  var mask: Image
  if offset == vec2(0, 0):
    mask = image.copy()
  else:
    mask = newImage(image.width, image.height)
    mask.draw(image, translate(offset), OverwriteBlend)

  mask.spread(spread)
  mask.blur(blur)

  result = newImage(mask.width, mask.height)
  result.fill(color)
  result.draw(mask, blendMode = MaskBlend)

proc superImage*(image: Image, x, y, w, h: int): Image {.raises: [PixieError].} =
  ## Either cuts a sub image or returns a super image with padded transparency.
  if x >= 0 and x + w <= image.width and y >= 0 and y + h <= image.height:
    result = image.subImage(x, y, w, h)
  elif abs(x) >= image.width or abs(y) >= image.height:
    # Nothing to copy, just an empty new image
    result = newImage(w, h)
  else:
    result = newImage(w, h)
    result.draw(image, translate(vec2(-x.float32, -y.float32)), OverwriteBlend)

proc opaqueBounds*(image: Image): Rect =
  ## Returns the bounds of opaque pixels.
  ## Some images have transparency around them, use this to find just the
  ## visible part of the image and then use subImage to cut it out.
  ## Returns zero rect if whole image is transparent.
  ## Returns just the size of the image if no edge is transparent.
  var
    xMin = image.width
    xMax = 0
    yMin = image.height
    yMax = 0
  # Find the trim coordinates.
  for y in 0 ..< image.height:
    for x in 0 ..< image.width:
      if image.unsafe[x, y].a != 0:
        xMin = min(xMin, x)
        xMax = max(xMax, x + 1)
        yMin = min(yMin, y)
        yMax = max(yMax, y + 1)
  if xMax <= xMin or yMax <= yMin:
    return rect(0, 0, 0, 0)
  rect(
    xMin.float32,
    yMin.float32,
    (xMax - xMin).float32,
    (yMax - yMin).float32
  )

when defined(release):
  {.pop.}



================================================
FILE: src/pixie/internal.nim
================================================
import bumpy, chroma, common, simd, system/memory, vmath

template currentExceptionAsPixieError*(): untyped =
  ## Gets the current exception and returns it as a PixieError with stack trace.
  let e = getCurrentException()
  newException(PixieError, e.getStackTrace & e.msg, e)

template failUnsupportedBlendMode*(blendMode: BlendMode) =
  raise newException(
    PixieError,
    "Blend mode " & $blendMode & " not supported here"
  )

when defined(release):
  {.push checks: off.}

proc gaussianKernel*(radius: int): seq[uint16] {.raises: [].} =
  ## Compute lookup table for 1d Gaussian kernel.
  ## Values are [0, 255] * 256.
  result.setLen(radius * 2 + 1)

  var
    floats = newSeq[float32](result.len)
    total = 0.0
  for step in -radius .. radius:
    let
      s = radius.float32 / 2.2 # 2.2 matches Figma.
      a = 1 / sqrt(2 * PI * s^2) * exp(-1 * step.float32^2 / (2 * s^2))
    floats[step + radius] = a
    total += a
  for step in -radius .. radius:
    floats[step + radius] = floats[step + radius] / total
  for i, f in floats:
    result[i] = round(f * 255 * 256).uint16

proc intersectsInside*(a, b: Segment, at: var Vec2): bool {.inline.} =
  ## Checks if the a segment intersects b segment (excluding endpoints).
  ## If it returns true, at will have point of intersection
  let
    s1 = a.to - a.at
    s2 = b.to - b.at
    denominator = (-s2.x * s1.y + s1.x * s2.y)
    s = (-s1.y * (a.at.x - b.at.x) + s1.x * (a.at.y - b.at.y)) / denominator
    t = (s2.x * (a.at.y - b.at.y) - s2.y * (a.at.x - b.at.x)) / denominator

  if s > 0 and s < 1 and t > 0 and t < 1:
    at = a.at + (t * s1)
    return true

template getUncheckedArray*(
  image: Image, x, y: int
): ptr UncheckedArray[ColorRGBX] =
  cast[ptr UncheckedArray[ColorRGBX]](image.data[image.dataIndex(x, y)].addr)

proc fillUnsafe*(
  data: var seq[ColorRGBX], color: SomeColor, start, len: int
) {.hasSimd, raises: [].} =
  ## Fills the image data with the color starting at index start and
  ## continuing for len indices.
  let rgbx = color.asRgbx()
  # Use memset when every byte has the same value
  if rgbx.r == rgbx.g and rgbx.r == rgbx.b and rgbx.r == rgbx.a:
    nimSetMem(data[start].addr, rgbx.r.cint, len * 4)
  else:
    for i in start ..< start + len:
      data[i] = rgbx

const straightAlphaTable = block:
  var table: array[256, array[256, uint8]]
  for a in 0 ..< 256:
    let multiplier = if a > 0: (255 / a.float32) else: 0
    for c in 0 ..< 256:
      table[a][c] = min(round((c.float32 * multiplier)), 255).uint8
  table

proc toStraightAlpha*(data: var seq[ColorRGBA | ColorRGBX]) {.raises: [].} =
  ## Converts an image from premultiplied alpha to straight alpha.
  ## This is expensive for large images.
  for i in 0 ..< data.len:
    var c = data[i]
    c.r = straightAlphaTable[c.a][c.r]
    c.g = straightAlphaTable[c.a][c.g]
    c.b = straightAlphaTable[c.a][c.b]
    data[i] = c

proc toPremultipliedAlpha*(
  data: var seq[ColorRGBA | ColorRGBX]
) {.hasSimd, raises: [].} =
  ## Converts an image to premultiplied alpha from straight alpha.
  for i in 0 ..< data.len:
    var c = data[i]
    if c.a != 255:
      c.r = ((c.r.uint32 * c.a + 127) div 255).uint8
      c.g = ((c.g.uint32 * c.a + 127) div 255).uint8
      c.b = ((c.b.uint32 * c.a + 127) div 255).uint8
      data[i] = c

proc isOpaque*(data: var seq[ColorRGBX], start, len: int): bool {.hasSimd.} =
  result = true
  for i in start ..< start + len:
    if data[i].a != 255:
      return false

when defined(release):
  {.pop.}



================================================
FILE: src/pixie/paints.nim
================================================
import chroma, common, images, simd, vmath

type
  PaintKind* = enum
    SolidPaint
    ImagePaint
    TiledImagePaint
    LinearGradientPaint
    RadialGradientPaint
    AngularGradientPaint

  Paint* = ref object
    ## Paint used to fill paths.
    kind*: PaintKind
    blendMode*: BlendMode               ## Blend mode.
    opacity*: float32
    # SolidPaint
    color*: Color                       ## Color to fill with.
    # ImagePaint, TiledImagePaint:
    image*: Image                       ## Image to fill with.
    imageMat*: Mat3                     ## Matrix of the filled image.
    # LinearGradientPaint, RadialGradientPaint, AngularGradientPaint:
    gradientHandlePositions*: seq[Vec2] ## Gradient positions (image space).
    gradientStops*: seq[ColorStop]      ## Color stops (gradient space).

  ColorStop* = object
    ## Color stop on a gradient curve.
    color*: Color      ## Color of the stop.
    position*: float32 ## Gradient stop position 0..1.

  SomePaint* = string | Paint | SomeColor

proc newPaint*(kind: PaintKind): Paint {.raises: [].} =
  ## Create a new Paint.
  result = Paint(kind: kind, opacity: 1, imageMat: mat3())

proc copy*(paint: Paint): Paint {.raises: [].} =
  ## Create a new Paint with the same properties.
  result = newPaint(paint.kind)
  result.blendMode = paint.blendMode
  result.opacity = paint.opacity
  result.color = paint.color
  result.image = paint.image
  result.imageMat = paint.imageMat
  result.gradientHandlePositions = paint.gradientHandlePositions
  result.gradientStops = paint.gradientStops

converter parseSomePaint*(paint: SomePaint): Paint {.inline.} =
  ## Given SomePaint, parse it in different ways.
  when type(paint) is string:
    result = newPaint(SolidPaint)
    try:
      result.color = parseHtmlColor(paint)
    except:
      raise newException(PixieError, "Unable to parse color " & paint)
  elif type(paint) is SomeColor:
    result = newPaint(SolidPaint)
    when type(paint) is Color:
      result.color = paint
    else:
      result.color = paint.color()
  elif type(paint) is Paint:
    paint

proc colorStop*(color: Color, position: float32): ColorStop =
  ColorStop(color: color, position: position)

proc gradientColor(paint: Paint, t: float32): ColorRGBX =
  ## Get the gradient color based on `t` - where are we related to a line.
  var index = -1
  for i, stop in paint.gradientStops:
    if stop.position < t:
      index = i
    if stop.position > t:
      break
  var color: Color
  if index == -1:
    # first stop solid
    color = paint.gradientStops[0].color
  elif index + 1 >= paint.gradientStops.len:
    # last stop solid
    color = paint.gradientStops[index].color
  else:
    let
      gs1 = paint.gradientStops[index]
      gs2 = paint.gradientStops[index + 1]
    color = mix(
      gs1.color,
      gs2.color,
      (t - gs1.position) / (gs2.position - gs1.position)
    )
  color.a *= paint.opacity
  color.rgbx()

proc fillGradientLinear(image: Image, paint: Paint) =
  ## Fills a linear gradient.

  if paint.gradientHandlePositions.len != 2:
    raise newException(PixieError, "Linear gradient requires 2 handles")

  if paint.gradientStops.len == 0:
    raise newException(PixieError, "Gradient must have at least 1 color stop")

  paint.opacity = clamp(paint.opacity, 0, 1)
  if paint.opacity == 0:
    return

  proc toLineSpace(at, to, point: Vec2): float32 {.inline.} =
    ## Convert position on to where it would fall on a line between at and to.
    let
      d = to - at
      det = d.x * d.x + d.y * d.y
    (d.y * (point.y - at.y) + d.x * (point.x - at.x)) / det

  let
    at = paint.gradientHandlePositions[0]
    to = paint.gradientHandlePositions[1]

  if at.y == to.y: # Horizontal gradient
    var x: int
    while x < image.width:
      when allowSimd and (defined(amd64) or defined(arm64)):
        if x + 4 <= image.width:
          var colors: array[4, ColorRGBX]
          for i in 0 ..< 4:
            let
              xy = vec2((x + i).float32, 0.float32)
              t = toLineSpace(at, to, xy)
              rgbx = paint.gradientColor(t)
            colors[i] = rgbx
          when defined(amd64):
            let colorVec = mm_loadu_si128(colors[0].addr)
            for y in 0 ..< image.height:
              mm_storeu_si128(image.data[image.dataIndex(x, y)].addr, colorVec)
          else: # arm64
            let colorVec = vld1q_u32(colors[0].addr)
            for y in 0 ..< image.height:
              vst1q_u32(image.data[image.dataIndex(x, y)].addr, colorVec)
          x += 4
          continue

      let
        xy = vec2(x.float32, 0.float32)
        t = toLineSpace(at, to, xy)
        rgbx = paint.gradientColor(t)
      for y in 0 ..< image.height:
        image.unsafe[x, y] = rgbx
      inc x

  elif at.x == to.x: # Vertical gradient
    for y in 0 ..< image.height:
      let
        xy = vec2(0.float32, y.float32)
        t = toLineSpace(at, to, xy)
        rgbx = paint.gradientColor(t)
      var x: int
      when allowSimd:
        when defined(amd64):
          let colorVec = mm_set1_epi32(cast[int32](rgbx))
          for _ in 0 ..< image.width div 4:
            mm_storeu_si128(image.data[image.dataIndex(x, y)].addr, colorVec)
            x += 4
        elif defined(arm64):
          let colorVec = vmovq_n_u32(cast[uint32](rgbx))
          for _ in 0 ..< image.width div 4:
            vst1q_u32(image.data[image.dataIndex(x, y)].addr, colorVec)
            x += 4
      for x in x ..< image.width:
        image.unsafe[x, y] = rgbx

  else:
    for y in 0 ..< image.height:
      for x in 0 ..< image.width:
        let
          xy = vec2(x.float32, y.float32)
          t = toLineSpace(at, to, xy)
        image.unsafe[x, y] = paint.gradientColor(t)

proc fillGradientRadial(image: Image, paint: Paint) =
  ## Fills a radial gradient.

  if paint.gradientHandlePositions.len != 3:
    raise newException(PixieError, "Radial gradient requires 3 handles")

  if paint.gradientStops.len == 0:
    raise newException(PixieError, "Gradient must have at least 1 color stop")

  paint.opacity = clamp(paint.opacity, 0, 1)
  if paint.opacity == 0:
    return

  let
    center = paint.gradientHandlePositions[0]
    edge = paint.gradientHandlePositions[1]
    skew = paint.gradientHandlePositions[2]
    distanceX = dist(center, edge)
    distanceY = dist(center, skew)
    gradientAngle = normalize(center - edge).angle().fixAngle()
    mat = (
      translate(center) *
      rotate(-gradientAngle) *
      scale(vec2(distanceX, distanceY))
    ).inverse()
  for y in 0 ..< image.height:
    for x in 0 ..< image.width:
      let
        xy = vec2(x.float32, y.float32)
        t = (mat * xy).length()
      image.unsafe[x, y] = paint.gradientColor(t)

proc fillGradientAngular(image: Image, paint: Paint) =
  ## Fills an angular gradient.

  if paint.gradientHandlePositions.len != 3:
    raise newException(PixieError, "Angular gradient requires 2 handles")

  if paint.gradientStops.len == 0:
    raise newException(PixieError, "Gradient must have at least 1 color stop")

  paint.opacity = clamp(paint.opacity, 0, 1)
  if paint.opacity == 0:
    return

  let
    center = paint.gradientHandlePositions[0]
    edge = paint.gradientHandlePositions[1]
    f32PI = PI.float32
  # TODO: make edge between start and end anti-aliased.
  let gradientAngle = normalize(edge - center).angle().fixAngle()
  for y in 0 ..< image.height:
    for x in 0 ..< image.width:
      let
        xy = vec2(x.float32, y.float32)
        angle = normalize(xy - center).angle()
        t = (angle + gradientAngle + f32PI / 2).fixAngle() / 2 / f32PI + 0.5.float32
      image.unsafe[x, y] = paint.gradientColor(t)

proc fillGradient*(image: Image, paint: Paint) {.raises: [PixieError].} =
  ## Fills with the Paint gradient.
  case paint.kind:
  of LinearGradientPaint:
    image.fillGradientLinear(paint)
  of RadialGradientPaint:
    image.fillGradientRadial(paint)
  of AngularGradientPaint:
    image.fillGradientAngular(paint)
  else:
    raise newException(PixieError, "Paint must be a gradient")



================================================
FILE: src/pixie/simd.nim
================================================
import nimsimd/hassimd

export hassimd

const allowSimd* = not defined(pixieNoSimd) and not defined(tcc)

when allowSimd:
  when defined(amd64):
    import simd/sse2
    export sse2

    when not defined(pixieNoAvx):
      import nimsimd/runtimecheck, simd/avx, simd/avx2
      export avx, avx2

      let
        cpuHasAvx* = checkInstructionSets({AVX})
        cpuHasAvx2* = checkInstructionSets({AVX, AVX2})

    import nimsimd/sse2 as nimsimdsse2
    export nimsimdsse2

  elif defined(arm64):
    import simd/neon
    export neon

    import nimsimd/neon as nimsimdneon
    export nimsimdneon



================================================
FILE: src/pixie/fileformats/bmp.nim
================================================
import bitops, chroma, flatty/binny, ../common, ../images

# See: https://en.wikipedia.org/wiki/BMP_file_format
# See: https://bmptestsuite.sourceforge.io/
# https://docs.microsoft.com/en-us/windows/win32/gdi/bitmap-header-types
# https://stackoverflow.com/questions/61788908/windows-clipboard-getclipboarddata-for-cf-dibv5-causes-the-image-on-the-clip
# https://stackoverflow.com/questions/44177115/copying-from-and-to-clipboard-loses-image-transparency/46424800#46424800

const
  bmpSignature* = "BM"
  LCS_sRGB = 0x73524742

template failInvalid() =
  raise newException(PixieError, "Invalid BMP buffer, unable to load")

proc colorMaskShift(color, mask: uint32): uint8 {.inline.} =
  ((color and mask) shr (mask.firstSetBit() - 1)).uint8

proc decodeDib*(
  data: pointer, len: int, lpBitmapInfo = false
): Image {.raises: [PixieError].} =
  ## Decodes DIB data into an image.
  if len < 40:
    failInvalid()

  let data = cast[ptr UncheckedArray[uint8]](data)

  # BITMAPINFOHEADER
  var
    headerSize = data.readInt32(0).int
    width = data.readInt32(4).int
    height = data.readInt32(8).int
    planes = data.readUint16(12).int
    bits = data.readUint16(14).int
    compression = data.readInt32(16).int
    colorPaletteSize = data.readInt32(32).int

  if headerSize notin [40, 108, 124]:
    failInvalid()

  if planes != 1:
    failInvalid()

  if bits notin [1, 4, 8, 24, 32]:
    raise newException(PixieError, "Unsupported BMP bit count")

  if compression notin [0, 3]:
    raise newException(PixieError, "Unsupported BMP compression format")

  var
    redMask = 0x00FF0000.uint32
    greenMask = 0x0000FF00.uint32
    blueMask = 0x000000FF.uint32
    alphaMask = 0xFF000000.uint32
    flipVertical: bool
    useAlpha: bool

  if compression == 3:
    if len < 52:
      failInvalid()

    redMask = data.readUInt32(40)
    greenMask = data.readUInt32(44)
    blueMask = data.readUInt32(48)

    if redMask == 0 or blueMask == 0 or greenMask == 0:
      failInvalid()

  if headerSize > 40:
    if len < 56:
      failInvalid()

    alphaMask = data.readUInt32(52)

    useAlpha = alphaMask != 0

  if colorPaletteSize < 0 or colorPaletteSize > 256:
    failInvalid()

  if bits == 8 and colorPaletteSize == 0:
    colorPaletteSize = 256

  var colorPalette = newSeq[ColorRGBA](colorPaletteSize)
  if colorPaletteSize > 0:
    if len < headerSize + colorPaletteSize * 4:
      failInvalid()

    var offset = headerSize
    for i in 0 ..< colorPaletteSize:
      var rgba: ColorRGBA
      if offset + 3 > len - 2:
        failInvalid()
      rgba.r = data[offset + 2]
      rgba.g = data[offset + 1]
      rgba.b = data[offset + 0]
      rgba.a = 255
      offset += 4
      colorPalette[i] = rgba

  if height < 0:
    height = -height
    flipVertical = true

  result = newImage(width, height)

  var startOffset = headerSize + colorPaletteSize * 4
  if compression == 3 and (headerSize == 40 or lpBitmapInfo):
    startOffset += 12

  var offset = startOffset

  if bits == 1:
    var
      haveBits = 0
      colorBits: uint8 = 0
    for y in 0 ..< result.height:
      haveBits = 0
      let padding = (offset - startOffset) mod 4
      if padding > 0:
        offset += 4 - padding
      for x in 0 ..< result.width:
        var rgba: ColorRGBA
        if haveBits == 0:
          if offset >= len:
            failInvalid()
          colorBits = data[offset]
          haveBits = 8
          offset += 1
        if (colorBits and 0b1000_0000) == 0:
          rgba = colorPalette[0]
        else:
          rgba = colorPalette[1]
        colorBits = colorBits shl 1
        dec haveBits
        result.unsafe[x, result.height - y - 1] = rgba.rgbx()

  elif bits == 4:
    var
      haveBits = 0
      colorBits: uint8 = 0
    for y in 0 ..< result.height:
      haveBits = 0
      let padding = (offset - startOffset) mod 4
      if padding > 0:
        offset += 4 - padding
      for x in 0 ..< result.width:
        var rgba: ColorRGBA
        if haveBits == 0:
          if offset >= len:
            failInvalid()
          colorBits = data[offset]
          haveBits = 8
          offset += 1
        let index = (colorBits and 0b1111_0000) shr 4
        if index.int >= colorPaletteSize:
          failInvalid()
        rgba = colorPalette[index]
        colorBits = colorBits shl 4
        haveBits -= 4
        result.unsafe[x, result.height - y - 1] = rgba.rgbx()

  elif bits == 8:
    for y in 0 ..< result.height:
      let padding = (offset - startOffset) mod 4
      if padding > 0:
        offset += 4 - padding
      for x in 0 ..< result.width:
        if offset >= len:
          failInvalid()
        var rgba: ColorRGBA
        let index = data[offset]
        offset += 1
        if index.int >= colorPaletteSize:
          failInvalid()
        rgba = colorPalette[index]
        result.unsafe[x, result.height - y - 1] = rgba.rgbx()

  elif bits == 24:
    for y in 0 ..< result.height:
      let padding = (offset - startOffset) mod 4
      if padding > 0:
        offset += 4 - padding
      for x in 0 ..< result.width:
        if offset + 2 >= len:
          failInvalid()
        var rgba: ColorRGBA
        rgba.r = data[offset + 2]
        rgba.g = data[offset + 1]
        rgba.b = data[offset + 0]
        rgba.a = 255
        offset += 3
        result.unsafe[x, result.height - y - 1] = rgba.rgbx()

  elif bits == 32:
    for y in 0 ..< result.height:
      for x in 0 ..< result.width:
        if offset + 3 >= len:
          failInvalid()
        let color = data.readUint32(offset)
        if useAlpha:
          var rgbx: ColorRGBX
          rgbx.r = color.colorMaskShift(redMask)
          rgbx.g = color.colorMaskShift(greenMask)
          rgbx.b = color.colorMaskShift(blueMask)
          rgbx.a = color.colorMaskShift(alphaMask)
          result.unsafe[x, result.height - y - 1] = rgbx
        else:
          var rgba: ColorRGBA
          rgba.r = color.colorMaskShift(redMask)
          rgba.g = color.colorMaskShift(greenMask)
          rgba.b = color.colorMaskShift(blueMask)
          rgba.a = 255
          result.unsafe[x, result.height - y - 1] = rgba.rgbx()
        offset += 4

  if flipVertical:
    result.flipVertical()

proc decodeBmp*(data: string): Image {.raises: [PixieError].} =
  ## Decodes bitmap data into an image.
  if data.len < 14:
    failInvalid()

  # BMP Header
  if data[0 .. 1] != "BM":
    failInvalid()

  decodeDib(data[14].unsafeAddr, data.len - 14)

proc decodeBmpDimensions*(
  data: pointer, len: int
): ImageDimensions {.raises: [PixieError].} =
  ## Decodes the BMP dimensions.
  if len < 26:
    failInvalid()

  let data = cast[ptr UncheckedArray[uint8]](data)

  # BMP Header
  if data[0].char != 'B' or data[1].char != 'M': # Must start with BM
    failInvalid()

  result.width = data.readInt32(18).int
  result.height = abs(data.readInt32(22)).int

proc decodeBmpDimensions*(
  data: string
): ImageDimensions {.raises: [PixieError].} =
  ## Decodes the BMP dimensions.
  decodeBmpDimensions(data.cstring, data.len)

proc encodeDib*(image: Image): string {.raises: [].} =
  ## Encodes an image into a DIB.

  # BITMAPINFO containing BITMAPV5HEADER
  result.addUint32(124) # Size of this header
  result.addInt32(image.width.int32) # Signed integer
  result.addInt32(image.height.int32) # Signed integer
  result.addUint16(1) # Must be 1 (color planes)
  result.addUint16(32) # Bits per pixels, only support RGBA
  result.addUint32(3) # BI_BITFIELDS, no pixel array compression used
  result.addUint32(32) # Size of the raw bitmap data (including padding)
  result.addUint32(2835) # Print resolution of the image
  result.addUint32(2835) # Print resolution of the image
  result.addUint32(0) # Number of colors in the palette
  result.addUint32(0) # 0 means all colors are important
  result.addUint32(uint32(0x000000FF)) # Red channel
  result.addUint32(uint32(0x0000FF00)) # Green channel
  result.addUint32(uint32(0x00FF0000)) # Blue channel
  result.addUint32(uint32(0xFF000000)) # Alpha channel
  result.addUint32(LCS_sRGB) # Color space
  result.setLen(result.len + 64) # Unused
  result.addUint32(0) # BITMAPINFO bmiColors 0
  result.addUint32(0) # BITMAPINFO bmiColors 1
  result.addUint32(0) # BITMAPINFO bmiColors 2

  for y in 0 ..< image.height:
    for x in 0 ..< image.width:
      let rgba = image[x, image.height - y - 1].rgba()
      result.addUint32(cast[uint32](rgba))

proc encodeBmp*(image: Image): string {.raises: [].} =
  ## Encodes an image into the BMP file format.

  # BMP Header
  result.add("BM") # The header field used to identify the BMP
  result.addUint32(0) # The size of the BMP file in bytes
  result.addUint16(0) # Reserved
  result.addUint16(0) # Reserved
  result.addUint32(14 + 12 + 124) # The offset to the pixel array

  # DIB
  result.add(encodeDib(image))

  result.writeUint32(2, result.len.uint32)



================================================
FILE: src/pixie/fileformats/gif.nim
================================================
import chroma, flatty/binny, ../common, ../images, std/math, std/strutils,
    vmath, zippy/bitstreams

# See: https://www.w3.org/Graphics/GIF/spec-gif89a.txt

const gifSignatures* = @["GIF87a", "GIF89a"]

type
  Gif* = ref object
    frames*: seq[Image]
    intervals*: seq[float32] # Floating point seconds
    duration*: float32

  ControlExtension = object
    fields: uint8
    delayTime: uint16
    transparentColorIndex: uint8

template failInvalid() =
  raise newException(PixieError, "Invalid GIF buffer, unable to load")

when defined(release):
  {.push checks: off.}

proc decodeGif*(data: string): Gif {.raises: [PixieError].} =
  ## Decodes GIF data.
  if data.len < 13:
    failInvalid()

  if data[0 .. 5] notin gifSignatures:
    raise newException(PixieError, "Invalid GIF file signature")

  result = Gif()

  let
    screenWidth = data.readInt16(6).int
    screenHeight = data.readInt16(8).int
    globalFlags = data.readUint8(10).int
    hasGlobalColorTable = (globalFlags and 0b10000000) != 0
    globalColorTableSize = 2 ^ ((globalFlags and 0b00000111) + 1)
    bgColorIndex = data.readUint8(11).int
    pixelAspectRatio = data.readUint8(12)

  if bgColorIndex > globalColorTableSize:
    failInvalid()

  if pixelAspectRatio != 0:
    raise newException(PixieError, "Unsupported GIF, pixel aspect ratio")

  var pos = 13

  if pos + globalColorTableSize * 3 > data.len:
    failInvalid()

  var
    globalColorTable: seq[ColorRGBX]
    bgColor: ColorRGBX
  if hasGlobalColorTable:
    globalColorTable.setLen(globalColorTableSize)
    for i in 0 ..< globalColorTable.len:
      globalColorTable[i] = rgbx(
        data.readUint8(pos + 0),
        data.readUint8(pos + 1),
        data.readUint8(pos + 2),
        255
      )
      pos += 3
    bgColor = globalColorTable[bgColorIndex]

  proc skipSubBlocks() =
    while true: # Skip data sub-blocks
      if pos + 1 > data.len:
        failInvalid()

      let subBlockSize = data.readUint8(pos).int
      inc pos

      if subBlockSize == 0:
        break

      pos += subBlockSize

  var controlExtension: ControlExtension
  while true:
    if pos + 1 > data.len:
      failInvalid()

    let blockType = data.readUint8(pos)
    inc pos

    case blockType:
    of 0x2c: # Image
      if pos + 9 > data.len:
        failInvalid()

      let
        imageLeftPos = data.readUint16(pos + 0).int
        imageTopPos = data.readUint16(pos + 2).int
        imageWidth = data.readUint16(pos + 4).int
        imageHeight = data.readUint16(pos + 6).int
        imageFlags = data.readUint16(pos + 8)
        hasLocalColorTable = (imageFlags and 0b10000000) != 0
        interlaced = (imageFlags and 0b01000000) != 0
        localColorTableSize = 2 ^ ((imageFlags and 0b00000111) + 1)

      pos += 9

      if imageWidth > screenWidth or imageHeight > screenHeight:
        raise newException(PixieError, "Invalid GIF frame dimensions")

      if pos + localColorTableSize * 3 > data.len:
        failInvalid()

      var localColorTable: seq[ColorRGBX]
      if hasLocalColorTable:
        localColorTable.setLen(localColorTableSize)
        for i in 0 ..< localColorTable.len:
          localColorTable[i] = rgbx(
            data.readUint8(pos + 0),
            data.readUint8(pos + 1),
            data.readUint8(pos + 2),
            255
          )
          pos += 3

      if pos + 1 > data.len:
        failInvalid()

      let minCodeSize = data.readUint8(pos).int
      inc pos

      if minCodeSize > 11:
        failInvalid()

      # The image data is contained in a sequence of sub-blocks
      var lzwDataBlocks: seq[(int, int)] # (offset, len)
      while true:
        if pos + 1 > data.len:
          failInvalid()

        let subBlockSize = data.readUint8(pos).int
        inc pos

        if subBlockSize == 0:
          break

        if pos + subBlockSize > data.len:
          failInvalid()

        lzwDataBlocks.add((pos, subBlockSize))

        pos += subBlockSize

      var lzwDataLen: int
      for (_, len) in lzwDataBlocks:
        lzwDataLen += len

      var
        lzwData = newString(lzwDataLen)
        i: int
      for (offset, len) in lzwDataBlocks:
        copyMem(lzwData[i].addr, data[offset].unsafeAddr, len)
        i += len

      let
        clearCode = 1 shl minCodeSize
        endCode = clearCode + 1

      var
        b = BitStreamReader(
          src: cast[ptr UncheckedArray[uint8]](lzwData.cstring),
          len: lzwData.len
        )
        colorIndexes: seq[int]
        codeSize = minCodeSize + 1
        table = newSeq[(int, int)](endCode + 1)
        prev: tuple[offset, len: int]

      while true:
        let code = b.readBits(codeSize).int
        if b.bitsBuffered < 0:
          failInvalid()
        if code == endCode:
          break

        if code == clearCode:
          codeSize = minCodeSize + 1
          table.setLen(endCode + 1)
          prev = (0, 0)
          continue

        # Increase the code size if needed
        if table.len == (1 shl codeSize) - 1 and codeSize < 12:
          inc codeSize

        let start = colorIndexes.len
        if code < table.len: # If we have seen the code before
          if code < clearCode:
            colorIndexes.add(code)
            if prev.len > 0:
              table.add((prev.offset, prev.len + 1))
            prev = (start, 1)
          else:
            let (offset, len) = table[code]
            for i in 0 ..< len:
              colorIndexes.add(colorIndexes[offset + i])
            table.add((prev.offset, prev.len + 1))
            prev = (start, len)
        else:
          if prev[1] == 0:
            failInvalid()
          for i in 0 ..< prev[1]:
            colorIndexes.add(colorIndexes[prev[0] + i])
          colorIndexes.add(colorIndexes[prev[0]])
          table.add((start, prev.len + 1))
          prev = (start, prev.len + 1)

      if colorIndexes.len != imageWidth * imageHeight:
        failInvalid()

      let image = newImage(imageWidth, imageHeight)

      var transparentColorIndex = -1
      if (controlExtension.fields and 1) != 0: # Transparent index flag
        transparentColorIndex = controlExtension.transparentColorIndex.int

      let disposalMethod = (controlExtension.fields and 0b00011100) shr 2
      if disposalMethod == 2:
        let frame = newImage(screenWidth, screenHeight)
        frame.fill(bgColor)
        result.frames.add(frame)
      else:
        if hasLocalColorTable:
          for i, colorIndex in colorIndexes:
            if colorIndex >= localColorTable.len:
              # failInvalid()
              continue
            if colorIndex != transparentColorIndex:
              image.data[i] = localColorTable[colorIndex]
        else:
          for i, colorIndex in colorIndexes:
            if colorIndex >= globalColorTable.len:
              # failInvalid()
              continue
            if colorIndex != transparentColorIndex:
              image.data[i] = globalColorTable[colorIndex]

        if interlaced:
          # Just copyMem the rows into the right place. I've only ever seen
          # interlaced for the first frame so this is unlikely to be a hot path.
          let deinterlaced = newImage(image.width, image.height)
          var
            y: int
            i: int
          while i < image.height:
            copyMem(
              deinterlaced.data[deinterlaced.dataIndex(0, i)].addr,
              image.data[image.dataIndex(0, y)].addr,
              image.width * 4
            )
            i += 8
            inc y
          i = 4
          while i < image.height:
            copyMem(
              deinterlaced.data[deinterlaced.dataIndex(0, i)].addr,
              image.data[image.dataIndex(0, y)].addr,
              image.width * 4
            )
            i += 8
            inc y
          i = 2
          while i < image.height:
            copyMem(
              deinterlaced.data[deinterlaced.dataIndex(0, i)].addr,
              image.data[image.dataIndex(0, y)].addr,
              image.width * 4
            )
            i += 4
            inc y
          i = 1
          while i < image.height:
            copyMem(
              deinterlaced.data[deinterlaced.dataIndex(0, i)].addr,
              image.data[image.dataIndex(0, y)].addr,
              image.width * 4
            )
            i += 2
            inc y

          image.data = move deinterlaced.data

        if imageWidth != screenWidth or imageHeight != screenHeight or
          imageTopPos != 0 or imageLeftPos != 0:
          let frame = newImage(screenWidth, screenHeight)
          frame.draw(
            image,
            translate(vec2(imageLeftPos.float32, imageTopPos.float32))
          )
          result.frames.add(frame)
        else:
          result.frames.add(image)

      result.intervals.add(controlExtension.delayTime.float32 / 100)

      # Reset the control extension since it only applies to one image
      controlExtension = ControlExtension()

    of 0x21: # Extension
      if pos + 1 > data.len:
        failInvalid()

      let extensionType = data.readUint8(pos + 0)
      inc pos

      case extensionType:
      of 0xf9:
        # Graphic Control Extension
        if pos + 1 > data.len:
          failInvalid()

        let blockSize = data.readUint8(pos).int
        inc pos

        if blockSize != 4:
          failInvalid()

        if pos + blockSize > data.len:
          failInvalid()

        controlExtension.fields = data.readUint8(pos + 0)
        controlExtension.delayTime = data.readUint16(pos + 1)
        controlExtension.transparentColorIndex = data.readUint8(pos + 3)

        pos += blockSize
        inc pos # Block terminator

      of 0xfe:
        # Comment
        skipSubBlocks()

      # of 0x01:
      #   # Plain Text

      of 0xff:
        # Application Specific
        if pos + 1 > data.len:
          failInvalid()

        let blockSize = data.readUint8(pos).int
        inc pos

        if blockSize != 11:
          failInvalid()

        if pos + blockSize > data.len:
          failInvalid()

        pos += blockSize

        skipSubBlocks()

      else:
        raise newException(
          PixieError,
          "Unexpected GIF extension type " & toHex(extensionType)
        )

    of 0x3b: # Trailer
      break

    else:
      raise newException(
        PixieError,
        "Unexpected GIF block type " & toHex(blockType)
      )

  for interval in result.intervals:
    result.duration += interval

proc decodeGifDimensions*(
  data: pointer, len: int
): ImageDimensions {.raises: [PixieError].} =
  ## Decodes the GIF dimensions.
  if len < 10:
    failInvalid()

  let data = cast[ptr UncheckedArray[uint8]](data)

  let startsWithSignature =
    equalMem(data, gifSignatures[0].cstring, 6) or
    equalMem(data, gifSignatures[1].cstring, 6)

  if not startsWithSignature:
    raise newException(PixieError, "Invalid GIF file signature")

  result.width = data.readInt16(6).int
  result.height = data.readInt16(8).int

proc decodeGifDimensions*(
  data: string
): ImageDimensions {.raises: [PixieError].} =
  decodeGifDimensions(data.cstring, data.len)

proc newImage*(gif: Gif): Image {.raises: [].} =
  gif.frames[0].copy()

when defined(release):
  {.pop.}



================================================
FILE: src/pixie/fileformats/jpeg.nim
================================================
import chroma, flatty/binny, ../common, ../images, ../internal,
    ../simd, std/decls, std/sequtils, std/strutils

# This JPEG decoder is loosely based on stb_image which is public domain.

# JPEG is a complex format, this decoder only supports the most common features:
# * yCbCr format
# * gray scale format
# * 4:4:4, 4:2:2, 4:1:1, 4:2:0 resampling modes
# * progressive
# * restart markers
# * Exif orientation

# * https://github.com/daviddrysdale/libjpeg
# * https://www.youtube.com/watch?v=Kv1Hiv3ox8I
# * https://www.youtube.com/watch?v=0me3guauqOU
# * https://dev.exiv2.org/projects/exiv2/wiki/The_Metadata_in_JPEG_files
# * https://www.media.mit.edu/pia/Research/deepview/exif.html
# * https://www.ccoderun.ca/programming/2017-01-31_jpeg/
# * http://imrannazar.com/Let%27s-Build-a-JPEG-Decoder%3A-Concepts
# * https://github.com/nothings/stb/blob/master/stb_image.h
# * https://yasoob.me/posts/understanding-and-writing-jpeg-decoder-in-python/
# * https://www.w3.org/Graphics/JPEG/itu-t81.pdf

const
  fastBits = 9
  deZigZag = [
    uint8 00, 01, 08, 16, 09, 02, 03, 10,
    uint8 17, 24, 32, 25, 18, 11, 04, 05,
    uint8 12, 19, 26, 33, 40, 48, 41, 34,
    uint8 27, 20, 13, 06, 07, 14, 21, 28,
    uint8 35, 42, 49, 56, 57, 50, 43, 36,
    uint8 29, 22, 15, 23, 30, 37, 44, 51,
    uint8 58, 59, 52, 45, 38, 31, 39, 46,
    uint8 53, 60, 61, 54, 47, 55, 62, 63
  ]
  bitMasks = [ # (1 shr n) - 1
    0.uint32, 1, 3, 7, 15, 31, 63, 127, 255, 511,
    1023, 2047, 4095, 8191, 16383, 32767, 65535
  ]

let
  jpegStartOfImage* = [0xFF.uint8, 0xD8]

type
  Huffman = object
    codes: array[256, uint16]
    symbols: array[256, uint8]
    sizes: array[257, uint8]
    deltas: array[17, int]
    maxCodes: array[18, int]
    fast: array[1 shl fastBits, uint8]

  Component = object
    id, quantizationTableId: uint8
    yScale, xScale: int
    width, height: int
    widthStride, heightStride: int
    huffmanDC, huffmanAC: int
    dcPred: int
    widthCoeff, heightCoeff: int
    coeff, lineBuf: seq[uint8]
    blocks: seq[seq[array[64, int16]]]
    channel: Mask

  DecoderState = object
    buffer: ptr UncheckedArray[uint8]
    len, pos: int
    bitsBuffered: int
    bitBuffer: uint32
    foundSOF: bool
    imageHeight, imageWidth: int
    progressive: bool
    quantizationTables: array[4, array[64, uint8]]
    huffmanTables: array[2, array[4, Huffman]] # 0 = DC, 1 = AC
    components: seq[Component]
    maxYScale, maxXScale: int
    mcuWidth, mcuHeight, numMcuWide, numMcuHigh: int
    orientation: int
    scanComponents: int
    spectralStart, spectralEnd: int
    successiveApproxLow, successiveApproxHigh: int
    componentOrder: seq[int]
    restartInterval: int
    todoBeforeRestart: int
    eobRun: int
    hitEnd: bool

  Mask = ref object
    ## Mask object that holds mask opacity data.
    width*, height*: int
    data*: seq[uint8]

  UnsafeMask = distinct Mask

when defined(release):
  {.push checks: off.}

proc newMask(width, height: int): Mask {.raises: [PixieError].} =
  ## Creates a new mask with the parameter dimensions.
  if width <= 0 or height <= 0:
    raise newException(PixieError, "Mask width and height must be > 0")

  result = Mask()
  result.width = width
  result.height = height
  result.data = newSeq[uint8](width * height)

template dataIndex(mask: Mask, x, y: int): int =
  mask.width * y + x

template unsafe(src: Mask): UnsafeMask =
  cast[UnsafeMask](src)

template `[]`(view: UnsafeMask, x, y: int): uint8 =
  ## Gets a value from (x, y) coordinates.
  ## * No bounds checking *
  ## Make sure that x, y are in bounds.
  ## Failure in the assumptions will case unsafe memory reads.
  cast[Mask](view).data[cast[Mask](view).dataIndex(x, y)]

template `[]=`(view: UnsafeMask, x, y: int, color: uint8) =
  ## Sets a value from (x, y) coordinates.
  ## * No bounds checking *
  ## Make sure that x, y are in bounds.
  ## Failure in the assumptions will case unsafe memory writes.
  cast[Mask](view).data[cast[Mask](view).dataIndex(x, y)] = color

template failInvalid(reason = "unable to load") =
  ## Throw exception with a reason.
  raise newException(PixieError, "Invalid JPEG, " & reason)

proc clampByte(x: int32): uint8 {.inline.} =
  ## Clamp integer into byte range.
  # clamp(x, 0, 0xFF).uint8
  let
    signBit = (cast[uint32](x) shr 31)
    value = cast[uint32](x) and (signBit - 1)
  min(value, 255).uint8

proc readUint8(state: var DecoderState): uint8 =
  ## Reads a byte from the input stream.
  if state.pos >= state.len:
    failInvalid()
  result = state.buffer[state.pos]
  inc state.pos

proc readUint16be(state: var DecoderState): uint16 =
  ## Reads uint16 big-endian from the input stream.
  if state.pos + 2 > state.len:
    failInvalid()
  result =
    (state.buffer[state.pos].uint16 shl 8) or
    state.buffer[state.pos + 1]
  state.pos += 2

proc readUint32be(state: var DecoderState): uint32 =
  ## Reads uint32 big-endian from the input stream.
  if state.pos + 4 > state.len:
    failInvalid()
  result =
    (state.buffer[state.pos + 0].uint32 shl 24) or
    (state.buffer[state.pos + 1].uint32 shl 16) or
    (state.buffer[state.pos + 2].uint32 shl 8) or
    state.buffer[state.pos + 3]
  state.pos += 4

proc readStr(state: var DecoderState, n: int): string =
  ## Reads n number of bytes as a string.
  if state.pos + n > state.len:
    failInvalid()
  result.setLen(n)
  copyMem(result[0].addr, state.buffer[state.pos].addr, n)
  state.pos += n

proc skipBytes(state: var DecoderState, n: int) =
  ## Skips a number of bytes.
  if state.pos + n > state.len:
    failInvalid()
  state.pos += n

proc skipChunk(state: var DecoderState) =
  ## Skips current chunk.
  let len = state.readUint16be() - 2
  state.skipBytes(len.int)

proc decodeDRI(state: var DecoderState) =
  ## Decode Define Restart Interval
  let len = state.readUint16be() - 2
  if len != 2:
    failInvalid("invalid DRI length")
  state.restartInterval = state.readUint16be().int

proc decodeDQT(state: var DecoderState) =
  ## Decode Define Quantization Table(s)
  var len = state.readUint16be() - 2
  while len > 0:
    let
      info = state.readUint8()
      tableId = info and 15
      precision = info shr 4
    if precision != 0:
      failInvalid("unsupported quantization table precision")
    if tableId > 3:
      failInvalid()
    for i in 0 ..< 64:
      state.quantizationTables[tableId][deZigZag[i]] = state.readUint8()
    len -= 65
  if len != 0:
    failInvalid("DQT table length did not match")

proc buildHuffman(huffman: var Huffman, counts: array[16, uint8]) =
  ## Builds the huffman data structure.
  block:
    # JPEG spec page 51
    var k: int
    for i in 0.uint8 ..< 16:
      for j in 0.uint8 ..< counts[i]:
        if k notin 0 ..< 256:
          failInvalid()
        huffman.sizes[k] = i + 1
        inc k
    huffman.sizes[k] = 0

  # JPEG spec page 52
  var code, k: int
  for i in 1.uint8 .. 16:
    huffman.deltas[i] = k - code
    if huffman.sizes[k] == i:
      while huffman.sizes[k] == i:
        huffman.codes[k] = code.uint16
        inc code
        inc k
      if code - 1 >= 1 shl i:
        failInvalid()
    huffman.maxCodes[i] = code shl (16 - i)
    code = code shl 1
  huffman.maxCodes[17] = int.high

  for i in 0 ..< huffman.fast.len:
    huffman.fast[i] = 255

  for i in 0 ..< k:
    let size = huffman.sizes[i]
    if size <= fastBits:
      let fast = huffman.codes[i].int shl (fastBits - size)
      for j in 0 ..< 1 shl (fastBits - size):
        huffman.fast[fast + j] = i.uint8

proc decodeDHT(state: var DecoderState) =
  ## Decode Define Huffman Table
  var len = state.readUint16be() - 2
  while len > 0:
    let
      info = state.readUint8()
      tableId = info and 15
      tableCurrent = info shr 4 # DC or AC

    if tableCurrent > 1 or tableId > 3:
      failInvalid()

    var
      counts: array[16, uint8]
      numSymbols: uint8
    for i in 0 ..< 16:
      counts[i] = state.readUint8()
      numSymbols += counts[i]

    len -= 17

    state.huffmanTables[tableCurrent][tableId] = Huffman()
    state.huffmanTables[tableCurrent][tableId].buildHuffman(counts)

    for i in 0.uint8 ..< numSymbols:
      state.huffmanTables[tableCurrent][tableId].symbols[i] = state.readUint8()

    len -= numSymbols

  if len != 0:
    failInvalid()

proc decodeSOF0(state: var DecoderState) =
  ## Decode start of Frame
  if state.foundSOF:
    failInvalid()
  state.foundSOF = true

  var len = state.readUint16be().int - 2

  let precision = state.readUint8()
  if precision != 8:
    failInvalid("unsupported bit depth, must be 8")

  state.imageHeight = state.readUint16be().int
  state.imageWidth = state.readUint16be().int

  if state.imageHeight == 0:
    failInvalid("image invalid 0 height")
  if state.imageWidth == 0:
    failInvalid("image invalid 0 width")

  let numComponentsU8 = state.readUint8()
  let numComponents = numComponentsU8.int
  if numComponentsU8 notin {1'u8, 3}:
    failInvalid("unsupported component count, must be 1 or 3")

  len -= 6

  for i in 0 ..< numComponents:
    var component = Component()
    component.id = state.readUint8()
    let
      info = state.readUint8()
      vertical = info and 15
      horizontal = info shr 4
      quantizationTableId = state.readUint8()

    if quantizationTableId > 3:
      failInvalid("invalid quantization table id")

    if vertical notin {1'u8, 2, 4} or horizontal notin {1'u8, 2, 4}:
      failInvalid("invalid component scaling factor")

    component.xScale = vertical.int
    component.yScale = horizontal.int
    component.quantizationTableId = quantizationTableId
    state.components.add(component)

  len -= 3 * numComponents

  for component in state.components.mitems:
    state.maxXScale = max(state.maxXScale, component.xScale)
    state.maxYScale = max(state.maxYScale, component.yScale)

  state.mcuWidth = state.maxYScale * 8
  state.mcuHeight = state.maxXScale * 8
  state.numMcuWide =
    (state.imageWidth + state.mcuWidth - 1) div state.mcuWidth
  state.numMcuHigh =
    (state.imageHeight + state.mcuHeight - 1) div state.mcuHeight

  for component in state.components.mitems:
    component.width = (
      state.imageWidth *
      component.yScale +
      state.maxYScale - 1
    ) div state.maxYScale
    component.height = (
      state.imageHeight *
      component.xScale +
      state.maxXScale - 1
    ) div state.maxXScale

    # Allocate block data structures.
    component.blocks = newSeqWith(
      state.numMcuWide * component.yScale,
      newSeq[array[64, int16]](
        state.numMcuHigh * component.xScale
      )
    )

    component.widthStride = state.numMcuWide * component.yScale * 8
    component.heightStride = state.numMcuHigh * component.xScale * 8
    component.channel = newMask(component.widthStride, component.heightStride)

    if state.progressive:
      component.widthCoeff = component.widthStride div 8
      component.heightCoeff = component.heightStride div 8
      component.coeff.setLen(component.widthStride * component.heightStride)

  if len != 0:
    failInvalid()

proc decodeSOF1(state: var DecoderState) =
  failInvalid("unsupported extended sequential DCT format")

proc decodeSOF2(state: var DecoderState) =
  ## Decode Start of Image (Progressive DCT format)
  # Same as SOF0
  state.decodeSOF0()
  state.progressive = true

proc decodeExif(state: var DecoderState) =
  ## Decode Exif header
  var len = state.readUint16be().int - 2

  let exifHeader = state.readStr(6)

  len -= 6

  if exifHeader != "Exif\0\0":
    # Happens with progressive images, just ignore instead of error.
    # Skip to the end.
    state.skipBytes(len)
    return

  # Read the endianess of the exif header
  let
    tiffHeader = state.readUint16be().int
    littleEndian =
      if tiffHeader == 0x4D4D:
        false
      elif tiffHeader == 0x4949:
        true
      else:
        failInvalid("invalid Tiff header")

  len -= 2

  # Verify we got the endianess right.
  if state.readUint16be().maybeSwap(littleEndian) != 0x002A.uint16:
    failInvalid("invalid Tiff header endianess")

  len -= 2

  # Skip any other tiff header data.
  let offsetToFirstIFD = state.readUint32be().maybeSwap(littleEndian).int

  len -= 4

  if offsetToFirstIFD < 8:
    failInvalid("invalid Tiff offset")

  state.skipBytes(offsetToFirstIFD - 8)

  len -= (offsetToFirstIFD - 8)

  # Read the IFD0 (main image) tags.
  let numTags = state.readUint16be().maybeSwap(littleEndian).int

  len -= 2

  for i in 0 ..< numTags:
    let
      tagNumber = state.readUint16be().maybeSwap(littleEndian)
      dataFormat = state.readUint16be().maybeSwap(littleEndian)
      numberComponents = state.readUint32be().maybeSwap(littleEndian)
      dataOffset = state.readUint32be().maybeSwap(littleEndian).int

    len -= 12

    # For now we only care about orientation tag.
    case tagNumber:
      of 0x0112: # Orientation
        state.orientation = dataOffset shr 16
      else:
        discard

  # Skip all of the data we do not want to read, IFD1, thumbnail, etc.
  state.skipBytes(len) # Skip any remaining len

proc reset(state: var DecoderState) =
  ## Rests the decoder state need for restart markers.
  state.bitBuffer = 0
  state.bitsBuffered = 0
  state.hitEnd = false
  for component in 0 ..< state.components.len:
    state.components[component].dcPred = 0
  if state.restartInterval != 0:
    state.todoBeforeRestart = state.restartInterval
  else:
    state.todoBeforeRestart = int.high
  state.eobRun = 0

proc decodeSOS(state: var DecoderState) =
  ## Decode Start of Scan - header before the block data.
  var len = state.readUint16be() - 2

  state.scanComponents = state.readUint8().int

  if state.scanComponents > state.components.len:
    failInvalid("extra components")

  if cast[uint8](state.scanComponents) notin {1'u8, 3}:
    failInvalid("unsupported scan component count")

  state.componentOrder.setLen(0)

  for i in 0 ..< state.scanComponents:
    let
      id = state.readUint8()
      info = state.readUint8()
      huffmanAC = info and 15
      huffmanDC = info shr 4

    if huffmanAC > 3 or huffmanDC > 3:
      failInvalid()

    var component: int
    while component < state.components.len:
      if state.components[component].id == id:
        break
      inc component
    if component == state.components.len:
      failInvalid() # Not found

    state.components[component].huffmanAC = huffmanAC.int
    state.components[component].huffmanDC = huffmanDC.int
    state.componentOrder.add(component)

  state.spectralStart = state.readUint8().int
  state.spectralEnd = state.readUint8().int

  let aa = state.readUint8().int
  state.successiveApproxLow = aa and 15
  state.successiveApproxHigh = aa shr 4

  if state.progressive:
    if state.spectralStart > 63 or state.spectralEnd > 63:
      failInvalid()
    if state.spectralEnd > state.spectralEnd:
      failInvalid()
    if state.successiveApproxHigh > 13 or state.successiveApproxLow > 13:
      failInvalid()
  else:
    if state.spectralStart != 0:
      failInvalid()
    if state.successiveApproxHigh != 0 or state.successiveApproxLow != 0:
      failInvalid()
    state.spectralEnd = 63

  len -= 4 + 2 * state.scanComponents.uint16

  if len != 0:
    failInvalid()

  state.reset()

proc fillBitBuffer(state: var DecoderState) =
  ## When we are low on bits, we need to call this to populate some more.
  while state.bitsBuffered <= 24:
    let b =
      if state.hitEnd:
        0.uint32
      else:
        state.readUint8().uint32
    if b == 0xFF:
      var c = state.readUint8()
      while c == 0xFF:
        c = state.readUint8()
      if c != 0:
        state.pos -= 2
        state.hitEnd = true
        return
    state.bitBuffer = state.bitBuffer or (b shl (24 - state.bitsBuffered))
    state.bitsBuffered += 8

proc huffmanDecode(state: var DecoderState, tableCurrent, table: int): uint8 =
  ## Decode a uint8 from the huffman table.
  var huffman {.byaddr.} = state.huffmanTables[tableCurrent][table]

  state.fillBitBuffer()

  let
    fastId = (state.bitBuffer shr (32 - fastBits)) and ((1 shl fastBits) - 1)
    fast = huffman.fast[fastId]

  if fast < 255:
    let size = huffman.sizes[fast].int
    if size > state.bitsBuffered:
      failInvalid()
    state.bitBuffer = state.bitBuffer shl size
    state.bitsBuffered -= size
    return huffman.symbols[fast]

  var
    tmp = (state.bitBuffer shr 16).int
    i = fastBits + 1
  while i < huffman.maxCodes.len:
    if tmp < huffman.maxCodes[i]:
      break
    inc i

  if i == 17 or i > state.bitsBuffered:
    failInvalid()

  let symbolId = (state.bitBuffer shr (32 - i)).int + huffman.deltas[i]
  state.bitBuffer = state.bitBuffer shl i
  state.bitsBuffered -= i
  return huffman.symbols[symbolId]

template lrot(value: uint32, shift: int): uint32 =
  ## Left rotate
  (value shl shift) or (value shr (32 - shift))

proc readBit(state: var DecoderState): int =
  ## Get a single bit.
  if state.bitsBuffered < 1:
    state.fillBitBuffer()
  result = ((state.bitBuffer and cast[uint32](0x80000000)) shr 31).int
  state.bitBuffer = state.bitBuffer shl 1
  dec state.bitsBuffered

proc readBits(state: var DecoderState, n: int): int =
  ## Get n number of bits as a unsigned integer.
  if n notin 0 .. 16:
    failInvalid()
  if state.bitsBuffered < n:
    state.fillBitBuffer()
  let k = lrot(state.bitBuffer, n)
  result = (k and bitMasks[n]).int
  state.bitBuffer = k and (not bitMasks[n])
  state.bitsBuffered -= n

proc receiveExtend(state: var DecoderState, n: int): int =
  ## Get n number of bits as a signed integer. See Jpeg spec pages 109 and 114
  ## for EXTEND and RECEIVE.
  var
    v = state.readBits(n)
    vt = (1 shl (n - 1))
  if v < vt:
    vt = (-1 shl n) + 1
    v = v + vt
  return v

proc decodeRegularBlock(
  state: var DecoderState, component: int, data: var array[64, int16]
) =
  ## Decodes a whole block.
  let t = state.huffmanDecode(0, state.components[component].huffmanDC).int
  if t > 15:
    failInvalid("bad huffman code")
  let
    diff =
      if t == 0:
        0
      else:
        state.receiveExtend(t)
    dc = state.components[component].dcPred + diff
  state.components[component].dcPred = dc
  data[0] = cast[int16](dc)

  var i = 1
  while i < 64:
    let
      rs = state.huffmanDecode(1, state.components[component].huffmanAC)
      s = rs and 15
      r = rs shr 4
    if s == 0:
      if rs != 0xF0:
        break
      i += 16
    else:
      i += r.int
      if i >= 64:
        failInvalid()
      let zig = deZigZag[i]
      data[zig] = cast[int16](state.receiveExtend(s.int))
      inc i

proc decodeProgressiveBlock(
  state: var DecoderState, component: int, data: var array[64, int16]
) =
  ## Decode a Progressive Start Block
  if state.spectralEnd != 0:
    failInvalid("can't merge dc and ac")

  if state.successiveApproxHigh == 0:
    let t = state.huffmanDecode(0, state.components[component].huffmanDC).int
    if t > 15:
      failInvalid("bad huffman code")
    let
      diff =
        if t > 0:
          state.receiveExtend(t)
        else:
          0
      dc = state.components[component].dcPred + diff
    state.components[component].dcPred = dc
    data[0] = cast[int16](dc * (1 shl state.successiveApproxLow))
  else:
    if state.readBit() != 0:
      data[0] = cast[int16](data[0] + (1 shl state.successiveApproxLow))

proc decodeProgressiveContinuationBlock(
  state: var DecoderState, component: int, data: var array[64, int16]
) =
  ## Decode a Progressive Continuation Block
  if state.spectralStart == 0:
    failInvalid("can't merge progressive blocks")

  if state.successiveApproxHigh == 0:
    var shift = state.successiveApproxLow

    if state.eobRun != 0:
      dec state.eobRun
      return

    var k = state.spectralStart
    while k <= state.spectralEnd:
      let
        rs = state.huffmanDecode(1, state.components[component].huffmanAC)
        s = rs and 15
        r = rs.int shr 4
      if s == 0:
        if r < 15:
          state.eobRun = 1 shl r
          if r != 0:
            state.eobRun += state.readBits(r)
          dec state.eobRun
          break
        k += 16
      else:
        k += r.int
        if k >= 64:
          failInvalid()
        let zig = deZigZag[k]
        inc k
        if s >= 15:
          failInvalid()
        data[zig] = cast[int16](state.receiveExtend(s.int) * (1 shl shift))

  else:
    let bit = 1 shl state.successiveApproxLow

    if state.eobRun != 0:
      dec state.eobRun
      for k in state.spectralStart ..< state.spectralEnd:
        let zig = deZigZag[k]
        if data[zig] != 0:
          if state.readBit() != 0:
            if (data[zig] and bit) == 0:
              if data[zig] > 0:
                data[zig] = cast[int16](data[zig] + bit)
              else:
                data[zig] = cast[int16](data[zig] - bit)
    else:
      var k = state.spectralStart
      while k <= state.spectralEnd:
        let rs = state.huffmanDecode(1, state.components[component].huffmanAC)
        var
          s = rs.int and 15
          r = rs.int shr 4
        if s == 0:
          if r < 15:
            state.eobRun = (1 shl r) - 1
            if r != 0:
              state.eobRun += state.readBits(r)
            r = 64 # force end of block
          else:
            discard
        else:
          if s != 1:
            failInvalid("bad huffman code")
          if state.readBit() != 0:
            s = bit
          else:
            s = -bit

        while k <= state.spectralEnd:
          let zig = deZigZag[k]
          inc k
          if data[zig] != 0:
            if state.readBit() != 0:
              if (data[zig] and bit) == 0:
                if data[zig] > 0:
                  data[zig] = cast[int16](data[zig] + bit)
                else:
                  data[zig] = cast[int16](data[zig] - bit)
          else:
            if r == 0:
              data[zig] = cast[int16](s)
              break
            dec r

template idct1D(s0, s1, s2, s3, s4, s5, s6, s7: int32) =
  ## Inverse discrete cosine transform 1D
  template f2f(x: float32): int32 = (x * 4096 + 0.5).int32
  template fsh(x: int32): int32 = x * 4096
  p2 = s2
  p3 = s6
  p1 = (p2 + p3) * f2f(0.5411961f)
  t2 = p1 + p3*f2f(-1.847759065f)
  t3 = p1 + p2*f2f(0.765366865f)
  p2 = s0
  p3 = s4
  t0 = fsh(p2 + p3)
  t1 = fsh(p2 - p3)
  x0 = t0 + t3
  x3 = t0 - t3
  x1 = t1 + t2
  x2 = t1 - t2
  t0 = s7
  t1 = s5
  t2 = s3
  t3 = s1
  p3 = t0 + t2
  p4 = t1 + t3
  p1 = t0 + t3
  p2 = t1 + t2
  p5 = (p3 + p4) * f2f(1.175875602f)
  t0 = t0 * f2f(0.298631336f)
  t1 = t1 * f2f(2.053119869f)
  t2 = t2 * f2f(3.072711026f)
  t3 = t3 * f2f(1.501321110f)
  p1 = p5 + p1*f2f(-0.899976223f)
  p2 = p5 + p2*f2f(-2.562915447f)
  p3 = p3 * f2f(-1.961570560f)
  p4 = p4 * f2f(-0.390180644f)
  t3 += p1 + p4
  t2 += p2 + p3
  t1 += p2 + p4
  t0 += p1 + p3

{.push overflowChecks: off, rangeChecks: off.}

proc idctBlock(component: var Component, offset: int, data: array[64, int16]) =
  ## Inverse discrete cosine transform whole block.
  var values: array[64, int32]
  for i in 0 ..< 8:
    if data[i + 8] == 0 and
      data[i + 16] == 0 and
      data[i + 24] == 0 and
      data[i + 32] == 0 and
      data[i + 40] == 0 and
      data[i + 48] == 0 and
      data[i + 56] == 0:
      let dcterm = data[i] * 4
      values[i + 0] = dcterm
      values[i + 8] = dcterm
      values[i + 16] = dcterm
      values[i + 24] = dcterm
      values[i + 32] = dcterm
      values[i + 40] = dcterm
      values[i + 48] = dcterm
      values[i + 56] = dcterm
    else:
      var t0, t1, t2, t3, p1, p2, p3, p4, p5, x0, x1, x2, x3: int32
      idct1D(
        data[i + 0],
        data[i + 8],
        data[i + 16],
        data[i + 24],
        data[i + 32],
        data[i + 40],
        data[i + 48],
        data[i + 56]
      )
      x0 += 512
      x1 += 512
      x2 += 512
      x3 += 512
      values[i + 0] = (x0 + t3) shr 10
      values[i + 56] = (x0 - t3) shr 10
      values[i + 8] = (x1 + t2) shr 10
      values[i + 48] = (x1 - t2) shr 10
      values[i + 16] = (x2 + t1) shr 10
      values[i + 40] = (x2 - t1) shr 10
      values[i + 24] = (x3 + t0) shr 10
      values[i + 32] = (x3 - t0) shr 10

  for i in 0 ..< 8:
    let
      valuesPos = i * 8
      outPos = i * component.widthStride + offset

    var t0, t1, t2, t3, p1, p2, p3, p4, p5, x0, x1, x2, x3: int32
    idct1D(
      values[valuesPos + 0],
      values[valuesPos + 1],
      values[valuesPos + 2],
      values[valuesPos + 3],
      values[valuesPos + 4],
      values[valuesPos + 5],
      values[valuesPos + 6],
      values[valuesPos + 7]
    )

    x0 += 65536 + (128 shl 17)
    x1 += 65536 + (128 shl 17)
    x2 += 65536 + (128 shl 17)
    x3 += 65536 + (128 shl 17)

    component.channel.data[outPos + 0] = clampByte((x0 + t3) shr 17)
    component.channel.data[outPos + 7] = clampByte((x0 - t3) shr 17)
    component.channel.data[outPos + 1] = clampByte((x1 + t2) shr 17)
    component.channel.data[outPos + 6] = clampByte((x1 - t2) shr 17)
    component.channel.data[outPos + 2] = clampByte((x2 + t1) shr 17)
    component.channel.data[outPos + 5] = clampByte((x2 - t1) shr 17)
    component.channel.data[outPos + 3] = clampByte((x3 + t0) shr 17)
    component.channel.data[outPos + 4] = clampByte((x3 - t0) shr 17)

{.pop.}

proc decodeBlock(state: var DecoderState, comp, row, column: int) =
  ## Decodes a block.
  var data {.byaddr.} = state.components[comp].blocks[row][column]
  if state.progressive:
    if state.spectralStart == 0:
      state.decodeProgressiveBlock(comp, data)
    else:
      state.decodeProgressiveContinuationBlock(comp, data)
  else:
    state.decodeRegularBlock(comp, data)

proc checkRestart(state: var DecoderState) =
  ## Check if we might have run into a restart marker, then deal with it.
  dec state.todoBeforeRestart
  if state.todoBeforeRestart <= 0:
    if state.pos + 1 > state.len:
      failInvalid()
    # Handle getting a restart marker right at the end.
    if state.buffer[state.pos] == 0xFF and state.buffer[state.pos+1] == 0xD9:
      return
    if state.buffer[state.pos] != 0xFF or
      state.buffer[state.pos + 1] notin 0xD0'u8 .. 0xD7'u8:
      failInvalid("did not get expected restart marker")
    state.pos += 2
    state.reset()

proc decodeBlocks(state: var DecoderState) =
  ## Decodes scan data blocks that follow a SOS block.
  if state.scanComponents == 1:
    # Single component pass.
    let
      comp = state.componentOrder[0]
      w = (state.components[comp].width + 7) div 8
      h = (state.components[comp].height + 7) div 8
    for column in 0 ..< h:
      for row in 0 ..< w:
        state.decodeBlock(comp, row, column)
        state.checkRestart()
  else:
    # Interleaved regular component pass.
    for mcuY in 0 ..< state.numMcuHigh:
      for mcuX in 0 ..< state.numMcuWide:
        for comp in state.componentOrder:
          for compY in 0 ..< state.components[comp].xScale:
            for compX in 0 ..< state.components[comp].yScale:
              let
                row = (mcuX * state.components[comp].yScale + compX)
                col = (mcuY * state.components[comp].xScale + compY)
              state.decodeBlock(comp, row, col)
        state.checkRestart()

proc quantizationAndIDCTPass(state: var DecoderState) =
  ## Does quantization and IDCT.
  for comp in 0 ..< state.components.len:
    let
      w = (state.components[comp].width + 7) div 8
      h = (state.components[comp].height + 7) div 8
      qTableId = state.components[comp].quantizationTableId
    if qTableId.int notin 0 ..< state.quantizationTables.len:
      failInvalid()
    for column in 0 ..< h:
      for row in 0 ..< w:
        var data {.byaddr.} = state.components[comp].blocks[row][column]

        when defined(amd64) and allowSimd:
          for i in 0 ..< 8: # 8 per pass
            var q = mm_loadu_si128(state.quantizationTables[qTableId][i * 8].addr)
            q = mm_unpacklo_epi8(q, mm_setzero_si128())
            var v = mm_loadu_si128(data[i * 8].addr)
            mm_storeu_si128(data[i * 8].addr, mm_mullo_epi16(v, q))
        else:
          for i in 0 ..< 64:
            data[i] = cast[int16](
              data[i] * state.quantizationTables[qTableId][i].int32
            )

        state.components[comp].idctBlock(
          state.components[comp].widthStride * column * 8 + row * 8,
          data
        )

proc magnifyXBy2(mask: Mask): Mask =
  ## Smooth magnify by power of 2 only in the X direction.
  result = newMask(mask.width * 2, mask.height)
  for y in 0 ..< mask.height:
    for x in 0 ..< mask.width:
      let n = 3 * mask.unsafe[x, y].uint16
      if x == 0:
        result.unsafe[x * 2 + 0, y] = mask.unsafe[x, y]
        result.unsafe[x * 2 + 1, y] =
          ((n + mask.unsafe[x + 1, y].uint16 + 2) div 4).uint8
      elif x == mask.width - 1:
        result.unsafe[x * 2 + 0, y] =
          ((n + mask.unsafe[x - 1, y].uint16 + 2) div 4).uint8
        result.unsafe[x * 2 + 1, y] = mask.unsafe[x, y]
      else:
        result.unsafe[x * 2 + 0, y] =
          ((n + mask.unsafe[x - 1, y].uint16) div 4).uint8
        result.unsafe[x * 2 + 1, y] =
          ((n + mask.unsafe[x + 1, y].uint16) div 4).uint8

proc magnifyYBy2(mask: Mask): Mask =
  ## Smooth magnify by power of 2 only in the Y direction.
  result = newMask(mask.width, mask.height * 2)
  for y in 0 ..< mask.height:
    for x in 0 ..< mask.width:
      let n = 3 * mask.unsafe[x, y].uint16
      if y == 0:
        result.unsafe[x, y * 2 + 0] = mask.unsafe[x, y]
        result.unsafe[x, y * 2 + 1] =
          ((n + mask.unsafe[x, y + 1].uint16 + 2) div 4).uint8
      elif y == mask.height - 1:
        result.unsafe[x, y * 2 + 0] =
          ((n + mask.unsafe[x, y - 1].uint16 + 2) div 4).uint8
        result.unsafe[x, y * 2 + 1] = mask.unsafe[x, y]
      else:
        result.unsafe[x, y * 2 + 0] =
          ((n + mask.unsafe[x, y - 1].uint16) div 4).uint8
        result.unsafe[x, y * 2 + 1] =
          ((n + mask.unsafe[x, y + 1].uint16) div 4).uint8

proc yCbCrToRgbx(py, pcb, pcr: uint8): ColorRGBX =
  ## Takes a 3 component yCbCr outputs and populates image.
  template float2Fixed(x: float32): int32 =
    (x * 4096 + 0.5).int32 shl 8

  let
    yFixed = (py.int32 shl 20) + (1 shl 19)
    cb = pcb.int32 - 128
    cr = pcr.int32 - 128
  var
    r = yFixed + cr * float2Fixed(1.40200)
    g = yFixed +
      (cr * -float2Fixed(0.71414)) +
      ((cb * -float2Fixed(0.34414)) and -65536)
    b = yFixed + cb * float2Fixed(1.77200)
  result.r = clampByte(r shr 20)
  result.g = clampByte(g shr 20)
  result.b = clampByte(b shr 20)
  result.a = 255

proc grayScaleToRgbx(gray: uint8): ColorRGBX {.inline.} =
  ## Takes a single gray scale component output and populates image.
  rgbx(gray, gray, gray, 255)

proc buildImage(state: var DecoderState): Image =
  ## Takes a jpeg image object and builds a pixie Image from it.

  result = newImage(state.imageWidth, state.imageHeight)

  case state.components.len:
  of 3:
    for component in state.components.mitems:
      while component.yScale < state.maxYScale:
        component.channel = component.channel.magnifyXBy2()
        component.yScale *= 2

      while component.xScale < state.maxXScale:
        component.channel = component.channel.magnifyYBy2()
        component.xScale *= 2

    let
      cy = state.components[0].channel
      cb = state.components[1].channel
      cr = state.components[2].channel
    for y in 0 ..< state.imageHeight:
      var channelIndex = cy.dataIndex(0, y)
      for x in 0 ..< state.imageWidth:
        result.unsafe[x, y] = yCbCrToRgbx(
          cy.data[channelIndex],
          cb.data[channelIndex],
          cr.data[channelIndex],
        )
        inc channelIndex

  of 1:
    let cy = state.components[0].channel
    for y in 0 ..< state.imageHeight:
      var channelIndex = cy.dataIndex(0, y)
      for x in 0 ..< state.imageWidth:
        result.unsafe[x, y] = grayScaleToRgbx(cy.data[channelIndex])
        inc channelIndex

  else:
    failInvalid()

  # Do any of the orientation flips from the Exif header.
  case state.orientation:
    of 0, 1:
      discard
    of 2:
      result.flipHorizontal()
    of 3:
      result.flipVertical()
      result.flipHorizontal()
    of 4:
      result.flipVertical()
    of 5:
      result.rotate90()
      result.flipHorizontal()
    of 6:
      result.rotate90()
    of 7:
      result.rotate90()
      result.flipVertical()
    of 8:
      result.rotate90()
      result.flipVertical()
      result.flipHorizontal()
    else:
      failInvalid("invalid orientation")

proc decodeJpeg*(data: string): Image {.raises: [PixieError].} =
  ## Decodes the JPEG into an Image.

  var state = DecoderState()
  state.buffer = cast[ptr UncheckedArray[uint8]](data.cstring)
  state.len = data.len

  while true:
    if state.readUint8() != 0xFF:
      failInvalid("invalid chunk marker")

    let chunkId = state.readUint8()
    case chunkId:
      of 0xC0:
        # Start Of Frame (Baseline DCT)
        state.decodeSOF0()
      of 0xC1:
        # Start Of Frame (Extended sequential DCT)
        state.decodeSOF1()
      of 0xC2:
        # Start Of Frame (Progressive DCT)
        state.decodeSOF2()
      of 0xC4:
        # Define Huffman Table
        state.decodeDHT()
      of 0xD8:
        # SOI - Start of Image
        discard
      of 0xD9:
        # EOI - End of Image
        break
      of 0xD0 .. 0xD7:
        # Restart markers
        failInvalid("invalid restart marker")
      of 0xDB:
        # Define Quantization Table(s)
        state.decodeDQT()
      of 0xDD:
        # Define Restart Interval
        state.decodeDRI()
      of 0xDA:
        # Start Of Scan
        state.decodeSOS()
        # Entropy-coded data
        state.decodeBlocks()
      of 0XE0:
        # Application-specific
        # state.decodeAPP0(data, at)
        state.skipChunk()
      of 0xE1:
        # Exif/APP1
        state.decodeExif()
      of 0xE2..0xEF:
        # Application-specific
        state.skipChunk()
      of 0xFE:
        # Comment
        state.skipChunk()
      else:
        failInvalid("invalid chunk " & chunkId.toHex())

  state.quantizationAndIDCTPass()

  state.buildImage()

proc decodeJpegDimensions*(
  data: pointer, len: int
): ImageDimensions {.raises: [PixieError].} =
  ## Decodes the JPEG dimensions.

  var state = DecoderState()
  state.buffer = cast[ptr UncheckedArray[uint8]](data)
  state.len = len

  while true:
    if state.readUint8() != 0xFF:
      failInvalid("invalid chunk marker")

    let chunkId = state.readUint8()
    case chunkId:
      of 0xD8:
        # SOI - Start of Image
        discard
      of 0xC0, 0xC2:
        # Start Of Frame (Baseline DCT or Progressive DCT)
        discard state.readUint16be().int # Chunk len
        discard state.readUint8() # Precision
        state.imageHeight = state.readUint16be().int
        state.imageWidth = state.readUint16be().int
        break
      of 0xC1:
        failInvalid("unsupported extended sequential DCT format")
      of 0xC4:
        # Define Huffman Table
        state.decodeDHT()
      of 0xDB:
        # Define Quantization Table(s)
        state.skipChunk()
      of 0xDD:
        # Define Restart Interval
        state.skipChunk()
      of 0XE0:
        # Application-specific
        state.skipChunk()
      of 0xE1:
        # Exif/APP1
        state.decodeExif()
      of 0xE2..0xEF:
        # Application-specific
        state.skipChunk()
      of 0xFE:
        # Comment
        state.skipChunk()
      else:
        failInvalid("invalid chunk " & chunkId.toHex())

  case state.orientation:
    of 0, 1, 2, 3, 4:
      result.width = state.imageWidth
      result.height = state.imageHeight
    of 5, 6, 7, 8:
      result.width = state.imageHeight
      result.height = state.imageWidth
    else:
      failInvalid("invalid orientation")

proc decodeJpegDimensions*(
  data: string
): ImageDimensions {.raises: [PixieError].} =
  ## Decodes the JPEG dimensions.
  decodeJpegDimensions(data.cstring, data.len)

when defined(release):
  {.pop.}



================================================
FILE: src/pixie/fileformats/png.nim
================================================
import chroma, flatty/binny, math, ../common, ../images, ../internal,
    ../simd, zippy, crunchy

# See http://www.libpng.org/pub/png/spec/1.2/PNG-Contents.html

let
  pngSignature* = [137.uint8, 80, 78, 71, 13, 10, 26, 10]

type
  ChunkCounts = object
    PLTE, IDAT, tRNS: uint8

  PngHeader = object
    width, height: int
    bitDepth, colorType, compressionMethod, filterMethod, interlaceMethod: uint8

  Png* = ref object
    width*, height*, channels*: int
    data*: seq[ColorRGBA]

template failInvalid() =
  raise newException(PixieError, "Invalid PNG buffer, unable to load")

template failCRC() =
  raise newException(PixieError, "CRC check failed")

when defined(release):
  {.push checks: off.}

proc decodeHeader(data: pointer): PngHeader =
  let data = cast[ptr UncheckedArray[uint8]](data)
  result.width = data.readUint32(0).swap().int
  result.height = data.readUint32(4).swap().int
  result.bitDepth = data.readUint8(8)
  result.colorType = data.readUint8(9)
  result.compressionMethod = data.readUint8(10)
  result.filterMethod = data.readUint8(11)
  result.interlaceMethod = data.readUint8(12)

  if result.width == 0 or result.width > int32.high.int:
    raise newException(PixieError, "Invalid PNG width")

  if result.height == 0 or result.height > int32.high.int:
    raise newException(PixieError, "Invalid PNG height")

  template failInvalidCombo() =
    raise newException(
      PixieError, "Invalid PNG color type and bit depth combination"
    )

  case result.colorType:
  of 0:
    if result.bitDepth notin [1.uint8, 2, 4, 8, 16]:
      failInvalidCombo()
  of 2:
    if result.bitDepth notin [8.uint8, 16]:
      failInvalidCombo()
  of 3: # PLTE chunk is required, sample depth is always 8 bits
    if result.bitDepth notin [1.uint8, 2, 4, 8]:
      failInvalidCombo()
  of 4:
    if result.bitDepth notin [8.uint8, 16]:
      failInvalidCombo()
  of 6:
    if result.bitDepth notin [8.uint8, 16]:
      failInvalidCombo()
  else:
    failInvalidCombo()

  if result.compressionMethod != 0:
    raise newException(PixieError, "Invalid PNG compression method")

  if result.filterMethod != 0:
    raise newException(PixieError, "Invalid PNG filter method")

  if result.interlaceMethod notin [0.uint8, 1]:
    raise newException(PixieError, "Invalid PNG interlace method")

proc decodePalette(data: pointer, len: int): seq[ColorRGB] =
  if len == 0 or len mod 3 != 0:
    failInvalid()

  result.setLen(len div 3)

  copyMem(result[0].addr, data, len)

proc unfilter(
  uncompressed: pointer, len, height, rowBytes, bpp: int
): seq[uint8] =
  result.setLen(len - height)

  template uncompressedIdx(x, y: int): int =
    x + y * (rowBytes + 1)

  template unfiteredIdx(x, y: int): int =
    x + y * rowBytes

  let uncompressed = cast[ptr UncheckedArray[uint8]](uncompressed)

  # Unfilter the image data
  for y in 0 ..< height:
    let filterType = uncompressed[uncompressedIdx(0, y)]
    case filterType:
    of 0: # None
      copyMem(
        result[unfiteredIdx(0, y)].addr,
        uncompressed[uncompressedIdx(1, y)].unsafeAddr,
        rowBytes
      )
    of 1: # Sub
      let
        uncompressedStartIdx = uncompressedIdx(1, y)
        unfilteredStartIx = unfiteredIdx(0, y)
      for x in 0 ..< rowBytes:
        var value = uncompressed[uncompressedStartIdx + x]
        if x - bpp >= 0:
          value += result[unfilteredStartIx + x - bpp]
        result[unfilteredStartIx + x] = value
    of 2: # Up
      let
        uncompressedStartIdx = uncompressedIdx(1, y)
        unfilteredStartIx = unfiteredIdx(0, y)
      var x: int
      when allowSimd and (defined(amd64) or defined(arm64)):
        if y - 1 >= 0:
          for _ in 0 ..< rowBytes div 16:
            when defined(amd64):
              let
                bytes = mm_loadu_si128(uncompressed[uncompressedStartIdx + x].addr)
                up = mm_loadu_si128(result[unfilteredStartIx + x - rowBytes].addr)
              mm_storeu_si128(
                result[unfilteredStartIx + x].addr,
                mm_add_epi8(bytes, up)
              )
            else: # arm64
              let
                bytes = vld1q_u8(uncompressed[uncompressedStartIdx + x].addr)
                up = vld1q_u8(result[unfilteredStartIx + x - rowBytes].addr)
              vst1q_u8(
                result[unfilteredStartIx + x].addr,
                vaddq_u8(bytes, up)
              )
            x += 16
      for x in x ..< rowBytes:
        var value = uncompressed[uncompressedStartIdx + x]
        if y - 1 >= 0:
          value += result[unfilteredStartIx + x - rowBytes]
        result[unfilteredStartIx + x] = value
    of 3: # Average
      let
        uncompressedStartIdx = uncompressedIdx(1, y)
        unfilteredStartIx = unfiteredIdx(0, y)
      for x in 0 ..< rowBytes:
        var
          value = uncompressed[uncompressedStartIdx + x]
          left, up: uint32
        if x - bpp >= 0:
          left = result[unfilteredStartIx + x - bpp]
        if y - 1 >= 0:
          up = result[unfilteredStartIx + x - rowBytes]
        value += ((left + up) div 2).uint8
        result[unfilteredStartIx + x] = value
    of 4: # Paeth
      let
        uncompressedStartIdx = uncompressedIdx(1, y)
        unfilteredStartIx = unfiteredIdx(0, y)
      for x in 0 ..< rowBytes:
        var
          value = uncompressed[uncompressedStartIdx + x]
          left, up, upLeft: int
        if x - bpp >= 0:
          left = result[unfilteredStartIx + x - bpp].int
        if y - 1 >= 0:
          up = result[unfilteredStartIx + x - rowBytes].int
        if x - bpp >= 0 and y - 1 >= 0:
          upLeft = result[unfilteredStartIx + x - rowBytes - bpp].int
        template paethPredictor(a, b, c: int): int =
          let
            p = a + b - c
            pa = abs(p - a)
            pb = abs(p - b)
            pc = abs(p - c)
          if pa <= pb and pa <= pc:
            a
          elif pb <= pc:
            b
          else:
            c
        value += paethPredictor(up, left, upLeft).uint8
        result[unfilteredStartIx + x] = value
    else:
      discard # Not possible, parseHeader validates

proc decodeImageData(
  data: ptr UncheckedArray[uint8],
  header: PngHeader,
  palette: seq[ColorRGB],
  transparency: string,
  idats: seq[(int, int)]
): seq[ColorRGBA] =
  if idats.len == 0:
    failInvalid()

  result.setLen(header.width * header.height)

  let
    uncompressed =
      if idats.len > 1:
        var imageData: string
        for (start, len) in idats:
          let op = imageData.len
          imageData.setLen(imageData.len + len)
          copyMem(imageData[op].addr, data[start].addr, len)
        try: uncompress(imageData) except ZippyError: failInvalid()
      else:
        let
          (start, len) = idats[0]
          p = data[start].unsafeAddr
        try: uncompress(p, len) except ZippyError: failInvalid()
    valuesPerPixel =
      case header.colorType:
      of 0: 1
      of 2: 3
      of 3: 1
      of 4: 2
      of 6: 4
      else: 0 # Not possible, parseHeader validates
    valuesPerByte = 8 div header.bitDepth.int
    rowBytes = ceil((header.width.int * valuesPerPixel) / valuesPerByte).int
    totalBytes = rowBytes * header.height.int

  # Uncompressed image data should be the total bytes of pixel data plus
  # a filter byte for each row.
  if uncompressed.len != totalBytes + header.height.int:
    failInvalid()

  let unfiltered = unfilter(
    uncompressed.cstring,
    uncompressed.len,
    header.height,
    rowBytes,
    max(valuesPerPixel div valuesPerByte, 1)
  )

  case header.colorType:
  of 0:
    let special = if transparency.len == 2: transparency[1].int else: -1
    var bytePos, bitPos: int
    for y in 0 ..< header.height:
      for x in 0 ..< header.width:
        var value = unfiltered[bytePos]
        case header.bitDepth:
        of 1:
          value = (value shr (7 - bitPos)) and 1
          value *= 255
          inc bitPos
        of 2:
          value = (value shr (6 - bitPos)) and 3
          value *= 85
          inc(bitPos, 2)
        of 4:
          value = (value shr (4 - bitPos)) and 15
          value *= 17
          inc(bitPos, 4)
        of 8:
          inc bytePos
        else:
          discard # Not possible, parseHeader validates

        if bitPos == 8:
          inc bytePos
          bitPos = 0

        let alpha = if value.int == special: 0 else: 255
        result[x + y * header.width] = rgba(value, value, value, alpha.uint8)

      # If we move to a new row, skip to the next full byte
      if bitPos > 0:
        inc bytePos
        bitPos = 0
  of 2:
    var special: ColorRGBA
    if transparency.len == 6: # Need to apply transparency check, slower.
      special.r = transparency.readUint8(1)
      special.g = transparency.readUint8(3)
      special.b = transparency.readUint8(5)
      special.a = 255

      # While we can read an extra byte safely, do so. Much faster.
      for i in 0 ..< header.height * header.width - 1:
        copyMem(result[i].addr, unfiltered[i * 3].unsafeAddr, 4)
        result[i].a = 255
        if result[i] == special:
          result[i].a = 0
    else:
      # While we can read an extra byte safely, do so. Much faster.
      for i in 0 ..< header.height * header.width - 1:
        copyMem(result[i].addr, unfiltered[i * 3].unsafeAddr, 4)
        result[i].a = 255

    let lastOffset = header.height * header.width - 1
    var rgba = rgba(
      unfiltered[lastOffset * 3 + 0].uint8,
      unfiltered[lastOffset * 3 + 1].uint8,
      unfiltered[lastOffset * 3 + 2].uint8,
      255
    )
    if rgba == special:
      rgba.a = 0
    result[header.height * header.width - 1] = rgba
  of 3:
    var bytePos, bitPos: int
    for y in 0 ..< header.height:
      for x in 0 ..< header.width:
        var value = unfiltered[bytePos]
        case header.bitDepth:
        of 1:
          value = (value shr (7 - bitPos)) and 1
          inc bitPos
        of 2:
          value = (value shr (6 - bitPos)) and 3
          inc(bitPos, 2)
        of 4:
          value = (value shr (4 - bitPos)) and 15
          inc(bitPos, 4)
        of 8:
          inc bytePos
        else:
          discard # Not possible, parseHeader validates

        if bitPos == 8:
          inc bytePos
          bitPos = 0
        if value.int >= palette.len:
          failInvalid()

        let
          rgb = palette[value]
          transparency =
            if transparency.len > value.int:
              transparency.readUint8(value.int)
            else:
              255
        result[x + y * header.width] = rgba(rgb.r, rgb.g, rgb.b, transparency)

      # If we move to a new row, skip to the next full byte
      if bitPos > 0:
        inc bytePos
        bitPos = 0
  of 4:
    for i in 0 ..< header.height * header.width:
      let bytePos = i * 2
      result[i] = rgba(
        unfiltered[bytePos],
        unfiltered[bytePos],
        unfiltered[bytePos],
        unfiltered[bytePos + 1]
      )
  of 6:
    copyMem(result[0].addr, unfiltered[0].unsafeAddr, unfiltered.len)
  else:
    discard # Not possible, parseHeader validates

proc newImage*(png: Png): Image {.raises: [PixieError].} =
  ## Creates a new Image from the PNG.
  result = newImage(png.width, png.height)
  copyMem(result.data[0].addr, png.data[0].addr, png.data.len * 4)
  result.data.toPremultipliedAlpha()

proc convertToImage*(png: Png): Image {.raises: [].} =
  ## Converts a PNG into an Image by moving the data. This is faster but can
  ## only be done once.
  type Movable = ref object
    width, height, channels: int
    data: seq[ColorRGBX]

  result = Image()
  result.width = png.width
  result.height = png.height
  result.data = move cast[Movable](png).data
  result.data.toPremultipliedAlpha()

proc decodePngDimensions*(
  data: pointer, len: int
): ImageDimensions {.raises: [PixieError].} =
  ## Decodes the PNG dimensions.
  if len < (8 + (8 + 13 + 4) + 4): # Magic bytes + IHDR + IEND
    failInvalid()

  let data = cast[ptr UncheckedArray[uint8]](data)

  # PNG file signature
  let signature = cast[array[8, uint8]](data.readUint64(0))
  if signature != pngSignature:
    failInvalid()

  # First chunk must be IHDR
  if data.readUint32(8).swap() != 13 or data.readStr(12, 4) != "IHDR":
    failInvalid()

  let header = decodeHeader(data[16].addr)
  result.width = header.width
  result.height = header.height

proc decodePngDimensions*(
  data: string
): ImageDimensions {.inline, raises: [PixieError].} =
  ## Decodes the PNG dimensions.
  decodePngDimensions(data.cstring, data.len)

proc decodePng*(data: pointer, len: int): Png {.raises: [PixieError].} =
  ## Decodes the PNG data.
  if len < (8 + (8 + 13 + 4) + 4): # Magic bytes + IHDR + IEND
    failInvalid()

  let data = cast[ptr UncheckedArray[uint8]](data)

  # PNG file signature
  let signature = cast[array[8, uint8]](data.readUint64(0))
  if signature != pngSignature:
    failInvalid()

  var
    pos = 8 # After signature
    counts = ChunkCounts()
    header: PngHeader
    palette: seq[ColorRGB]
    transparency: string
    idats: seq[(int, int)]
    prevChunkType: string

  # First chunk must be IHDR
  if data.readUint32(pos).swap() != 13 or
    data.readStr(pos + 4, 4) != "IHDR":
    failInvalid()
  inc(pos, 8)
  header = decodeHeader(data[pos].addr)
  prevChunkType = "IHDR"
  inc(pos, 13)

  let headerCrc = crc32(data[pos - 17].addr, 17)
  if headerCrc != data.readUint32(pos).swap():
    failCRC()
  inc(pos, 4) # CRC

  # Not yet supported:
  if header.bitDepth == 16:
    raise newException(PixieError, "PNG 16 bit depth not supported yet")
  if header.interlaceMethod != 0:
    raise newException(PixieError, "Interlaced PNG not supported yet")

  while true:
    if pos + 8 > len:
      failInvalid()

    let
      chunkLen = data.readUint32(pos).swap().int
      chunkType = data.readStr(pos + 4, 4)
    inc(pos, 8)

    if chunkLen > high(int32).int:
      failInvalid()

    if pos + chunkLen + 4 > len:
      failInvalid()

    case chunkType:
    of "IHDR":
      failInvalid()
    of "PLTE":
      inc counts.PLTE
      if counts.PLTE > 1 or counts.IDAT > 0 or counts.tRNS > 0:
        failInvalid()
      palette = decodePalette(data[pos].addr, chunkLen)
    of "tRNS":
      inc counts.tRNS
      if counts.tRNS > 1 or counts.IDAT > 0:
        failInvalid()
      transparency = data.readStr(pos, chunkLen)
      case header.colorType:
      of 0:
        if transparency.len != 2:
          failInvalid()
      of 2:
        if transparency.len != 6:
          failInvalid()
      of 3:
        if transparency.len > palette.len:
          failInvalid()
      else:
        failInvalid()
    of "IDAT":
      inc counts.IDAT
      if counts.IDAT > 1 and prevChunkType != "IDAT":
        failInvalid()
      if header.colorType == 3 and counts.PLTE == 0:
        failInvalid()
      idats.add((pos, chunkLen))
    of "IEND":
      if chunkLen != 0:
        failInvalid()
    else:
      if (chunkType.readUint8(0) and 0b00100000) == 0:
        raise newException(
          PixieError, "Unrecognized PNG critical chunk " & chunkType
        )

    inc(pos, chunkLen)

    let chunkCrc = crc32(data[pos - chunkLen - 4].addr, chunkLen + 4)
    if chunkCrc != data.readUint32(pos).swap():
      failCRC()
    inc(pos, 4) # CRC

    prevChunkType = chunkType

    if pos == len or prevChunkType == "IEND":
      break

  if prevChunkType != "IEND":
    failInvalid()

  result = Png()
  result.width = header.width
  result.height = header.height
  result.channels = 4
  result.data = decodeImageData(data, header, palette, transparency, idats)

proc decodePng*(data: string): Png {.inline, raises: [PixieError].} =
  ## Decodes the PNG data.
  decodePng(data.cstring, data.len)

proc encodePng*(
  width, height, channels: int, data: pointer, len: int
): string {.raises: [PixieError].} =
  ## Encodes the image data into the PNG file format.
  ## If data points to RGBA data, it is assumed to be straight alpha.

  if width <= 0 or width > int32.high.int:
    raise newException(PixieError, "Invalid PNG width")

  if height <= 0 or height > int32.high.int:
    raise newException(PixieError, "Invalid PNG height")

  if len != width * height * channels:
    raise newException(PixieError, "Invalid PNG data size")

  let colorType = case channels:
    of 1: 0.char
    of 2: 4.char
    of 3: 2.char
    of 4: 6.char
    else:
      raise newException(PixieError, "Invalid PNG number of channels")

  let data = cast[ptr UncheckedArray[uint8]](data)

  # Add the PNG file signature
  for c in pngSignature:
    result.add(c.char)

  # Add IHDR
  result.addUint32(13.uint32.swap())
  result.add("IHDR")
  result.addUint32(width.uint32.swap())
  result.addUint32(height.uint32.swap())
  result.add(8.char)
  result.add(colorType)
  result.add(0.char)
  result.add(0.char)
  result.add(0.char)
  result.addUint32(crc32(result[result.len - 17].addr, 17).swap())

  # Add IDAT
  # Add room for 1 byte before each row for the filter type.
  var
    filtered = newString(width * height * channels + height)
    upRow = newSeq[uint8](width * channels)
    subRow = newSeq[uint8](width * channels)
    avgRow = newSeq[uint8](width * channels)
  for y in 0 ..< height:
    let rowStart = y * width * channels
    for x in 0 ..< width * channels:
      # Move through the image data byte-by-byte
      let dataPos = rowStart + x
      var left, up: uint8
      if x - channels >= 0:
        left = data[dataPos - channels]
      if y - 1 >= 0:
        up = data[(y - 1) * width * channels + x]
      upRow[x] = data[dataPos] - up.uint8
      subRow[x] = data[dataPos] - left.uint8
      let avg = ((left.int + up.int) div 2).uint8
      avgRow[x] = data[dataPos] - avg

    var upRowSum, subRowSum, avgRowSum: uint64
    for i in 0 ..< upRow.len:
      upRowSum += upRow[i]
      subRowSum += subRow[i]
      avgRowSum += avgRow[i]

    let minRowSum = min(min(upRowSum, subRowSum), avgRowSum)

    if upRowSum == minRowSum:
      filtered[rowStart + y] = 2.char # Up filter type
      copyMem(
        filtered[rowStart + y + 1].addr,
        upRow[0].addr,
        upRow.len
      )
    elif subRowSum == minRowSum:
      filtered[rowStart + y] = 1.char # Sub filter type
      copyMem(
        filtered[rowStart + y + 1].addr,
        subRow[0].addr,
        subRow.len
      )
    else:
      filtered[rowStart + y] = 3.char # Average filter type
      copyMem(
        filtered[rowStart + y + 1].addr,
        avgRow[0].addr,
        avgRow.len
      )

  let compressed =
    try:
      compress(filtered, DefaultCompression, dfZlib)
    except ZippyError:
      raise newException(
        PixieError, "Unexpected error compressing PNG image data"
      )
  if compressed.len > int32.high.int:
    raise newException(PixieError, "Compressed PNG image data too large")

  result.addUint32(compressed.len.uint32.swap())
  result.add("IDAT")
  result.add(compressed)
  result.addUint32(crc32(
    result[result.len - compressed.len - 4].addr,
    compressed.len + 4
  ).swap())

  # Add IEND
  result.addUint32(0)
  result.add("IEND")
  result.addUint32(crc32(result[result.len - 4].addr, 4).swap())

proc encodePng*(png: Png): string {.raises: [PixieError].} =
  encodePng(png.width, png.height, 4, png.data[0].addr, png.data.len * 4)

proc encodePng*(image: Image): string {.raises: [PixieError].} =
  ## Encodes the image data into the PNG file format.
  if image.data.len == 0:
    raise newException(
      PixieError,
      "Image has no data (are height and width 0?)"
    )
  var copy = image.data
  copy.toStraightAlpha()
  encodePng(image.width, image.height, 4, copy[0].addr, copy.len * 4)

when defined(release):
  {.pop.}



================================================
FILE: src/pixie/fileformats/ppm.nim
================================================
import chroma, flatty/binny, ../common, ../images, std/strutils

# See: http://netpbm.sourceforge.net/doc/ppm.html

const ppmSignatures* = @["P3", "P6"]

type
  PpmHeader = object
    version: string
    width, height, maxVal, dataOffset: int

template failInvalid() =
  raise newException(PixieError, "Invalid PPM data")

proc decodeHeader(
  data: ptr UncheckedArray[uint8], len: int
): PpmHeader {.raises: [PixieError].} =
  var
    commentMode, readWhitespace: bool
    i, readFields: int
    field: string
  while readFields < 4:
    if i >= len:
      raise newException(PixieError, "Invalid PPM file header")
    let c = data[i].char
    if c == '#':
      commentMode = true
    elif c == '\n':
      commentMode = false
    if not commentMode:
      if c in Whitespace and not readWhitespace:
        inc readFields
        readWhitespace = true
        try:
          case readFields:
            of 1:
              result.version = field
            of 2:
              result.width = parseInt(field)
            of 3:
              result.height = parseInt(field)
            of 4:
              result.maxVal = parseInt(field)
            else:
              discard
        except ValueError:
          failInvalid()
        field = ""
      elif not (c in Whitespace):
        field.add(c)
        readWhitespace = false
    inc i

    result.dataOffset = i

proc decodeP6Data(data: string, maxVal: int): seq[ColorRGBX] {.raises: [].} =
  let needsUint16 = maxVal > 0xFF

  result = newSeq[ColorRGBX](
    if needsUint16:
      data.len div 6
    else:
      data.len div 3
  )

  # Let's calculate the real maximum value multiplier.
  # rgbx() accepts a maximum value of 255. Most of the time,
  # maxVal is set to 255 as well, so in most cases it is 1
  let valueMultiplier = (255 / maxVal).float32

  # if comparison in for loops is expensive, so let's unroll it
  if not needsUint16:
    for i in 0 ..< result.len:
      let
        red = data.readUint8(i + (i * 2)).float32
        green = data.readUint8(i + 1 + (i * 2)).float32
        blue = data.readUint8(i + 2 + (i * 2)).float32
      result[i] = rgbx(
        (red * valueMultiplier + 0.5).uint8,
        (green * valueMultiplier + 0.5).uint8,
        (blue * valueMultiplier + 0.5).uint8,
        255
      )
  else:
    for i in 0 ..< result.len:
      let
        red = data.readUint16(i + (i * 5)).swap.float32
        green = data.readUint16(i + 2 + (i * 5)).swap.float32
        blue = data.readUint16(i + 4 + (i * 5)).swap.float32
      result[i] = rgbx(
        (red * valueMultiplier + 0.5).uint8,
        (green * valueMultiplier + 0.5).uint8,
        (blue * valueMultiplier + 0.5).uint8,
        255
      )

proc decodeP3Data(data: string, maxVal: int): seq[ColorRGBX] {.raises: [PixieError].} =
  let
    needsUint16 = maxVal > 0xFF
    maxLen =
      if needsUint16:
        data.splitWhitespace.len * 2
      else:
        data.splitWhitespace.len

  var p6data = newStringOfCap(maxLen)
  try:
    if not needsUint16:
      for line in data.splitLines():
        for sample in line.split('#', 1)[0].splitWhitespace():
          p6data.add(parseInt(sample).char)
    else:
      for line in data.splitLines():
        for sample in line.split('#', 1)[0].splitWhitespace():
          p6data.addUint16(parseInt(sample).uint16.swap)
  except ValueError:
    failInvalid()

  result = decodeP6Data(p6data, maxVal)

proc decodePpm*(data: string): Image {.raises: [PixieError].} =
  ## Decodes Portable Pixel Map data into an Image.

  let header = decodeHeader(
    cast[ptr UncheckedArray[uint8]](data.cstring),
    data.len
  )

  if not (header.version in ppmSignatures):
    failInvalid()

  if 0 > header.maxVal or header.maxVal > 0xFFFF:
    failInvalid()

  result = newImage(header.width, header.height)
  result.data =
    if header.version == "P3":
      decodeP3Data(data[header.dataOffset .. ^1], header.maxVal)
    else:
      decodeP6Data(data[header.dataOffset .. ^1], header.maxVal)

proc decodePpmDimensions*(
  data: pointer, len: int
): ImageDimensions {.raises: [PixieError].} =
  ## Decodes the PPM dimensions.
  let
    data = cast[ptr UncheckedArray[uint8]](data)
    header = decodeHeader(data, len)
  result.width = header.width
  result.height = header.height

proc decodePpmDimensions*(
  data: string
): ImageDimensions {.raises: [PixieError].} =
  ## Decodes the PPM dimensions.
  decodePpmDimensions(data.cstring, data.len)

proc encodePpm*(image: Image): string {.raises: [].} =
  ## Encodes an image into the PPM file format (version P6).

  # PPM header
  result.add("P6") # The header field used to identify the PPM
  result.add("\n") # Newline
  result.add($image.width)
  result.add(" ") # Space
  result.add($image.height)
  result.add("\n") # Newline
  result.add("255") # Max color value
  result.add("\n") # Newline

  # PPM image data
  for y in 0 ..< image.height:
    for x in 0 ..< image.width:
      let rgb = image[x, y]
      # Alpha channel is ignored
      result.addUint8(rgb.r)
      result.addUint8(rgb.g)
      result.addUint8(rgb.b)



================================================
FILE: src/pixie/fileformats/qoi.nim
================================================
import chroma, flatty/binny, ../common, ../images, ../internal

# See: https://qoiformat.org/qoi-specification.pdf

const
  qoiSignature* = "qoif"
  indexLen = 64
  opRgb = 0b11111110'u8
  opRgba = 0b11111111'u8
  opMask2 = 0b11000000'u8
  opIndex = 0b00000000'u8
  opDiff = 0b01000000'u8
  opLuma = 0b10000000'u8
  opRun = 0b11000000'u8

type
  Colorspace* = enum
    sRBG = 0
    Linear = 1

  Qoi* = ref object
    ## Raw QOI image data.
    width*, height*, channels*: int
    colorspace*: Colorspace
    data*: seq[ColorRGBA]

  Index = array[indexLen, ColorRGBA]

proc hash(p: ColorRGBA): int =
  (p.r.int * 3 + p.g.int * 5 + p.b.int * 7 + p.a.int * 11) mod indexLen

proc newImage*(qoi: Qoi): Image =
  ## Creates a new Image from the QOI.
  result = newImage(qoi.width, qoi.height)
  copyMem(result.data[0].addr, qoi.data[0].addr, qoi.data.len * 4)
  result.data.toPremultipliedAlpha()

proc convertToImage*(qoi: Qoi): Image {.raises: [].} =
  ## Converts a QOI into an Image by moving the data. This is faster but can
  ## only be done once.
  type Movable = ref object
    width, height, channels: int
    colorspace: Colorspace
    data: seq[ColorRGBX]

  result = Image()
  result.width = qoi.width
  result.height = qoi.height
  result.data = move cast[Movable](qoi).data
  result.data.toPremultipliedAlpha()

proc decodeQoi*(data: string): Qoi {.raises: [PixieError].} =
  ## Decompress QOI file format data.
  if data.len <= 14 or data[0 .. 3] != qoiSignature:
    raise newException(PixieError, "Invalid QOI header")

  let
    width = data.readUint32(4).swap()
    height = data.readUint32(8).swap()
    channels = data.readUint8(12)
    colorspace = data.readUint8(13)

  if channels notin {3'u8, 4} or colorspace notin {0'u8, 1}:
    raise newException(PixieError, "Invalid QOI header")

  if width.int * height.int > uint32.high.int64:
    raise newException(PixieError, "QOI is too large to decode")

  result = Qoi()
  result.width = width.int
  result.height = height.int
  result.channels = channels.int
  result.colorspace = colorspace.Colorspace
  result.data.setLen(result.width * result.height)

  var
    index: Index
    p = 14
    run: uint8
    px = rgba(0, 0, 0, 255)
  for dst in result.data.mitems:
    if p > data.len - 8:
      raise newException(PixieError, "Underrun of QOI decoder")

    if run > 0:
      dec run
    else:
      let b0 = data.readUint8(p)
      inc p

      case b0:
      of opRgb:
        px.r = data.readUint8(p + 0)
        px.g = data.readUint8(p + 1)
        px.b = data.readUint8(p + 2)
        p += 3
      of opRgba:
        px.r = data.readUint8(p + 0)
        px.g = data.readUint8(p + 1)
        px.b = data.readUint8(p + 2)
        px.a = data.readUint8(p + 3)
        p += 4
      else:
        case b0 and opMask2:
        of opIndex:
          px = index[b0]
        of opDiff:
          px.r = px.r + ((b0 shr 4) and 0x03).uint8 - 2
          px.g = px.g + ((b0 shr 2) and 0x03).uint8 - 2
          px.b = px.b + ((b0 shr 0) and 0x03).uint8 - 2
        of opLuma:
          let
            b1 = data.readUint8(p)
            vg = (b0.uint8 and 0x3f) - 32
          px.r = px.r + vg - 8 + ((b1 shr 4) and 0x0f)
          px.g = px.g + vg
          px.b = px.b + vg - 8 + ((b1 shr 0) and 0x0f)
          inc p
        of opRun:
          run = b0 and 0x3f
        else:
          raise newException(PixieError, "Unexpected QOI op")

      index[hash(px)] = px

    dst = px

  while p < data.len:
    case data[p]:
    of '\0':
      discard
    of '\1':
      break # ignore trailing data
    else:
      raise newException(PixieError, "Invalid QOI padding")
    inc(p)

proc decodeQoiDimensions*(
  data: pointer, len: int
): ImageDimensions {.raises: [PixieError].} =
  ## Decodes the QOI dimensions.
  if len <= 12 or not equalMem(data, qoiSignature.cstring, 4):
    raise newException(PixieError, "Invalid QOI header")

  let data = cast[ptr UncheckedArray[uint8]](data)

  result.width = data.readUint32(4).swap().int
  result.height = data.readUint32(8).swap().int

proc decodeQoiDimensions*(
  data: string
): ImageDimensions {.raises: [PixieError].} =
  ## Decodes the QOI dimensions.
  decodeQoiDimensions(data.cstring, data.len)

proc encodeQoi*(qoi: Qoi): string {.raises: [PixieError].} =
  ## Encodes raw QOI pixels to the QOI file format.

  if qoi.width.int * qoi.height.int > uint32.high.int64:
    raise newException(PixieError, "QOI is too large to encode")

  # Allocate a buffer 3/4 the size of the pathological encoding
  result = newStringOfCap(14 + 8 + qoi.data.len * 3)

  result.add(qoiSignature)
  result.addUint32(qoi.width.uint32.swap())
  result.addUint32(qoi.height.uint32.swap())
  result.addUint8(qoi.channels.uint8)
  result.addUint8(qoi.colorspace.uint8)

  var
    index: Index
    run: uint8
    pxPrev = rgba(0, 0, 0, 255)
  for off, px in qoi.data:
    if px == pxPrev:
      inc run
      if run == 62 or off == qoi.data.high:
        result.addUint8(opRun or (run - 1))
        run = 0
    else:
      if run > 0:
        result.addUint8(opRun or (run - 1))
        run = 0

      let i = hash(px)
      if index[i] == px:
        result.addUint8(opIndex or uint8(i))
      else:
        index[i] = px
        if px.a == pxPrev.a:
          let
            vr = px.r.int - pxPrev.r.int
            vg = px.g.int - pxPrev.g.int
            vb = px.b.int - pxPrev.b.int
            vgr = vr - vg
            vgb = vb - vg
          if (vr > -3) and (vr < 2) and
              (vg > -3) and (vg < 2) and
              (vb > -3) and (vb < 2):
            let b = opDiff or
              (((vr + 2) shl 4) or ((vg + 2) shl 2) or ((vb + 2) shl 0)).uint8
            result.addUint8(b)
          elif vgr > -9 and vgr < 8 and
              vg > -33 and vg < 32 and
              vgb > -9 and vgb < 8:
            result.addUint8(opLuma or (vg + 32).uint8)
            result.addUint8((((vgr + 8) shl 4) or (vgb + 8)).uint8)
          else:
            result.addUint8(opRgb)
            result.addUint8(px.r)
            result.addUint8(px.g)
            result.addUint8(px.b)
        else:
          result.addUint8(opRgba)
          result.addUint8(px.r)
          result.addUint8(px.g)
          result.addUint8(px.b)
          result.addUint8(px.a)

      pxPrev = px

  for _ in 0 .. 6:
    result.addUint8(0x00)

  result.addUint8(0x01)

proc encodeQoi*(image: Image): string {.raises: [PixieError].} =
  ## Encodes an image to the QOI file format.
  let qoi = Qoi()
  qoi.width = image.width
  qoi.height = image.height
  qoi.channels = 4
  qoi.data.setLen(image.data.len)

  copyMem(qoi.data[0].addr, image.data[0].addr, image.data.len * 4)
  qoi.data.toStraightAlpha()

  encodeQoi(qoi)



================================================
FILE: src/pixie/fileformats/svg.nim
================================================
## Load SVG files.

import chroma, ../common, ../images, ../internal, ../paints,
    ../paths, strutils, tables, vmath, xmlparser, xmltree

when defined(pixieDebugSvg):
  import strtabs

const
  xmlSignature* = "<?xml"
  svgSignature* = "<svg"

type
  Svg* = ref object
    width*, height*: int
    elements: seq[(Path, SvgProperties)]
    linearGradients: Table[string, LinearGradient]

  SvgProperties = object
    display: bool
    fillRule: WindingRule
    fill: string
    stroke: ColorRGBX
    strokeWidth: float32
    strokeLineCap: LineCap
    strokeLineJoin: LineJoin
    strokeMiterLimit: float32
    strokeDashArray: seq[float32]
    transform: Mat3
    opacity, fillOpacity, strokeOpacity: float32

  LinearGradient = object
    x1, y1, x2, y2: float32
    stops: seq[ColorStop]

template failInvalid() =
  raise newException(PixieError, "Invalid SVG data")

proc attrOrDefault(node: XmlNode, name, default: string): string =
  result = node.attr(name)
  if result.len == 0:
    result = default

proc initSvgProperties(): SvgProperties =
  result.display = true
  result.fill = "black"
  result.strokeWidth = 1
  result.transform = mat3()
  result.strokeMiterLimit = defaultMiterLimit
  result.opacity = 1
  result.fillOpacity = 1
  result.strokeOpacity = 1

proc parseSvgProperties(node: XmlNode, inherited: SvgProperties): SvgProperties =
  result = inherited

  proc splitArgs(s: string): seq[string] =
    # Handles (1,1) or (1 1) or (1, 1) or (1,1 2,2) etc
    let tmp = s.replace(',', ' ').split(' ')
    for entry in tmp:
      if entry.len > 0:
        result.add(entry)

  var
    fillRule = node.attr("fill-rule")
    fill = node.attr("fill")
    stroke = node.attr("stroke")
    strokeWidth = node.attr("stroke-width")
    strokeLineCap = node.attr("stroke-linecap")
    strokeLineJoin = node.attr("stroke-linejoin")
    strokeMiterLimit = node.attr("stroke-miterlimit")
    strokeDashArray = node.attr("stroke-dasharray")
    transform = node.attr("transform")
    style = node.attr("style")
    display = node.attr("display")
    opacity = node.attr("opacity")
    fillOpacity = node.attr("fill-opacity")
    strokeOpacity = node.attr("stroke-opacity")

  when defined(pixieDebugSvg):
    proc maybeLogPair(k, v: string) =
      if k notin [
          "fill-rule", "fill", "stroke", "stroke-width", "stroke-linecap",
          "stroke-linejoin", "stroke-miterlimit", "stroke-dasharray",
          "transform", "style", "version", "viewBox", "width", "height",
          "xmlns", "x", "y", "x1", "x2", "y1", "y2", "id", "d", "cx", "cy",
          "r", "points", "rx", "ry", "enable-background", "xml:space",
          "xmlns:xlink", "data-name", "role", "class", "opacity",
          "fill-opacity", "stroke-opacity"
        ]:
          echo k, ": ", v

    if node.attrs() != nil:
      for k, v in node.attrs():
        maybeLogPair(k, v)

  let pairs = style.split(';')
  for pair in pairs:
    let parts = pair.split(':')
    if parts.len == 2:
      # Do not override element properties
      case parts[0].strip():
      of "fill-rule":
        if fillRule.len == 0:
          fillRule = parts[1].strip()
      of "fill":
        if fill.len == 0:
          fill = parts[1].strip()
      of "stroke":
        if stroke.len == 0:
          stroke = parts[1].strip()
      of "stroke-linecap":
        if strokeLineCap.len == 0:
          strokeLineCap = parts[1].strip()
      of "stroke-linejoin":
        if strokeLineJoin.len == 0:
          strokeLineJoin = parts[1].strip()
      of "stroke-width":
        if strokeWidth.len == 0:
          strokeWidth = parts[1].strip()
      of "stroke-miterlimit":
        if strokeMiterLimit.len == 0:
          strokeMiterLimit = parts[1].strip()
      of "stroke-dasharray":
        if strokeDashArray.len == 0:
          strokeDashArray = parts[1].strip()
      of "display":
        if display.len == 0:
          display = parts[1].strip()
      of "opacity":
        if opacity.len == 0:
          opacity = parts[1].strip()
      of "fillOpacity":
        if fillOpacity.len == 0:
          fillOpacity = parts[1].strip()
      of "strokeOpacity":
        if strokeOpacity.len == 0:
          strokeOpacity = parts[1].strip()
      else:
        when defined(pixieDebugSvg):
          maybeLogPair(parts[0], parts[1])
    elif pair.len > 0:
      when defined(pixieDebugSvg):
        echo "Invalid style pair: ", pair

  if display.len > 0:
    result.display = display.strip() != "none"

  if opacity.len > 0:
    result.opacity = clamp(parseFloat(opacity), 0, 1)

  if fillRule == "":
    discard # Inherit
  elif fillRule == "nonzero":
    result.fillRule = NonZero
  elif fillRule == "evenodd":
    result.fillRule = EvenOdd
  else:
    raise newException(
      PixieError, "Invalid fill-rule value " & fillRule
    )

  if fill == "" or fill == "currentColor":
    result.fill = inherited.fill
  else:
    result.fill = fill

  if stroke == "":
    discard # Inherit
  elif stroke == "currentColor":
    if result.stroke == rgbx(0, 0, 0, 0):
      result.stroke = rgbx(0, 0, 0, 255)
  elif stroke == "none":
    result.stroke = ColorRGBX()
  else:
    result.stroke = parseHtmlColor(stroke).rgbx

  if fillOpacity.len > 0:
    result.fillOpacity = parseFloat(fillOpacity).clamp(0, 1)

  if strokeOpacity.len > 0:
    result.strokeOpacity = parseFloat(strokeOpacity).clamp(0, 1)

  if strokeWidth == "":
    discard # Inherit
  else:
    if strokeWidth.endsWith("px"):
      strokeWidth = strokeWidth[0 .. ^3]
    result.strokeWidth = parseFloat(strokeWidth)
    if result.stroke == rgbx(0, 0, 0, 0):
      result.stroke = rgbx(0, 0, 0, 255)

  if strokeLineCap == "":
    discard # Inherit
  else:
    case strokeLineCap:
    of "butt":
      result.strokeLineCap = ButtCap
    of "round":
      result.strokeLineCap = RoundCap
    of "square":
      result.strokeLineCap = SquareCap
    of "inherit":
      discard
    else:
      raise newException(
        PixieError, "Invalid stroke-linecap value " & strokeLineCap
      )

  if strokeLineJoin == "":
    discard # Inherit
  else:
    case strokeLineJoin:
    of "miter":
      result.strokeLineJoin = MiterJoin
    of "round":
      result.strokeLineJoin = RoundJoin
    of "bevel":
      result.strokeLineJoin = BevelJoin
    of "inherit":
      discard
    else:
      raise newException(
        PixieError, "Invalid stroke-linejoin value " & strokeLineJoin
      )

  if strokeMiterLimit == "":
    discard
  else:
    result.strokeMiterLimit = parseFloat(strokeMiterLimit)

  if strokeDashArray == "":
    discard
  else:
    var values = splitArgs(strokeDashArray)
    for value in values:
      result.strokeDashArray.add(parseFloat(value))

  if transform == "":
    discard # Inherit
  else:
    template failInvalidTransform(transform: string) =
      raise newException(
          PixieError, "Unsupported SVG transform: " & transform
        )

    var remaining = transform
    while remaining.len > 0:
      let index = remaining.find(")")
      if index == -1:
        failInvalidTransform(transform)
      let f = remaining[0 .. index].strip()
      remaining = remaining[index + 1 .. ^1]

      if f.startsWith("matrix("):
        let arr = splitArgs(f[7 .. ^2])
        if arr.len != 6:
          failInvalidTransform(transform)
        var m = mat3()
        m[0, 0] = parseFloat(arr[0])
        m[0, 1] = parseFloat(arr[1])
        m[1, 0] = parseFloat(arr[2])
        m[1, 1] = parseFloat(arr[3])
        m[2, 0] = parseFloat(arr[4])
        m[2, 1] = parseFloat(arr[5])
        result.transform = result.transform * m
      elif f.startsWith("translate("):
        let
          components = splitArgs(f[10 .. ^2])
          tx = parseFloat(components[0])
          ty =
            if components.len == 1:
              0.0
            else:
              parseFloat(components[1])
        result.transform = result.transform * translate(vec2(tx, ty))
      elif f.startsWith("rotate("):
        let
          values = splitArgs(f[7 .. ^2])
          angle: float32 = parseFloat(values[0]) * -PI / 180
        var cx, cy: float32
        if values.len > 1:
          cx = parseFloat(values[1])
        if values.len > 2:
          cy = parseFloat(values[2])
        let center = vec2(cx, cy)
        result.transform = result.transform *
          translate(center) * rotate(angle) * translate(-center)
      elif f.startsWith("scale("):
        let
          values = splitArgs(f[6 .. ^2])
          sx: float32 = parseFloat(values[0])
          sy: float32 =
            if values.len > 1:
              parseFloat(values[1])
            else:
              sx
        result.transform = result.transform * scale(vec2(sx, sy))
      else:
        failInvalidTransform(transform)

proc parseSvgElement(
  node: XmlNode, svg: Svg, propertiesStack: var seq[SvgProperties]
): seq[(Path, SvgProperties)] =
  if node.kind != xnElement:
    # Skip <!-- comments -->
    return

  case node.tag:
  of "title", "desc":
    discard

  of "defs":
    when defined(pixieDebugSvg):
      echo node

  of "g":
    let props = node.parseSvgProperties(propertiesStack[^1])
    propertiesStack.add(props)
    for child in node:
      result.add child.parseSvgElement(svg, propertiesStack)
    discard propertiesStack.pop()

  of "path":
    let
      d = node.attr("d")
      props = node.parseSvgProperties(propertiesStack[^1])
      path = parsePath(d)

    result.add (path, props)

  of "line":
    let
      props = node.parseSvgProperties(propertiesStack[^1])
      x1 = parseFloat(node.attrOrDefault("x1", "0"))
      y1 = parseFloat(node.attrOrDefault("y1", "0"))
      x2 = parseFloat(node.attrOrDefault("x2", "0"))
      y2 = parseFloat(node.attrOrDefault("y2", "0"))

    let path = newPath()
    path.moveTo(x1, y1)
    path.lineTo(x2, y2)

    result.add (path, props)

  of "polyline", "polygon":
    let
      props = node.parseSvgProperties(propertiesStack[^1])
      points = node.attr("points")

    var vecs: seq[Vec2]
    if points.contains(","):
      for pair in points.split(" "):
        let parts = pair.split(",")
        if parts.len != 2:
          failInvalid()
        vecs.add(vec2(parseFloat(parts[0]), parseFloat(parts[1])))
    else:
      let points = points.split(" ")
      if points.len mod 2 != 0:
        failInvalid()
      for i in 0 ..< points.len div 2:
        vecs.add(vec2(parseFloat(points[i * 2]), parseFloat(points[i * 2 + 1])))

    if vecs.len == 0:
      failInvalid()

    let path = newPath()
    path.moveTo(vecs[0])
    for i in 1 ..< vecs.len:
      path.lineTo(vecs[i])

    # The difference between polyline and polygon is whether we close the path
    # and fill or not
    if node.tag == "polygon":
      path.closePath()

    result.add (path, props)

  of "rect":
    let
      props = node.parseSvgProperties(propertiesStack[^1])
      x = parseFloat(node.attrOrDefault("x", "0"))
      y = parseFloat(node.attrOrDefault("y", "0"))
      width = parseFloat(node.attrOrDefault("width", "0"))
      height = parseFloat(node.attrOrDefault("height", "0"))

    if width == 0 or height == 0:
      return

    var
      rx = max(parseFloat(node.attrOrDefault("rx", "0")), 0)
      ry = max(parseFloat(node.attrOrDefault("ry", "0")), 0)

    let path = newPath()
    if rx > 0 or ry > 0:
      if rx == 0:
        rx = ry
      elif ry == 0:
        ry = rx
      rx = min(rx, width / 2)
      ry = min(ry, height / 2)

      path.moveTo(x + rx, y)
      path.lineTo(x + width - rx, y)
      path.ellipticalArcTo(rx, ry, 0, false, true, x + width, y + ry)
      path.lineTo(x + width, y + height - ry)
      path.ellipticalArcTo(rx, ry, 0, false, true, x + width - rx, y + height)
      path.lineTo(x + rx, y + height)
      path.ellipticalArcTo(rx, ry, 0, false, true, x, y + height - ry)
      path.lineTo(x, y + ry)
      path.ellipticalArcTo(rx, ry, 0, false, true, x + rx, y)
    else:
      path.rect(x, y, width, height)

    result.add (path, props)

  of "circle", "ellipse":
    let
      props = node.parseSvgProperties(propertiesStack[^1])
      cx = parseFloat(node.attrOrDefault("cx", "0"))
      cy = parseFloat(node.attrOrDefault("cy", "0"))

    var rx, ry: float32
    if node.tag == "circle":
      rx = parseFloat(node.attr("r"))
      ry = rx
    else:
      rx = parseFloat(node.attrOrDefault("rx", "0"))
      ry = parseFloat(node.attrOrDefault("ry", "0"))

    let path = newPath()
    path.ellipse(cx, cy, rx, ry)

    result.add (path, props)

  of "radialGradient":
    discard

  of "linearGradient":
    let
      props = node.parseSvgProperties(propertiesStack[^1])
      id = node.attr("id")
      gradientUnits = node.attr("gradientUnits")
      gradientTransform = node.attr("gradientTransform")

    if gradientUnits != "userSpaceOnUse":
      raise newException(
        PixieError, "Unsupported gradient units: " & gradientUnits
      )
    if gradientTransform != "":
      raise newException(
        PixieError, "Unsupported gradient transform: " & gradientTransform
      )

    var linearGradient: LinearGradient
    linearGradient.x1 = parseFloat(node.attr("x1"))
    linearGradient.y1 = parseFloat(node.attr("y1"))
    linearGradient.x2 = parseFloat(node.attr("x2"))
    linearGradient.y2 = parseFloat(node.attr("y2"))

    for child in node:
      if child.tag == "stop":
        var color = child.attr("stop-color")

        if color == "":
          let
            style = child.attr("style")
            pairs = style.split(';')
          for pair in pairs:
            let parts = pair.split(':')
            if parts.len == 2:
              # Do not override element properties
              case parts[0].strip():
              of "stop-color":
                if color == "":
                  color = parts[1].strip()
              else:
                when defined(pixieDebugSvg):
                  maybeLogPair(parts[0], parts[1])
            elif pair.len > 0:
              when defined(pixieDebugSvg):
                echo "Invalid style pair: ", pair

        if color == "":
          raise newException(
            PixieError, "Invalid SVG gradient, missing stop-color"
          )

        linearGradient.stops.add(ColorStop(
          color: color.parseHtmlColor(),
          position: parseFloat(child.attr("offset"))
        ))
      else:
        raise newException(PixieError, "Unexpected SVG tag: " & child.tag)

    svg.linearGradients[id] = linearGradient

  else:
    raise newException(PixieError, "Unsupported SVG tag: " & node.tag)

proc parseSvg*(
  root: XmlNode, width = 0, height = 0
): Svg {.raises: [PixieError].} =
  ## Parse SVG XML. Defaults to the SVG's view box size.
  try:
    if root.tag != "svg":
      failInvalid()

    let
      viewBox = root.attr("viewBox")
      box = viewBox.split(" ")
      viewBoxMinX = parseInt(box[0])
      viewBoxMinY = parseInt(box[1])
      viewBoxWidth = parseInt(box[2])
      viewBoxHeight = parseInt(box[3])

    var rootProps = initSvgProperties()
    rootProps = root.parseSvgProperties(rootProps)

    if viewBoxMinX != 0 or viewBoxMinY != 0:
      let viewBoxMin = vec2(-viewBoxMinX.float32, -viewBoxMinY.float32)
      rootProps.transform = rootProps.transform * translate(viewBoxMin)

    result = Svg()

    if width == 0 and height == 0: # Default to the view box size
      result.width = viewBoxWidth
      result.height = viewBoxHeight
    else:
      result.width = width
      result.height = height

      let
        scaleX = width.float32 / viewBoxWidth.float32
        scaleY = height.float32 / viewBoxHeight.float32
      rootProps.transform = rootProps.transform * scale(vec2(scaleX, scaleY))

    var propertiesStack = @[rootProps]
    for node in root.items:
      result.elements.add node.parseSvgElement(result, propertiesStack)
  except PixieError as e:
    raise e
  except:
    raise currentExceptionAsPixieError()

proc parseSvg*(data: string, width = 0, height = 0): Svg {.raises: [PixieError].} =
  ## Parse SVG data. Defaults to the SVG's view box size.
  try:
    let root = parseXml(data)
    result = root.parseSvg(width, height)
  except PixieError as e:
    raise e
  except:
    raise currentExceptionAsPixieError()

proc newImage*(svg: Svg): Image {.raises: [PixieError].} =
  ## Render SVG and return the image.
  result = newImage(svg.width, svg.height)

  try:
    var blendMode = OverwriteBlend # Start as overwrite
    for (path, props) in svg.elements:
      if props.display and props.opacity > 0:
        if props.fill != "none":
          var paint: Paint
          if props.fill.startsWith("url("):
            let closingParen = props.fill.find(")", 5)
            if closingParen == -1:
              raise newException(PixieError, "Malformed fill: " & props.fill)
            let id = props.fill[5 .. closingParen - 1]
            if id in svg.linearGradients:
              let linearGradient = svg.linearGradients[id]
              paint = newPaint(LinearGradientPaint)
              paint.gradientHandlePositions = @[
                props.transform * vec2(linearGradient.x1, linearGradient.y1),
                props.transform * vec2(linearGradient.x2, linearGradient.y2)
              ]
              paint.gradientStops = linearGradient.stops
            else:
              raise newException(PixieError, "Missing SVG resource " & id)
          else:
            paint = parseHtmlColor(props.fill).rgbx

          paint.opacity = props.fillOpacity * props.opacity
          paint.blendMode = blendMode

          result.fillPath(path, paint, props.transform, props.fillRule)

        blendMode = NormalBlend # Switch to normal when compositing multiple paths

        if props.stroke != rgbx(0, 0, 0, 0) and props.strokeWidth > 0:
          let paint = props.stroke.copy()
          paint.color.a *= (props.opacity * props.strokeOpacity)
          result.strokePath(
            path,
            paint,
            props.transform,
            props.strokeWidth,
            props.strokeLineCap,
            props.strokeLineJoin,
            miterLimit = props.strokeMiterLimit,
            dashes = props.strokeDashArray
          )
  except PixieError as e:
    raise e
  except:
    raise currentExceptionAsPixieError()



================================================
FILE: src/pixie/fileformats/tiff.nim
================================================
import chroma, flatty/binny, ../common, ../images, ../internal

const
  tiffSignatures* = [
    [0x4d.uint8, 0x4d, 0x00, 0x2a],
    [0x49.uint8, 0x49, 0x2a, 0x00]
  ]
  knownTags = [
    0x0100.uint16, # ImageWidth
    0x0101,        # ImageLength
    0x0102,        # BitsPerSample
    0x0103,        # Compression
    0x0106,        # PhotometricInterpretation
    0x0111,        # StripOffsets
    0x0116,        # RowsPerStrip
    0x0117,        # StripByteCounts
    0x0140,        # ColorMap
  ]

type
  Tiff* = ref object
    width*, height*: int
    data*: seq[ColorRGBA]

template failInvalid() =
  raise newException(PixieError, "Invalid TIFF buffer, unable to load")

proc decodeTiff*(data: string): Tiff =
  if data.len < 8:
    failInvalid()

  result = Tiff()

  var
    pos: int
    isBigEndian: bool
    bitsPerSample: seq[int]
    compression: int
    photometricInterpretation: int
    stripOffsets, stripByteCounts: seq[int]
    rowsPerStrip: int
    colorMap: seq[ColorRGBA]

  let signature = cast[array[4, uint8]](data.readUint32(0))
  if signature == tiffSignatures[0]:
    isBigEndian = true
  elif signature == tiffSignatures[1]:
    discard
  else:
    failInvalid()

  pos = 4

  let ifdOffset = data.readUint32(pos).maybeSwap(isBigEndian).int
  pos = ifdOffset # Move to the first IFD offset

  if pos + 2 > data.len:
    failInvalid()

  let numEntries = data.readUint16(pos).maybeSwap(isBigEndian).int
  pos += 2

  for _ in 0 ..< numEntries:
    if pos + 12 > data.len:
      failInvalid()

    let
      tag = data.readUint16(pos + 0).maybeSwap(isBigEndian)
      fieldType = data.readUint16(pos + 2).maybeSwap(isBigEndian)
      numValues = data.readUint32(pos + 4).maybeSwap(isBigEndian).int
      valueOrOffset = pos + 8

    pos += 12

    if tag notin knownTags:
      continue

    let bytesPerValue =
      case fieldType:
      of 1:
        1
      of 2:
        1
      of 3:
        2
      of 4:
        4
      else:
        raise newException(PixieError, "Unsupported field type " & $fieldType)

    var valueOffset =
      if numValues * bytesPerValue <= 4:
        valueOrOffset
      else:
        data.readUint32(valueOrOffset).maybeSwap(isBigEndian).int

    proc readValue(offset: int): int =
      case fieldType:
      of 1:
        if offset + 1 > data.len:
          failInvalid()
        data.readUint8(offset).maybeSwap(isBigEndian).int
      of 3:
        if offset + 2 > data.len:
          failInvalid()
        data.readUint16(offset).maybeSwap(isBigEndian).int
      of 4:
        if offset + 4 > data.len:
          failInvalid()
        data.readUint32(offset).maybeSwap(isBigEndian).int
      else:
        raise newException(PixieError, "Unsupported field type " & $fieldType)

    case tag:
    of knownTags[0]:
      if numValues != 1:
        failInvalid()
      result.width = readValue(valueOffset)
    of knownTags[1]:
      if numValues != 1:
        failInvalid()
      result.height = readValue(valueOffset)
    of knownTags[2]:
      for _ in 0 ..< numValues:
        bitsPerSample.add(readValue(valueOffset))
        valueOffset += bytesPerValue
    of knownTags[3]:
      if numValues != 1:
        failInvalid()
      compression = readValue(valueOffset)
    of knownTags[4]:
      if numValues != 1:
        failInvalid()
      photometricInterpretation = readValue(valueOffset)
    of knownTags[5]:
      for _ in 0 ..< numValues:
        stripOffsets.add(readValue(valueOffset))
        valueOffset += bytesPerValue
    of knownTags[6]:
      if numValues != 1:
        failInvalid()
      rowsPerStrip = readValue(valueOffset)
    of knownTags[7]:
      for _ in 0 ..< numValues:
        stripByteCounts.add(readValue(valueOffset))
        valueOffset += bytesPerValue
    of knownTags[8]:
      if fieldType != 3:
        failInvalid()
      var values: seq[int]
      for _ in 0 ..< numValues:
        values.add(readValue(valueOffset))
        valueOffset += bytesPerValue
      colorMap.setLen(numValues div 3)
      for i in 0 ..< colorMap.len:
        colorMap[i] = rgba(
          ((values[i].float32 / 65535) * 255).uint8,
          ((values[i + colorMap.len].float32 / 65535) * 255).uint8,
          ((values[i + 2 * colorMap.len].float32 / 65535) * 255).uint8,
          255
        )
    else:
      discard

  if result.width == 0 or result.height == 0:
    failInvalid()

  if stripOffsets.len != stripByteCounts.len:
    failInvalid()

  if bitsPerSample.len == 0:
    failInvalid()

  for i, bits in bitsPerSample:
    if bits notin {8}:
      raise newException(
        PixieError,
        "TIFF bits per sample of " & $bits & " not supported yet"
      )

  # Check the bits per sample are all equal
  for i in 0 ..< bitsPerSample.len:
    for j in 0 ..< bitsPerSample.len:
      if bitsPerSample[i] != bitsPerSample[j]:
        failInvalid()

  var decompressed: string
  case compression:
  of 1: # No compression
    var stripDataLen: int
    for byteCount in stripByteCounts:
      stripDataLen += byteCount

    decompressed.setLen(stripDataLen)

    var at: int
    for i, offset in stripOffsets:
      let byteCount = stripByteCounts[i]
      if offset + byteCount > data.len:
        failInvalid()
      copyMem(decompressed[at].addr, data[offset].unsafeAddr, byteCount)
      at += byteCount

  # of 5: # LZW

  else:
    raise newException(
      PixieError,
      "TIFF compression " & $compression & " not supported yet"
    )

  result.data.setLen(result.width * result.height)

  case photometricInterpretation:
  of 2: # RGB
    if bitsPerSample.len == 4: # 32 bit RGBA
      raise newException(PixieError, "RGBA TIFF not supported yet")
    elif bitsPerSample.len == 3: # 24 bit RGB
      if decompressed.len div 3 != result.data.len:
        failInvalid()
      for i in 0 ..< result.data.len:
        let decompressedIdx = i * 3
        result.data[i] = rgba(
          decompressed[decompressedIdx + 0].uint8,
          decompressed[decompressedIdx + 1].uint8,
          decompressed[decompressedIdx + 2].uint8,
          255
        )
    else:
      failInvalid()

  of 3: # Color Map
    if decompressed.len != result.data.len:
      failInvalid()
    for i in 0 ..< result.data.len:
      let colorMapIndex = decompressed[i].int
      if colorMapIndex > colorMap.len:
        failInvalid()
      result.data[i] = colorMap[colorMapIndex]

  else:
    raise newException(
      PixieError,
      "TIFF photometric interpretation " & $photometricInterpretation &
      " not supported yet"
    )

proc newImage*(tiff: Tiff): Image =
  result = newImage(tiff.width, tiff.height)
  copyMem(result.data[0].addr, tiff.data[0].addr, tiff.data.len * 4)
  result.data.toPremultipliedAlpha()

proc convertToImage*(tiff: Tiff): Image {.raises: [].} =
  ## Converts a PNG into an Image by moving the data. This is faster but can
  ## only be done once.
  type Movable = ref object
    width, height, channels: int
    data: seq[ColorRGBX]

  result = Image()
  result.width = tiff.width
  result.height = tiff.height
  result.data = move cast[Movable](tiff).data
  result.data.toPremultipliedAlpha()



================================================
FILE: src/pixie/fontformats/svgfont.nim
================================================
import ../common, ../internal, ../paths, strutils, tables, unicode,
    vmath, xmlparser, xmltree

type SvgFont* = ref object
  unitsPerEm*, ascent*, descent*: float32
  advances: Table[Rune, float32]
  glyphPaths: Table[Rune, Path]
  kerningPairs: Table[(Rune, Rune), float32]
  missingGlyphAdvance: float32
  missingGlyphPath: Path

proc getGlyphPath*(svgFont: SvgFont, rune: Rune): Path {.raises: [].} =
  svgFont.glyphPaths.getOrDefault(rune, svgFont.missingGlyphPath)

proc hasGlyph*(svgFont: SvgFont, rune: Rune): bool =
  rune in svgFont.glyphPaths

proc getAdvance*(svgFont: SvgFont, rune: Rune): float32 {.raises: [].} =
  svgFont.advances.getOrDefault(rune, svgFont.missingGlyphAdvance)

proc getKerningAdjustment*(
  svgFont: SvgFont, left, right: Rune
): float32 {.raises: [].} =
  let pair = (left, right)
  result = svgFont.kerningPairs.getOrDefault(pair, 0)

template failInvalid() =
  raise newException(PixieError, "Invalid SVG font data")

proc parseFloat(node: XmlNode, attr: string): float32 =
  let value = node.attr(attr)
  if value.len == 0:
    raise newException(PixieError, "SVG font missing attr " & attr)
  try:
    result = parseFloat(value)
  except:
    failInvalid()

proc parseSvgFont*(buf: string): SvgFont {.raises: [PixieError].} =
  result = SvgFont()

  let root =
    try:
      parseXml(buf)
    except:
      raise currentExceptionAsPixieError()

  let defs = root.child("defs")
  if defs == nil:
    failInvalid()

  let font = defs.child("font")
  if font == nil:
    failInvalid()

  let defaultAdvance = font.parseFloat("horiz-adv-x")

  for node in font.items:
    case node.tag:
      of "font-face":
        result.unitsPerEm = node.parseFloat("units-per-em")
        result.ascent = node.parseFloat("ascent")
        result.descent = node.parseFloat("descent")
      of "glyph":
        let
          name = node.attr("glyph-name")
          unicode = node.attr("unicode")
        if unicode.len > 0 or name == "space":
          var
            i: int
            rune: Rune
          if name == "space":
            rune = Rune(32)
          else:
            fastRuneAt(unicode, i, rune, true)
          if i == unicode.len:
            var advance = defaultAdvance
            if node.attr("horiz-adv-x").len > 0:
              advance = node.parseFloat("horiz-adv-x")
            result.advances[rune] = advance
            let path = parsePath(node.attr("d"))
            path.transform(scale(vec2(1, -1)))
            result.glyphPaths[rune] = path
          else:
            discard # Multi-rune unicode?
      of "hkern":
        # TODO "g" kerning
        let
          u1 = node.attr("u1")
          u2 = node.attr("u2")
        if u1.len > 0 and u2.len > 0:
          var
            i1, i2: int
            left, right: Rune
          fastRuneAt(u1, i1, left, true)
          fastRuneAt(u2, i2, right, true)
          if i1 == u1.len and i2 == u2.len:
            let adjustment = -node.parseFloat("k")
            result.kerningPairs[(left, right)] = adjustment
          else:
            discard # Multi-rune unicode?
      of "missing-glyph":
        var advance = defaultAdvance
        if node.attr("horiz-adv-x").len > 0:
          advance = node.parseFloat("horiz-adv-x")
        result.missingGlyphAdvance = advance
        result.missingGlyphPath = parsePath(node.attr("d"))
        result.missingGlyphPath.transform(scale(vec2(1, -1)))
      else:
        discard # Unrecognized font node child



================================================
FILE: src/pixie/simd/avx.nim
================================================
import chroma, nimsimd/hassimd, nimsimd/avx

when defined(gcc) or defined(clang):
  {.localPassC: "-mavx".}

when defined(release):
  {.push checks: off.}

proc fillUnsafeAvx*(
  data: var seq[ColorRGBX],
  color: SomeColor,
  start, len: int
) {.simd.} =
  let rgbx = color.asRgbx()

  var
    i = start
    p = cast[uint](data[i].addr)
  # Align to 32 bytes
  while i < (start + len) and (p and 31) != 0:
    data[i] = rgbx
    inc i
    p += 4

  let
    colorVec = mm256_set1_epi32(cast[int32](rgbx))
    iterations = (start + len - i) div 8
  for _ in 0 ..< iterations:
    mm256_store_si256(cast[pointer](p), colorVec)
    p += 32
  i += 8 * iterations

  for i in i ..< start + len:
    data[i] = rgbx

when defined(release):
  {.pop.}



================================================
FILE: src/pixie/simd/avx2.nim
================================================
import avx, chroma, nimsimd/hassimd, nimsimd/avx2, ../blends, ../common, vmath

when defined(gcc) or defined(clang):
  {.localPassC: "-mavx2".}

when defined(release):
  {.push checks: off.}

template blendNormalSimd(backdrop, source: M256i): M256i =
  var
    sourceAlpha = mm256_and_si256(source, alphaMask)
    backdropEven = mm256_slli_epi16(backdrop, 8)
    backdropOdd = mm256_and_si256(backdrop, oddMask)

  sourceAlpha = mm256_shuffle_epi8(sourceAlpha, shuffleControl)

  let multiplier = mm256_sub_epi32(vecAlpha255, sourceAlpha)

  backdropEven = mm256_mulhi_epu16(backdropEven, multiplier)
  backdropOdd = mm256_mulhi_epu16(backdropOdd, multiplier)
  backdropEven = mm256_srli_epi16(mm256_mulhi_epu16(backdropEven, div255), 7)
  backdropOdd = mm256_srli_epi16(mm256_mulhi_epu16(backdropOdd, div255), 7)

  mm256_add_epi8(
    source,
    mm256_or_si256(backdropEven, mm256_slli_epi16(backdropOdd, 8))
  )

template blendMaskSimd(backdrop, source: M256i): M256i =
  var
    sourceAlpha = mm256_and_si256(source, alphaMask)
    backdropEven = mm256_slli_epi16(backdrop, 8)
    backdropOdd = mm256_and_si256(backdrop, oddMask)

  sourceAlpha = mm256_shuffle_epi8(sourceAlpha, shuffleControl)

  backdropEven = mm256_mulhi_epu16(backdropEven, sourceAlpha)
  backdropOdd = mm256_mulhi_epu16(backdropOdd, sourceAlpha)
  backdropEven = mm256_srli_epi16(mm256_mulhi_epu16(backdropEven, div255), 7)
  backdropOdd = mm256_srli_epi16(mm256_mulhi_epu16(backdropOdd, div255), 7)

  mm256_or_si256(backdropEven, mm256_slli_epi16(backdropOdd, 8))

proc isOneColorAvx2*(image: Image): bool {.simd.} =
  result = true

  let color = image.data[0]

  var i: int
  # Align to 32 bytes
  while i < image.data.len and (cast[uint](image.data[i].addr) and 31) != 0:
    if image.data[i] != color:
      return false
    inc i

  let
    colorVec = mm256_set1_epi32(cast[int32](color))
    iterations = (image.data.len - i) div 16
  for _ in 0 ..< iterations:
    let
      values0 = mm256_load_si256(image.data[i].addr)
      values1 = mm256_load_si256(image.data[i + 8].addr)
      eq0 = mm256_cmpeq_epi8(values0, colorVec)
      eq1 = mm256_cmpeq_epi8(values1, colorVec)
      eq01 = mm256_and_si256(eq0, eq1)
    if mm256_movemask_epi8(eq01) != cast[int32](0xffffffff):
      return false
    i += 16

  for i in i ..< image.data.len:
    if image.data[i] != color:
      return false

proc isTransparentAvx2*(image: Image): bool {.simd.} =
  result = true

  var i: int
  # Align to 32 bytes
  while i < image.data.len and (cast[uint](image.data[i].addr) and 31) != 0:
    if image.data[i].a != 0:
      return false
    inc i

  let
    vecZero = mm256_setzero_si256()
    iterations = (image.data.len - i) div 16
  for _ in 0 ..< iterations:
    let
      values0 = mm256_load_si256(image.data[i].addr)
      values1 = mm256_load_si256(image.data[i + 8].addr)
      values01 = mm256_or_si256(values0, values1)
      eq = mm256_cmpeq_epi8(values01, vecZero)
    if mm256_movemask_epi8(eq) != cast[int32](0xffffffff):
      return false
    i += 16

  for i in i ..< image.data.len:
    if image.data[i].a != 0:
      return false

proc isOpaqueAvx2*(data: var seq[ColorRGBX], start, len: int): bool {.simd.} =
  result = true

  var i = start
  # Align to 32 bytes
  while i < (start + len) and (cast[uint](data[i].addr) and 31) != 0:
    if data[i].a != 255:
      return false
    inc i

  let
    vec255 = mm256_set1_epi8(255)
    iterations = (start + len - i) div 16
  for _ in 0 ..< iterations:
    let
      values0 = mm256_load_si256(data[i].addr)
      values1 = mm256_load_si256(data[i + 8].addr)
      values01 = mm256_and_si256(values0, values1)
      eq = mm256_cmpeq_epi8(values01, vec255)
    if (mm256_movemask_epi8(eq) and 0x88888888) != 0x88888888:
      return false
    i += 16

  for i in i ..< start + len:
    if data[i].a != 255:
      return false

proc toPremultipliedAlphaAvx2*(data: var seq[ColorRGBA | ColorRGBX]) {.simd.} =
  var
    i: int
    p = cast[uint](data[0].addr)
  # Align to 32 bytes
  while i < data.len and (p and 31) != 0:
    var rgbx = data[i]
    if rgbx.a != 255:
      rgbx.r = ((rgbx.r.uint32 * rgbx.a + 127) div 255).uint8
      rgbx.g = ((rgbx.g.uint32 * rgbx.a + 127) div 255).uint8
      rgbx.b = ((rgbx.b.uint32 * rgbx.a + 127) div 255).uint8
      data[i] = rgbx
    inc i
    p += 4

  let
    alphaMask = mm256_set1_epi32(cast[int32](0xff000000))
    shuffleControl = mm256_set_epi8(
      15, -1, 15, -1, 11, -1, 11, -1, 7, -1, 7, -1, 3, -1, 3, -1,
      15, -1, 15, -1, 11, -1, 11, -1, 7, -1, 7, -1, 3, -1, 3, -1
    )
    oddMask = mm256_set1_epi16(0xff00)
    vec128 = mm256_set1_epi16(128)
    hiMask = mm256_set1_epi16(255 shl 8)
    iterations = (data.len - i) div 8
  for _ in 0 ..< iterations:
    let
      values = mm256_load_si256(cast[pointer](p))
      alpha = mm256_and_si256(values, alphaMask)
      eq = mm256_cmpeq_epi8(values, alphaMask)
    if (mm256_movemask_epi8(eq) and 0x88888888) != 0x88888888:
      let
        evenMultiplier = mm256_shuffle_epi8(alpha, shuffleControl)
        oddMultiplier = mm256_or_si256(evenMultiplier, alphaMask)
      var
        colorsEven = mm256_slli_epi16(values, 8)
        colorsOdd = mm256_and_si256(values, oddMask)
      colorsEven = mm256_mulhi_epu16(colorsEven, evenMultiplier)
      colorsOdd = mm256_mulhi_epu16(colorsOdd, oddMultiplier)
      let
        tmpEven = mm256_add_epi16(colorsEven, vec128)
        tmpOdd = mm256_add_epi16(colorsOdd, vec128)
      colorsEven = mm256_srli_epi16(tmpEven, 8)
      colorsOdd = mm256_srli_epi16(tmpOdd, 8)
      colorsEven = mm256_add_epi16(colorsEven, tmpEven)
      colorsOdd = mm256_add_epi16(colorsOdd, tmpOdd)
      colorsEven = mm256_srli_epi16(colorsEven, 8)
      colorsOdd = mm256_and_si256(colorsOdd, hiMask)
      mm256_store_si256(cast[pointer](p), mm256_or_si256(colorsEven, colorsOdd))
    p += 32
  i += 8 * iterations

  for i in i ..< data.len:
    var rgbx = data[i]
    if rgbx.a != 255:
      rgbx.r = ((rgbx.r.uint32 * rgbx.a + 127) div 255).uint8
      rgbx.g = ((rgbx.g.uint32 * rgbx.a + 127) div 255).uint8
      rgbx.b = ((rgbx.b.uint32 * rgbx.a + 127) div 255).uint8
      data[i] = rgbx

proc invertAvx2*(image: Image) {.simd.} =
  var
    i: int
    p = cast[uint](image.data[0].addr)
  # Align to 32 bytes
  while i < image.data.len and (p and 31) != 0:
    var rgbx = image.data[i]
    rgbx.r = 255 - rgbx.r
    rgbx.g = 255 - rgbx.g
    rgbx.b = 255 - rgbx.b
    rgbx.a = 255 - rgbx.a
    image.data[i] = rgbx
    inc i
    p += 4

  let
    vec255 = mm256_set1_epi8(255)
    iterations = (image.data.len - i) div 16
  for _ in 0 ..< iterations:
    let
      a = mm256_load_si256(cast[pointer](p))
      b = mm256_load_si256(cast[pointer](p + 32))
    mm256_store_si256(cast[pointer](p), mm256_sub_epi8(vec255, a))
    mm256_store_si256(cast[pointer](p + 32), mm256_sub_epi8(vec255, b))
    p += 64
  i += 16 * iterations

  for i in i ..< image.data.len:
    var rgbx = image.data[i]
    rgbx.r = 255 - rgbx.r
    rgbx.g = 255 - rgbx.g
    rgbx.b = 255 - rgbx.b
    rgbx.a = 255 - rgbx.a
    image.data[i] = rgbx

  toPremultipliedAlphaAvx2(image.data)

proc applyOpacityAvx2*(image: Image, opacity: float32) {.simd.} =
  let opacity = round(255 * opacity).uint16
  if opacity == 255:
    return

  if opacity == 0:
    fillUnsafeAvx(image.data, rgbx(0, 0, 0, 0), 0, image.data.len)
    return

  var
    i: int
    p = cast[uint](image.data[0].addr)
  # Align to 32 bytes
  while i < image.data.len and (p and 31) != 0:
    var rgbx = image.data[i]
    rgbx.r = ((rgbx.r * opacity) div 255).uint8
    rgbx.g = ((rgbx.g * opacity) div 255).uint8
    rgbx.b = ((rgbx.b * opacity) div 255).uint8
    rgbx.a = ((rgbx.a * opacity) div 255).uint8
    image.data[i] = rgbx
    inc i
    p += 4

  let
    oddMask = mm256_set1_epi16(0xff00)
    div255 = mm256_set1_epi16(0x8081)
    zeroVec = mm256_setzero_si256()
    opacityVec = mm256_slli_epi16(mm256_set1_epi16(opacity), 8)
    iterations = (image.data.len - i) div 8
  for _ in 0 ..< iterations:
    let
      values = mm256_load_si256(cast[pointer](p))
      eqZero = mm256_cmpeq_epi16(values, zeroVec)
    if mm256_movemask_epi8(eqZero) != cast[int32](0xffffffff):
      var
        valuesEven = mm256_slli_epi16(values, 8)
        valuesOdd = mm256_and_si256(values, oddMask)
      valuesEven = mm256_mulhi_epu16(valuesEven, opacityVec)
      valuesOdd = mm256_mulhi_epu16(valuesOdd, opacityVec)
      valuesEven = mm256_srli_epi16(mm256_mulhi_epu16(valuesEven, div255), 7)
      valuesOdd = mm256_srli_epi16(mm256_mulhi_epu16(valuesOdd, div255), 7)
      mm256_store_si256(
        cast[pointer](p),
        mm256_or_si256(valuesEven, mm256_slli_epi16(valuesOdd, 8))
      )
    p += 32
  i += 8 * iterations

  for i in i ..< image.data.len:
    var rgbx = image.data[i]
    rgbx.r = ((rgbx.r * opacity) div 255).uint8
    rgbx.g = ((rgbx.g * opacity) div 255).uint8
    rgbx.b = ((rgbx.b * opacity) div 255).uint8
    rgbx.a = ((rgbx.a * opacity) div 255).uint8
    image.data[i] = rgbx

proc ceilAvx2*(image: Image) {.simd.} =
  var
    i: int
    p = cast[uint](image.data[0].addr)
  # Align to 32 bytes
  while i < image.data.len and (p and 31) != 0:
    var rgbx = image.data[i]
    rgbx.r = if rgbx.r == 0: 0 else: 255
    rgbx.g = if rgbx.g == 0: 0 else: 255
    rgbx.b = if rgbx.b == 0: 0 else: 255
    rgbx.a = if rgbx.a == 0: 0 else: 255
    image.data[i] = rgbx
    inc i
    p += 4

  let
    vecZero = mm256_setzero_si256()
    vec255 = mm256_set1_epi8(255)
    iterations = (image.data.len - i) div 8
  for _ in 0 ..< iterations:
    var values = mm256_load_si256(cast[pointer](p))
    values = mm256_cmpeq_epi8(values, vecZero)
    values = mm256_andnot_si256(values, vec255)
    mm256_store_si256(cast[pointer](p), values)
    p += 32
  i += 8 * iterations

  for i in i ..< image.data.len:
    var rgbx = image.data[i]
    rgbx.r = if rgbx.r == 0: 0 else: 255
    rgbx.g = if rgbx.g == 0: 0 else: 255
    rgbx.b = if rgbx.b == 0: 0 else: 255
    rgbx.a = if rgbx.a == 0: 0 else: 255
    image.data[i] = rgbx

proc minifyBy2Avx2*(image: Image, power = 1): Image {.simd.} =
  ## Scales the image down by an integer scale.
  if power < 0:
    raise newException(PixieError, "Cannot minifyBy2 with negative power")
  if power == 0:
    return image.copy()

  var src = image
  for _ in 1 .. power:
    # When minifying an image of odd size, round the result image size up
    # so a 99 x 99 src image returns a 50 x 50 image.
    let
      srcWidthIsOdd = (src.width mod 2) != 0
      srcHeightIsOdd = (src.height mod 2) != 0
      resultEvenWidth = src.width div 2
      resultEvenHeight = src.height div 2
    result = newImage(
      if srcWidthIsOdd: resultEvenWidth + 1 else: resultEvenWidth,
      if srcHeightIsOdd: resultEvenHeight + 1 else: resultEvenHeight
    )
    let
      oddMask = mm256_set1_epi16(0xff00)
      vec2 = mm256_set1_epi16(2)
      permuteControl = mm256_set_epi32(7, 7, 7, 7, 6, 4, 2, 0)
    for y in 0 ..< resultEvenHeight:
      let
        topRowStart = src.dataIndex(0, y * 2)
        bottomRowStart = src.dataIndex(0, y * 2 + 1)

      var x: int
      while x <= resultEvenWidth - 8:
        let
          top = mm256_loadu_si256(src.data[topRowStart + x * 2].addr)
          bottom = mm256_loadu_si256(src.data[bottomRowStart + x * 2].addr)
          topShifted = mm256_srli_si256(top, 4)
          bottomShifted = mm256_srli_si256(bottom, 4)
          topEven = mm256_andnot_si256(oddMask, top)
          topOdd = mm256_srli_epi16(top, 8)
          bottomEven = mm256_andnot_si256(oddMask, bottom)
          bottomOdd = mm256_srli_epi16(bottom, 8)
          topShiftedEven = mm256_andnot_si256(oddMask, topShifted)
          topShiftedOdd = mm256_srli_epi16(topShifted, 8)
          bottomShiftedEven = mm256_andnot_si256(oddMask, bottomShifted)
          bottomShiftedOdd = mm256_srli_epi16(bottomShifted, 8)
          topAddedEven = mm256_add_epi16(topEven, topShiftedEven)
          bottomAddedEven = mm256_add_epi16(bottomEven, bottomShiftedEven)
          topAddedOdd = mm256_add_epi16(topOdd, topShiftedOdd)
          bottomAddedOdd = mm256_add_epi16(bottomOdd, bottomShiftedOdd)
          addedEven = mm256_add_epi16(topAddedEven, bottomAddedEven)
          addedOdd = mm256_add_epi16(topAddedOdd, bottomAddedOdd)
          addedEvenRounding = mm256_add_epi16(addedEven, vec2)
          addedOddRounding = mm256_add_epi16(addedOdd, vec2)
          addedEvenDiv4 = mm256_srli_epi16(addedEvenRounding, 2)
          addedOddDiv4 = mm256_srli_epi16(addedOddRounding, 2)
          merged = mm256_or_si256(addedEvenDiv4, mm256_slli_epi16(addedOddDiv4, 8))
          # Merged has the correct values for the next two pixels at
          # index 0, 2, 4, 6 so permute into position and store
          permuted = mm_256_permutevar8x32_epi32(merged, permuteControl)
        mm_storeu_si128(
          result.data[result.dataIndex(x, y)].addr,
          mm256_castsi256_si128(permuted)
        )
        x += 4

      for x in x ..< resultEvenWidth:
        let
          a = src.data[topRowStart + x * 2]
          b = src.data[topRowStart + x * 2 + 1]
          c = src.data[bottomRowStart + x * 2 + 1]
          d = src.data[bottomRowStart + x * 2]
          mixed = rgbx(
            ((a.r.uint32 + b.r + c.r + d.r + 2) div 4).uint8,
            ((a.g.uint32 + b.g + c.g + d.g + 2) div 4).uint8,
            ((a.b.uint32 + b.b + c.b + d.b + 2) div 4).uint8,
            ((a.a.uint32 + b.a + c.a + d.a + 2) div 4).uint8
          )
        result.data[result.dataIndex(x, y)] = mixed

      if srcWidthIsOdd:
        let rgbx = mix(
          src.data[src.dataIndex(src.width - 1, y * 2 + 0)],
          src.data[src.dataIndex(src.width - 1, y * 2 + 1)],
          0.5
        ) * 0.5
        result.data[result.dataIndex(result.width - 1, y)] = rgbx

    if srcHeightIsOdd:
      for x in 0 ..< resultEvenWidth:
        let rgbx = mix(
          src.data[src.dataIndex(x * 2 + 0, src.height - 1)],
          src.data[src.dataIndex(x * 2 + 1, src.height - 1)],
          0.5
        ) * 0.5
        result.data[result.dataIndex(x, result.height - 1)] = rgbx

      if srcWidthIsOdd:
        result.data[result.dataIndex(result.width - 1, result.height - 1)] =
          src.data[src.dataIndex(src.width - 1, src.height - 1)] * 0.25

    # Set src as this result for if we do another power
    src = result

template applyCoverage(rgbxVec: M256i, coverage: M128i): M256i =
  ## Unpack the first 8 coverage bytes.
  let
    unpacked0 = mm_shuffle_epi8(coverage, coverageShuffle)
    unpacked1 = mm_shuffle_epi8(mm_srli_si128(coverage, 4), coverageShuffle)
    unpacked =
      mm256_insertf128_si256(mm256_castsi128_si256(unpacked0), unpacked1, 1)

  var
    rgbxEven = mm256_slli_epi16(rgbxVec, 8)
    rgbxOdd = mm256_and_si256(rgbxVec, oddMask)
  rgbxEven = mm256_mulhi_epu16(rgbxEven, unpacked)
  rgbxOdd = mm256_mulhi_epu16(rgbxOdd, unpacked)
  rgbxEven = mm256_srli_epi16(mm256_mulhi_epu16(rgbxEven, div255), 7)
  rgbxOdd = mm256_srli_epi16(mm256_mulhi_epu16(rgbxOdd, div255), 7)

  mm256_or_si256(rgbxEven, mm256_slli_epi16(rgbxOdd, 8))

proc blendLineCoverageOverwriteAvx2*(
  line: ptr UncheckedArray[ColorRGBX],
  coverages: ptr UncheckedArray[uint8],
  rgbx: ColorRGBX,
  len: int
) {.simd.} =
  var i: int
  while i < len and (cast[uint](line[i].addr) and 31) != 0:
    let coverage = coverages[i]
    if coverage != 0:
      line[i] = rgbx * coverage
    inc i

  let
    rgbxVec = mm256_set1_epi32(cast[uint32](rgbx))
    vecZero = mm256_setzero_si256()
    vec255 = mm256_set1_epi8(255)
    oddMask = mm256_set1_epi16(0xff00)
    div255 = mm256_set1_epi16(0x8081)
    coverageShuffle = mm_set_epi8(
      3, -1, 3, -1, 2, -1, 2, -1, 1, -1, 1, -1, 0, -1, 0, -1
    )
  while i < len - 32:
    let
      coverage = mm256_loadu_si256(coverages[i].addr)
      eqZero = mm256_cmpeq_epi8(coverage, vecZero)
      eq255 = mm256_cmpeq_epi8(coverage, vec255)
    if mm256_movemask_epi8(eqZero) == cast[int32](0xffffffff):
      i += 32
    elif mm256_movemask_epi8(eq255) == cast[int32](0xffffffff):
      for _ in 0 ..< 4:
        mm256_store_si256(line[i].addr, rgbxVec)
        i += 8
    else:
      let
        coverageLo = mm256_castsi256_si128(coverage)
        coverageHi = mm256_extractf128_si256(coverage, 1)
        coverages = [
          coverageLo,
          mm_srli_si128(coverageLo, 8),
          coverageHi,
          mm_srli_si128(coverageHi, 8),
        ]
      for j in 0 ..< 4:
        mm256_store_si256(line[i].addr, rgbxVec.applyCoverage(coverages[j]))
        i += 8

  for i in i ..< len:
    let coverage = coverages[i]
    if coverage != 0:
      line[i] = rgbx * coverage

proc blendLineNormalAvx2*(
  line: ptr UncheckedArray[ColorRGBX], rgbx: ColorRGBX, len: int
) {.simd.} =
  var i: int
  while i < len and (cast[uint](line[i].addr) and 31) != 0:
    line[i] = blendNormal(line[i], rgbx)
    inc i

  let
    source = mm256_set1_epi32(cast[uint32](rgbx))
    alphaMask = mm256_set1_epi32(cast[int32](0xff000000))
    oddMask = mm256_set1_epi16(cast[int16](0xff00))
    div255 = mm256_set1_epi16(cast[int16](0x8081))
    vecAlpha255 = mm256_set1_epi32(cast[int32]([0.uint8, 255, 0, 255]))
    shuffleControl = mm256_set_epi8(
      15, -1, 15, -1, 11, -1, 11, -1, 7, -1, 7, -1, 3, -1, 3, -1,
      15, -1, 15, -1, 11, -1, 11, -1, 7, -1, 7, -1, 3, -1, 3, -1
    )
  while i < len - 8:
    let backdrop = mm256_load_si256(line[i].addr)
    mm256_store_si256(line[i].addr, blendNormalSimd(backdrop, source))
    i += 8

  for i in i ..< len:
    line[i] = blendNormal(line[i], rgbx)

proc blendLineNormalAvx2*(
  a, b: ptr UncheckedArray[ColorRGBX], len: int
) {.simd.} =
  var i: int
  while i < len and (cast[uint](a[i].addr) and 31) != 0:
    a[i] = blendNormal(a[i], b[i])
    inc i

  let
    alphaMask = mm256_set1_epi32(cast[int32](0xff000000))
    oddMask = mm256_set1_epi16(cast[int16](0xff00))
    div255 = mm256_set1_epi16(cast[int16](0x8081))
    vec255 = mm256_set1_epi8(255)
    vecAlpha255 = mm256_set1_epi32(cast[int32]([0.uint8, 255, 0, 255]))
    shuffleControl = mm256_set_epi8(
      15, -1, 15, -1, 11, -1, 11, -1, 7, -1, 7, -1, 3, -1, 3, -1,
      15, -1, 15, -1, 11, -1, 11, -1, 7, -1, 7, -1, 3, -1, 3, -1
    )
  while i < len - 8:
    let
      source = mm256_loadu_si256(b[i].addr)
      eq255 = mm256_cmpeq_epi8(source, vec255)
    if (mm256_movemask_epi8(eq255) and 0x88888888) == 0x88888888: # Opaque source
      mm256_store_si256(a[i].addr, source)
    else:
      let backdrop = mm256_load_si256(a[i].addr)
      mm256_store_si256(a[i].addr, blendNormalSimd(backdrop, source))
    i += 8

  for i in i ..< len:
    a[i] = blendNormal(a[i], b[i])

proc blendLineCoverageNormalAvx2*(
  line: ptr UncheckedArray[ColorRGBX],
  coverages: ptr UncheckedArray[uint8],
  rgbx: ColorRGBX,
  len: int
) {.simd.} =
  var i: int
  while i < len and (cast[uint](line[i].addr) and 31) != 0:
    let coverage = coverages[i]
    if coverage == 0:
      discard
    else:
      line[i] = blendNormal(line[i], rgbx * coverage)
    inc i

  let
    rgbxVec = mm256_set1_epi32(cast[uint32](rgbx))
    vecZero = mm256_setzero_si256()
    vec255 = mm256_set1_epi8(255)
    alphaMask = mm256_set1_epi32(cast[int32](0xff000000))
    oddMask = mm256_set1_epi16(cast[int16](0xff00))
    div255 = mm256_set1_epi16(cast[int16](0x8081))
    vecAlpha255 = mm256_set1_epi32(cast[int32]([0.uint8, 255, 0, 255]))
    coverageShuffle = mm_set_epi8(
      3, -1, 3, -1, 2, -1, 2, -1, 1, -1, 1, -1, 0, -1, 0, -1
    )
    shuffleControl = mm256_set_epi8(
      15, -1, 15, -1, 11, -1, 11, -1, 7, -1, 7, -1, 3, -1, 3, -1,
      15, -1, 15, -1, 11, -1, 11, -1, 7, -1, 7, -1, 3, -1, 3, -1
    )
  while i < len - 32:
    let
      coverage = mm256_loadu_si256(coverages[i].addr)
      eqZero = mm256_cmpeq_epi8(coverage, vecZero)
      eq255 = mm256_cmpeq_epi8(coverage, vec255)
    if mm256_movemask_epi8(eqZero) == cast[int32](0xffffffff):
      i += 32
    elif mm256_movemask_epi8(eq255) == cast[int32](0xffffffff) and rgbx.a == 255:
      for _ in 0 ..< 4:
        mm256_store_si256(line[i].addr, rgbxVec)
        i += 8
    else:
      let
        coverageLo = mm256_castsi256_si128(coverage)
        coverageHi = mm256_extractf128_si256(coverage, 1)
        coverages = [
          coverageLo,
          mm_srli_si128(coverageLo, 8),
          coverageHi,
          mm_srli_si128(coverageHi, 8),
        ]
      for j in 0 ..< 4:
        let
          backdrop = mm256_loadu_si256(line[i].addr)
          source = rgbxVec.applyCoverage(coverages[j])
        mm256_store_si256(line[i].addr, blendNormalSimd(backdrop, source))
        i += 8

  for i in i ..< len:
    let coverage = coverages[i]
    if coverage == 0:
      discard
    else:
      line[i] = blendNormal(line[i], rgbx * coverage)

proc blendLineMaskAvx2*(
  line: ptr UncheckedArray[ColorRGBX], rgbx: ColorRGBX, len: int
) {.simd.} =
  var i: int
  while i < len and (cast[uint](line[i].addr) and 31) != 0:
    line[i] = blendMask(line[i], rgbx)
    inc i

  let
    source = mm256_set1_epi32(cast[uint32](rgbx))
    alphaMask = mm256_set1_epi32(cast[int32](0xff000000))
    oddMask = mm256_set1_epi16(cast[int16](0xff00))
    div255 = mm256_set1_epi16(cast[int16](0x8081))
    shuffleControl = mm256_set_epi8(
      15, -1, 15, -1, 11, -1, 11, -1, 7, -1, 7, -1, 3, -1, 3, -1,
      15, -1, 15, -1, 11, -1, 11, -1, 7, -1, 7, -1, 3, -1, 3, -1
    )
  while i < len - 8:
    let backdrop = mm256_load_si256(line[i].addr)
    mm256_store_si256(line[i].addr, blendMaskSimd(backdrop, source))
    i += 8

  for i in i ..< len:
    line[i] = blendMask(line[i], rgbx)

proc blendLineMaskAvx2*(
  a, b: ptr UncheckedArray[ColorRGBX], len: int
) {.simd.} =
  var i: int
  while i < len and (cast[uint](a[i].addr) and 31) != 0:
    a[i] = blendMask(a[i], b[i])
    inc i

  let
    alphaMask = mm256_set1_epi32(cast[int32](0xff000000))
    oddMask = mm256_set1_epi16(cast[int16](0xff00))
    div255 = mm256_set1_epi16(cast[int16](0x8081))
    vec255 = mm256_set1_epi8(255)
    shuffleControl = mm256_set_epi8(
      15, -1, 15, -1, 11, -1, 11, -1, 7, -1, 7, -1, 3, -1, 3, -1,
      15, -1, 15, -1, 11, -1, 11, -1, 7, -1, 7, -1, 3, -1, 3, -1
    )
  while i < len - 8:
    let
      source = mm256_loadu_si256(b[i].addr)
      eq255 = mm256_cmpeq_epi8(source, vec255)
    if (mm256_movemask_epi8(eq255) and 0x88888888) == 0x88888888: # Opaque source
      discard
    else:
      let backdrop = mm256_load_si256(a[i].addr)
      mm256_store_si256(a[i].addr, blendMaskSimd(backdrop, source))
    i += 8

  for i in i ..< len:
    a[i] = blendMask(a[i], b[i])

proc blendLineCoverageMaskAvx2*(
  line: ptr UncheckedArray[ColorRGBX],
  coverages: ptr UncheckedArray[uint8],
  rgbx: ColorRGBX,
  len: int
) {.simd.} =
  var i: int
  while i < len and (cast[uint](line[i].addr) and 31) != 0:
    let coverage = coverages[i]
    if coverage == 0:
      line[i] = rgbx(0, 0, 0, 0)
    elif coverage == 255:
      discard
    else:
      line[i] = blendMask(line[i], rgbx * coverage)
    inc i

  let
    rgbxVec = mm256_set1_epi32(cast[uint32](rgbx))
    vecZero = mm256_setzero_si256()
    vec255 = mm256_set1_epi8(255)
    alphaMask = mm256_set1_epi32(cast[int32](0xff000000))
    oddMask = mm256_set1_epi16(cast[int16](0xff00))
    div255 = mm256_set1_epi16(cast[int16](0x8081))
    coverageShuffle = mm_set_epi8(
      3, -1, 3, -1, 2, -1, 2, -1, 1, -1, 1, -1, 0, -1, 0, -1
    )
    shuffleControl = mm256_set_epi8(
      15, -1, 15, -1, 11, -1, 11, -1, 7, -1, 7, -1, 3, -1, 3, -1,
      15, -1, 15, -1, 11, -1, 11, -1, 7, -1, 7, -1, 3, -1, 3, -1
    )
  while i < len - 16:
    let
      coverage = mm256_loadu_si256(coverages[i].addr)
      eqZero = mm256_cmpeq_epi8(coverage, vecZero)
      eq255 = mm256_cmpeq_epi8(coverage, vec255)
    if mm256_movemask_epi8(eqZero) == cast[int32](0xffffffff):
      for _ in 0 ..< 4:
        mm256_store_si256(line[i].addr, vecZero)
        i += 8
    elif mm256_movemask_epi8(eq255) == cast[int32](0xffffffff) and rgbx.a == 255:
      i += 32
    else:
      let
        coverageLo = mm256_castsi256_si128(coverage)
        coverageHi = mm256_extractf128_si256(coverage, 1)
        coverages = [
          coverageLo,
          mm_srli_si128(coverageLo, 8),
          coverageHi,
          mm_srli_si128(coverageHi, 8),
        ]
      for j in 0 ..< 4:
        let
          backdrop = mm256_loadu_si256(line[i].addr)
          source = rgbxVec.applyCoverage(coverages[j])
        mm256_store_si256(line[i].addr, blendMaskSimd(backdrop, source))
        i += 8

  for i in i ..< len:
    let coverage = coverages[i]
    if coverage == 0:
      line[i] = rgbx(0, 0, 0, 0)
    elif coverage == 255:
      discard
    else:
      line[i] = blendMask(line[i], rgbx * coverage)

when defined(release):
  {.pop.}



================================================
FILE: src/pixie/simd/neon.nim
================================================
import chroma, nimsimd/hassimd, nimsimd/neon, ../blends, ../common, vmath

when defined(release):
  {.push checks: off.}

template multiplyDiv255(c, a: uint8x8): uint8x8 =
  let ca = vmull_u8(c, a)
  vraddhn_u16(ca, vrshrq_n_u16(ca, 8))

template multiplyDiv255(c, a: uint8x16): uint8x16 =
  vcombine_u8(
    multiplyDiv255(vget_low_u8(c), vget_low_u8(a)),
    multiplyDiv255(vget_high_u8(c), vget_high_u8(a))
  )

template blendNormalSimd(backdrop, source: uint8x16x4): uint8x16x4 =
  let multiplier = vsubq_u8(vec255, source.val[3])

  var blended: uint8x16x4
  blended.val[0] = multiplyDiv255(backdrop.val[0], multiplier)
  blended.val[1] = multiplyDiv255(backdrop.val[1], multiplier)
  blended.val[2] = multiplyDiv255(backdrop.val[2], multiplier)
  blended.val[3] = multiplyDiv255(backdrop.val[3], multiplier)
  blended.val[0] = vaddq_u8(blended.val[0], source.val[0])
  blended.val[1] = vaddq_u8(blended.val[1], source.val[1])
  blended.val[2] = vaddq_u8(blended.val[2], source.val[2])
  blended.val[3] = vaddq_u8(blended.val[3], source.val[3])
  blended

proc fillUnsafeNeon*(
  data: var seq[ColorRGBX],
  color: SomeColor,
  start, len: int
) {.simd.} =
  let rgbx = color.asRgbx()

  var
    i = start
    p = cast[uint](data[i].addr)
  # Align to 16 bytes
  while i < (start + len) and (p and 15) != 0:
    data[i] = rgbx
    inc i
    p += 4

  let
    colors = vmovq_n_u32(cast[uint32](rgbx))
    x4 = vld4q_dup_u32(colors.unsafeAddr)
    iterations = (start + len - i) div 16
  for _ in 0 ..< iterations:
    vst1q_u32_x4(data[i].addr, x4)
    i += 16

  for i in i ..< start + len:
    data[i] = rgbx

proc isOneColorNeon*(image: Image): bool {.simd.} =
  result = true

  let color = image.data[0]

  var
    i: int
    p = cast[uint](image.data[0].addr)
  # Align to 16 bytes
  while i < image.data.len and (p and 15) != 0:
    if image.data[i] != color:
      return false
    inc i
    p += 4

  let
    colorVecs = vld4q_dup_u8(color.unsafeAddr)
    iterations = (image.data.len - i) div 16
  for _ in 0 ..< iterations:
    let
      deinterleved = vld4q_u8(image.data[i].addr)
      rEq = vceqq_u8(deinterleved.val[0], colorVecs.val[0])
      gEq = vceqq_u8(deinterleved.val[1], colorVecs.val[1])
      bEq = vceqq_u8(deinterleved.val[2], colorVecs.val[2])
      aEq = vceqq_u8(deinterleved.val[3], colorVecs.val[3])
      rgEq = vandq_u8(rEq, gEq)
      baEq = vandq_u8(bEq, aEq)
      rgbaEq = vandq_u8(rgEq, baEq)
      mask = vget_lane_u64(cast[uint64x1](
        vand_u8(vget_low_u8(rgbaEq), vget_high_u8(rgbaEq)
      )), 0)
    if mask != uint64.high:
      return false
    i += 16

  for i in i ..< image.data.len:
    if image.data[i] != color:
      return false

proc isTransparentNeon*(image: Image): bool {.simd.} =
  var
    i: int
    p = cast[uint](image.data[0].addr)
  # Align to 16 bytes
  while i < image.data.len and (p and 15) != 0:
    if image.data[i].a != 0:
      return false
    inc i
    p += 4

  result = true

  let
    vecZero = vmovq_n_u8(0)
    iterations = (image.data.len - i) div 16
  for _ in 0 ..< iterations:
    let
      alphas = vld4q_u8(image.data[i].addr).val[3]
      eq = vceqq_u8(alphas, vecZero)
      mask = vget_lane_u64(cast[uint64x1](
        vand_u8(vget_low_u8(eq), vget_high_u8(eq)
      )), 0)
    if mask != uint64.high:
      return false
    i += 16

  for i in i ..< image.data.len:
    if image.data[i].a != 0:
      return false

proc isOpaqueNeon*(data: var seq[ColorRGBX], start, len: int): bool {.simd.} =
  result = true

  var
    i = start
    p = cast[uint](data[0].addr)
  # Align to 16 bytes
  while i < (start + len) and (p and 15) != 0:
    if data[i].a != 255:
      return false
    inc i
    p += 4

  let
    vec255 = vmovq_n_u8(255)
    iterations = (start + len - i) div 16
  for _ in 0 ..< iterations:
    let
      alphas = vld4q_u8(data[i].addr).val[3]
      eq = vceqq_u8(alphas, vec255)
      mask = vget_lane_u64(cast[uint64x1](
        vand_u8(vget_low_u8(eq), vget_high_u8(eq)
      )), 0)
    if mask != uint64.high:
      return false
    i += 16

  for i in i ..< start + len:
    if data[i].a != 255:
      return false

proc toPremultipliedAlphaNeon*(data: var seq[ColorRGBA | ColorRGBX]) {.simd.} =
  var
    i: int
    p = cast[uint](data[0].addr)
  # Align to 16 bytes
  while i < data.len and (p and 15) != 0:
    var c = data[i]
    if c.a != 255:
      c.r = ((c.r.uint32 * c.a + 127) div 255).uint8
      c.g = ((c.g.uint32 * c.a + 127) div 255).uint8
      c.b = ((c.b.uint32 * c.a + 127) div 255).uint8
      data[i] = c
    inc i
    p += 4

  let iterations = (data.len - i) div 16
  for _ in 0 ..< iterations:
    var channels = vld4q_u8(cast[pointer](p))
    channels.val[0] = multiplyDiv255(channels.val[0], channels.val[3])
    channels.val[1] = multiplyDiv255(channels.val[1], channels.val[3])
    channels.val[2] = multiplyDiv255(channels.val[2], channels.val[3])
    vst4q_u8(cast[pointer](p), channels)
    p += 64
  i += 16 * iterations

  for i in i ..< data.len:
    var c = data[i]
    if c.a != 255:
      c.r = ((c.r.uint32 * c.a + 127) div 255).uint8
      c.g = ((c.g.uint32 * c.a + 127) div 255).uint8
      c.b = ((c.b.uint32 * c.a + 127) div 255).uint8
      data[i] = c

proc invertNeon*(image: Image) {.simd.} =
  var
    i: int
    p = cast[uint](image.data[0].addr)
  # Align to 16 bytes
  while i < image.data.len and (p and 15) != 0:
    var rgbx = image.data[i]
    rgbx.r = 255 - rgbx.r
    rgbx.g = 255 - rgbx.g
    rgbx.b = 255 - rgbx.b
    rgbx.a = 255 - rgbx.a
    image.data[i] = rgbx
    inc i
    p += 4

  let
    vec255 = vmovq_n_u8(255)
    iterations = image.data.len div 16
  for _ in 0 ..< iterations:
    var channels = vld4q_u8(cast[pointer](p))
    channels.val[0] = vsubq_u8(vec255, channels.val[0])
    channels.val[1] = vsubq_u8(vec255, channels.val[1])
    channels.val[2] = vsubq_u8(vec255, channels.val[2])
    channels.val[3] = vsubq_u8(vec255, channels.val[3])
    vst4q_u8(cast[pointer](p), channels)
    p += 64
  i += 16 * iterations

  for i in i ..< image.data.len:
    var rgbx = image.data[i]
    rgbx.r = 255 - rgbx.r
    rgbx.g = 255 - rgbx.g
    rgbx.b = 255 - rgbx.b
    rgbx.a = 255 - rgbx.a
    image.data[i] = rgbx

  toPremultipliedAlphaNeon(image.data)

proc applyOpacityNeon*(image: Image, opacity: float32) {.simd.} =
  let opacity = round(255 * opacity).uint8
  if opacity == 255:
    return

  if opacity == 0:
    fillUnsafeNeon(image.data, rgbx(0, 0, 0, 0), 0, image.data.len)
    return

  var
    i: int
    p = cast[uint](image.data[0].addr)

  let
    opacityVec = vmov_n_u8(opacity)
    iterations = image.data.len div 8
  for _ in 0 ..< iterations:
    var channels = vld4_u8(cast[pointer](p))
    channels.val[0] = multiplyDiv255(channels.val[0], opacityVec)
    channels.val[1] = multiplyDiv255(channels.val[1], opacityVec)
    channels.val[2] = multiplyDiv255(channels.val[2], opacityVec)
    channels.val[3] = multiplyDiv255(channels.val[3], opacityVec)
    vst4_u8(cast[pointer](p), channels)
    p += 32
  i += 8 * iterations

  for i in i ..< image.data.len:
    var rgbx = image.data[i]
    rgbx.r = ((rgbx.r * opacity) div 255).uint8
    rgbx.g = ((rgbx.g * opacity) div 255).uint8
    rgbx.b = ((rgbx.b * opacity) div 255).uint8
    rgbx.a = ((rgbx.a * opacity) div 255).uint8
    image.data[i] = rgbx

proc ceilNeon*(image: Image) {.simd.} =
  var
    i: int
    p = cast[uint](image.data[0].addr)

  let
    zeroVec = vmovq_n_u8(0)
    vec255 = vmovq_n_u8(255)
    iterations = image.data.len div 4
  for _ in 0 ..< iterations:
    var values = vld1q_u8(cast[pointer](p))
    values = vceqq_u8(values, zeroVec)
    values = vbicq_u8(vec255, values)
    vst1q_u8(cast[pointer](p), values)
    p += 16
  i += 4 * iterations

  for i in i ..< image.data.len:
    var rgbx = image.data[i]
    rgbx.r = if rgbx.r == 0: 0 else: 255
    rgbx.g = if rgbx.g == 0: 0 else: 255
    rgbx.b = if rgbx.b == 0: 0 else: 255
    rgbx.a = if rgbx.a == 0: 0 else: 255
    image.data[i] = rgbx

proc minifyBy2Neon*(image: Image, power = 1): Image {.simd.} =
  ## Scales the image down by an integer scale.
  if power < 0:
    raise newException(PixieError, "Cannot minifyBy2 with negative power")
  if power == 0:
    return image.copy()

  var src = image
  for _ in 1 .. power:
    # When minifying an image of odd size, round the result image size up
    # so a 99 x 99 src image returns a 50 x 50 image.
    let
      srcWidthIsOdd = (src.width mod 2) != 0
      srcHeightIsOdd = (src.height mod 2) != 0
      resultEvenWidth = src.width div 2
      resultEvenHeight = src.height div 2
    result = newImage(
      if srcWidthIsOdd: resultEvenWidth + 1 else: resultEvenWidth,
      if srcHeightIsOdd: resultEvenHeight + 1 else: resultEvenHeight
    )
    let
      evenLanes = [0.uint8, 2, 4, 6, 255, 255, 255, 255]
      tblIdx = vld1_u8(evenLanes.unsafeAddr)
    for y in 0 ..< resultEvenHeight:
      let
        topRowStart = src.dataIndex(0, y * 2)
        bottomRowStart = src.dataIndex(0, y * 2 + 1)

      var x: int
      while x <= resultEvenWidth - 9:
        let
          top = vld4_u8(src.data[topRowStart + x * 2].addr)
          topNext = vld4_u8(src.data[topRowStart + x * 2 + 1].addr)
          bottom = vld4_u8(src.data[bottomRowStart + x * 2].addr)
          bottomNext = vld4_u8(src.data[bottomRowStart + x * 2 + 1].addr)
          r = vrshrn_n_u16(vaddq_u16(
            vaddl_u8(top.val[0], topNext.val[0]),
            vaddl_u8(bottom.val[0], bottomNext.val[0])
          ), 2)
          g = vrshrn_n_u16(vaddq_u16(
            vaddl_u8(top.val[1], topNext.val[1]),
            vaddl_u8(bottom.val[1], bottomNext.val[1])
          ), 2)
          b = vrshrn_n_u16(vaddq_u16(
            vaddl_u8(top.val[2], topNext.val[2]),
            vaddl_u8(bottom.val[2], bottomNext.val[2])
          ), 2)
          a = vrshrn_n_u16(vaddq_u16(
            vaddl_u8(top.val[3], topNext.val[3]),
            vaddl_u8(bottom.val[3], bottomNext.val[3])
          ), 2)
        # The correct values are in the even lanes 0, 2, 4, 6
        var correct: uint8x8x4
        correct.val[0] = vtbl1_u8(r, tblIdx)
        correct.val[1] = vtbl1_u8(g, tblIdx)
        correct.val[2] = vtbl1_u8(b, tblIdx)
        correct.val[3] = vtbl1_u8(a, tblIdx)
        vst4_u8(result.data[result.dataIndex(x, y)].addr, correct)
        x += 4

      for x in x ..< resultEvenWidth:
        let
          a = src.data[topRowStart + x * 2]
          b = src.data[topRowStart + x * 2 + 1]
          c = src.data[bottomRowStart + x * 2 + 1]
          d = src.data[bottomRowStart + x * 2]
          mixed = rgbx(
            ((a.r.uint32 + b.r + c.r + d.r) div 4).uint8,
            ((a.g.uint32 + b.g + c.g + d.g) div 4).uint8,
            ((a.b.uint32 + b.b + c.b + d.b) div 4).uint8,
            ((a.a.uint32 + b.a + c.a + d.a) div 4).uint8
          )
        result.data[result.dataIndex(x, y)] = mixed

      if srcWidthIsOdd:
        let rgbx = mix(
          src.data[src.dataIndex(src.width - 1, y * 2 + 0)],
          src.data[src.dataIndex(src.width - 1, y * 2 + 1)],
          0.5
        ) * 0.5
        result.data[result.dataIndex(result.width - 1, y)] = rgbx

    if srcHeightIsOdd:
      for x in 0 ..< resultEvenWidth:
        let rgbx = mix(
          src.data[src.dataIndex(x * 2 + 0, src.height - 1)],
          src.data[src.dataIndex(x * 2 + 1, src.height - 1)],
          0.5
        ) * 0.5
        result.data[result.dataIndex(x, result.height - 1)] = rgbx

      if srcWidthIsOdd:
        result.data[result.dataIndex(result.width - 1, result.height - 1)] =
          src.data[src.dataIndex(src.width - 1, src.height - 1)] * 0.25

    # Set src as this result for if we do another power
    src = result

proc magnifyBy2Neon*(image: Image, power = 1): Image {.simd.} =
  ## Scales image up by 2 ^ power.
  if power < 0:
    raise newException(PixieError, "Cannot magnifyBy2 with negative power")

  let scale = 2 ^ power
  result = newImage(image.width * scale, image.height * scale)

  for y in 0 ..< image.height:
    # Write one row of pixels duplicated by scale
    let
      sourceRowStart = image.dataIndex(0, y)
      resultRowStart = result.dataIndex(0, y * scale)
    var x: int
    if scale == 2:
      template duplicate(vec: uint8x8): uint8x16 =
        let duplicated = vzip_u8(vec, vec)
        vcombine_u8(duplicated.val[0], duplicated.val[1])
      while x <= image.width - 8:
        let values = vld4_u8(image.data[sourceRowStart + x].addr)
        var duplicated: uint8x16x4
        duplicated.val[0] = duplicate(values.val[0])
        duplicated.val[1] = duplicate(values.val[1])
        duplicated.val[2] = duplicate(values.val[2])
        duplicated.val[3] = duplicate(values.val[3])
        vst4q_u8(result.data[resultRowStart + x * scale].addr, duplicated)
        x += 8
    for x in x ..< image.width:
      let
        rgbx = image.data[sourceRowStart + x]
        resultIdx = resultRowStart + x * scale
      for i in 0 ..< scale:
        result.data[resultIdx + i] = rgbx
    # Copy that row of pixels into (scale - 1) more rows
    for i in 1 ..< scale:
      copyMem(
        result.data[resultRowStart + result.width * i].addr,
        result.data[resultRowStart].addr,
        result.width * 4
      )

proc blendLineCoverageOverwriteNeon*(
  line: ptr UncheckedArray[ColorRGBX],
  coverages: ptr UncheckedArray[uint8],
  rgbx: ColorRGBX,
  len: int
) {.simd.} =
  var i: int
  while i < len and (cast[uint](line[i].addr) and 15) != 0:
    let coverage = coverages[i]
    if coverage != 0:
      line[i] = rgbx * coverage
    inc i

  var vecRgbx: uint8x16x4
  vecRgbx.val[0] = vmovq_n_u8(rgbx.r)
  vecRgbx.val[1] = vmovq_n_u8(rgbx.g)
  vecRgbx.val[2] = vmovq_n_u8(rgbx.b)
  vecRgbx.val[3] = vmovq_n_u8(rgbx.a)

  let
    vecZero = vmovq_n_u8(0)
    vec255 = vmovq_n_u8(255)
  while i < len - 16:
    let
      coverage = vld1q_u8(coverages[i].addr)
      eqZero = vceqq_u8(coverage, vecZero)
      eq255 = vceqq_u8(coverage, vec255)
      maskZero = vget_lane_u64(cast[uint64x1](
        vand_u8(vget_low_u8(eqZero), vget_high_u8(eqZero)
      )), 0)
      mask255 = vget_lane_u64(cast[uint64x1](
        vand_u8(vget_low_u8(eq255), vget_high_u8(eq255)
      )), 0)
    if maskZero == uint64.high:
      discard
    elif mask255 == uint64.high:
      vst4q_u8(line[i].addr, vecRgbx)
    else:
      var source: uint8x16x4
      source.val[0] = multiplyDiv255(vecRgbx.val[0], coverage)
      source.val[1] = multiplyDiv255(vecRgbx.val[1], coverage)
      source.val[2] = multiplyDiv255(vecRgbx.val[2], coverage)
      source.val[3] = multiplyDiv255(vecRgbx.val[3], coverage)
      vst4q_u8(line[i].addr, source)

    i += 16

  for i in i ..< len:
    let coverage = coverages[i]
    if coverage != 0:
      line[i] = rgbx * coverage

proc blendLineNormalNeon*(
  line: ptr UncheckedArray[ColorRGBX], rgbx: ColorRGBX, len: int
) {.simd.} =
  var i: int
  while i < len and (cast[uint](line[i].addr) and 15) != 0:
    line[i] = blendNormal(line[i], rgbx)
    inc i

  var vecRgbx: uint8x16x4
  vecRgbx.val[0] = vmovq_n_u8(rgbx.r)
  vecRgbx.val[1] = vmovq_n_u8(rgbx.g)
  vecRgbx.val[2] = vmovq_n_u8(rgbx.b)
  vecRgbx.val[3] = vmovq_n_u8(rgbx.a)

  let vec255 = vmovq_n_u8(255)
  while i < len - 16:
    let backdrop = vld4q_u8(line[i].addr)
    vst4q_u8(line[i].addr, blendNormalSimd(backdrop, vecRgbx))
    i += 16

  for i in i ..< len:
    line[i] = blendNormal(line[i], rgbx)

proc blendLineNormalNeon*(
  a, b: ptr UncheckedArray[ColorRGBX], len: int
) {.simd.} =
  var i: int
  while i < len and (cast[uint](a[i].addr) and 15) != 0:
    a[i] = blendNormal(a[i], b[i])
    inc i

  let vec255 = vmovq_n_u8(255)
  while i < len - 16:
    let
      source = vld4q_u8(b[i].addr)
      eq255 = vceqq_u8(source.val[3], vec255)
      mask = vget_lane_u64(cast[uint64x1](
        vand_u8(vget_low_u8(eq255), vget_high_u8(eq255)
      )), 0)
    if mask == uint64.high:
      vst4q_u8(a[i].addr, source)
    else:
      let backdrop = vld4q_u8(a[i].addr)
      vst4q_u8(a[i].addr, blendNormalSimd(backdrop, source))

    i += 16

  for i in i ..< len:
    a[i] = blendNormal(a[i], b[i])

proc blendLineCoverageNormalNeon*(
  line: ptr UncheckedArray[ColorRGBX],
  coverages: ptr UncheckedArray[uint8],
  rgbx: ColorRGBX,
  len: int
) {.simd.} =
  var i: int
  while i < len and (cast[uint](line[i].addr) and 15) != 0:
    let coverage = coverages[i]
    if coverage == 0:
      discard
    else:
      line[i] = blendNormal(line[i], rgbx * coverage)
    inc i

  var vecRgbx: uint8x16x4
  vecRgbx.val[0] = vmovq_n_u8(rgbx.r)
  vecRgbx.val[1] = vmovq_n_u8(rgbx.g)
  vecRgbx.val[2] = vmovq_n_u8(rgbx.b)
  vecRgbx.val[3] = vmovq_n_u8(rgbx.a)

  let
    vecZero = vmovq_n_u8(0)
    vec255 = vmovq_n_u8(255)
  while i < len - 16:
    let
      coverage = vld1q_u8(coverages[i].addr)
      eqZero = vceqq_u8(coverage, vecZero)
      eq255 = vceqq_u8(coverage, vec255)
      maskZero = vget_lane_u64(cast[uint64x1](
        vand_u8(vget_low_u8(eqZero), vget_high_u8(eqZero)
      )), 0)
      mask255 = vget_lane_u64(cast[uint64x1](
        vand_u8(vget_low_u8(eq255), vget_high_u8(eq255)
      )), 0)
    if maskZero == uint64.high:
      discard
    elif mask255 == uint64.high and rgbx.a == 255:
      vst4q_u8(line[i].addr, vecRgbx)
    else:
      var source: uint8x16x4
      source.val[0] = multiplyDiv255(vecRgbx.val[0], coverage)
      source.val[1] = multiplyDiv255(vecRgbx.val[1], coverage)
      source.val[2] = multiplyDiv255(vecRgbx.val[2], coverage)
      source.val[3] = multiplyDiv255(vecRgbx.val[3], coverage)

      let backdrop = vld4q_u8(line[i].addr)
      vst4q_u8(line[i].addr, blendNormalSimd(backdrop, source))

    i += 16

  for i in i ..< len:
    let coverage = coverages[i]
    if coverage == 0:
      discard
    else:
      line[i] = blendNormal(line[i], rgbx * coverage)

proc blendLineMaskNeon*(
  line: ptr UncheckedArray[ColorRGBX], rgbx: ColorRGBX, len: int
) {.simd.} =
  var i: int
  while i < len and (cast[uint](line[i].addr) and 15) != 0:
    line[i] = blendMask(line[i], rgbx)
    inc i

  let alpha = vmovq_n_u8(rgbx.a)
  while i < len - 16:
    let backdrop = vld4q_u8(line[i].addr)
    var blended: uint8x16x4
    blended.val[0] = multiplyDiv255(backdrop.val[0], alpha)
    blended.val[1] = multiplyDiv255(backdrop.val[1], alpha)
    blended.val[2] = multiplyDiv255(backdrop.val[2], alpha)
    blended.val[3] = multiplyDiv255(backdrop.val[3], alpha)
    vst4q_u8(line[i].addr, blended)
    i += 16

  for i in i ..< len:
    line[i] = blendMask(line[i], rgbx)

proc blendLineMaskNeon*(
  a, b: ptr UncheckedArray[ColorRGBX], len: int
) {.simd.} =
  var i: int
  while i < len and (cast[uint](a[i].addr) and 15) != 0:
    a[i] = blendMask(a[i], b[i])
    inc i

  let vec255 = vmovq_n_u8(255)
  while i < len - 16:
    let
      source = vld4q_u8(b[i].addr)
      eq255 = vceqq_u8(source.val[3], vec255)
      mask = vget_lane_u64(cast[uint64x1](
        vand_u8(vget_low_u8(eq255), vget_high_u8(eq255)
      )), 0)
    if mask == uint64.high:
      discard
    else:
      let backdrop = vld4q_u8(a[i].addr)
      var blended: uint8x16x4
      blended.val[0] = multiplyDiv255(backdrop.val[0], source.val[3])
      blended.val[1] = multiplyDiv255(backdrop.val[1], source.val[3])
      blended.val[2] = multiplyDiv255(backdrop.val[2], source.val[3])
      blended.val[3] = multiplyDiv255(backdrop.val[3], source.val[3])
      vst4q_u8(a[i].addr, blended)

    i += 16

  for i in i ..< len:
    a[i] = blendMask(a[i], b[i])

proc blendLineCoverageMaskNeon*(
  line: ptr UncheckedArray[ColorRGBX],
  coverages: ptr UncheckedArray[uint8],
  rgbx: ColorRGBX,
  len: int
) {.simd.} =
  var i: int
  while i < len and (cast[uint](line[i].addr) and 15) != 0:
    let coverage = coverages[i]
    if coverage == 0:
      line[i] = rgbx(0, 0, 0, 0)
    elif coverage == 255:
      discard
    else:
      line[i] = blendMask(line[i], rgbx * coverage)
    inc i

  let
    alpha = vmovq_n_u8(rgbx.a)
    vecZero = vmovq_n_u8(0)
    vec255 = vmovq_n_u8(255)
  while i < len - 16:
    let
      coverage = vld1q_u8(coverages[i].addr)
      eqZero = vceqq_u8(coverage, vecZero)
      eq255 = vceqq_u8(coverage, vec255)
      maskZero = vget_lane_u64(cast[uint64x1](
        vand_u8(vget_low_u8(eqZero), vget_high_u8(eqZero)
      )), 0)
      mask255 = vget_lane_u64(cast[uint64x1](
        vand_u8(vget_low_u8(eq255), vget_high_u8(eq255)
      )), 0)
    if maskZero == uint64.high:
      vst1q_u8(line[i].addr, vecZero)
      vst1q_u8(line[i + 4].addr, vecZero)
      vst1q_u8(line[i + 8].addr, vecZero)
      vst1q_u8(line[i + 12].addr, vecZero)
    elif mask255 == uint64.high and rgbx.a == 255:
      discard
    else:
      let
        backdrop = vld4q_u8(line[i].addr)
        alpha = multiplyDiv255(alpha, coverage)
      var blended: uint8x16x4
      blended.val[0] = multiplyDiv255(backdrop.val[0], alpha)
      blended.val[1] = multiplyDiv255(backdrop.val[1], alpha)
      blended.val[2] = multiplyDiv255(backdrop.val[2], alpha)
      blended.val[3] = multiplyDiv255(backdrop.val[3], alpha)
      vst4q_u8(line[i].addr, blended)

    i += 16

  for i in i ..< len:
    let coverage = coverages[i]
    if coverage == 0:
      line[i] = rgbx(0, 0, 0, 0)
    elif coverage == 255:
      discard
    else:
      line[i] = blendMask(line[i], rgbx * coverage)

when defined(release):
  {.pop.}



================================================
FILE: src/pixie/simd/sse2.nim
================================================
import chroma, nimsimd/hassimd, nimsimd/sse2, ../blends, ../common, vmath

when defined(release):
  {.push checks: off.}

proc applyOpacity*(color: M128, opacity: float32): ColorRGBX {.inline.} =
  let opacityVec = mm_set1_ps(opacity)
  var finalColor = mm_cvtps_epi32(mm_mul_ps(color, opacityVec))
  finalColor = mm_packus_epi16(finalColor, mm_setzero_si128())
  finalColor = mm_packus_epi16(finalColor, mm_setzero_si128())
  cast[ColorRGBX](mm_cvtsi128_si32(finalColor))

template blendNormalSimd(backdrop, source: M128i): M128i =
  var
    sourceAlpha = mm_and_si128(source, alphaMask)
    backdropEven = mm_slli_epi16(backdrop, 8)
    backdropOdd = mm_and_si128(backdrop, oddMask)

  sourceAlpha = mm_or_si128(sourceAlpha, mm_srli_epi32(sourceAlpha, 16))

  let multiplier = mm_sub_epi32(vecAlpha255, sourceAlpha)

  backdropEven = mm_mulhi_epu16(backdropEven, multiplier)
  backdropOdd = mm_mulhi_epu16(backdropOdd, multiplier)
  backdropEven = mm_srli_epi16(mm_mulhi_epu16(backdropEven, div255), 7)
  backdropOdd = mm_srli_epi16(mm_mulhi_epu16(backdropOdd, div255), 7)

  mm_add_epi8(
    source,
    mm_or_si128(backdropEven, mm_slli_epi16(backdropOdd, 8))
  )

template blendMaskSimd(backdrop, source: M128i): M128i =
  var
    sourceAlpha = mm_and_si128(source, alphaMask)
    backdropEven = mm_slli_epi16(backdrop, 8)
    backdropOdd = mm_and_si128(backdrop, oddMask)

  sourceAlpha = mm_or_si128(sourceAlpha, mm_srli_epi32(sourceAlpha, 16))

  backdropEven = mm_mulhi_epu16(backdropEven, sourceAlpha)
  backdropOdd = mm_mulhi_epu16(backdropOdd, sourceAlpha)
  backdropEven = mm_srli_epi16(mm_mulhi_epu16(backdropEven, div255), 7)
  backdropOdd = mm_srli_epi16(mm_mulhi_epu16(backdropOdd, div255), 7)

  mm_or_si128(backdropEven, mm_slli_epi16(backdropOdd, 8))

proc fillUnsafeSse2*(
  data: var seq[ColorRGBX],
  color: SomeColor,
  start, len: int
) {.simd.} =
  let rgbx = color.asRgbx()

  var
    i = start
    p = cast[uint](data[i].addr)
  # Align to 16 bytes
  while i < (start + len) and (p and 15) != 0:
    data[i] = rgbx
    inc i
    p += 4

  let
    colorVec = mm_set1_epi32(cast[int32](rgbx))
    iterations = (start + len - i) div 8
  for _ in 0 ..< iterations:
    mm_store_si128(cast[pointer](p), colorVec)
    mm_store_si128(cast[pointer](p + 16), colorVec)
    p += 32
  i += iterations * 8

  for i in i ..< start + len:
    data[i] = rgbx

proc isOneColorSse2*(image: Image): bool {.simd.} =
  result = true

  let color = image.data[0]

  var
    i: int
    p = cast[uint](image.data[0].addr)
  # Align to 16 bytes
  while i < image.data.len and (p and 15) != 0:
    if image.data[i] != color:
      return false
    inc i
    p += 4

  let
    colorVec = mm_set1_epi32(cast[int32](color))
    iterations = (image.data.len - i) div 16
  for _ in 0 ..< iterations:
    let
      values0 = mm_load_si128(cast[pointer](p))
      values1 = mm_load_si128(cast[pointer](p + 16))
      values2 = mm_load_si128(cast[pointer](p + 32))
      values3 = mm_load_si128(cast[pointer](p + 48))
      eq0 = mm_cmpeq_epi8(values0, colorVec)
      eq1 = mm_cmpeq_epi8(values1, colorVec)
      eq2 = mm_cmpeq_epi8(values2, colorVec)
      eq3 = mm_cmpeq_epi8(values3, colorVec)
      eq0123 = mm_and_si128(mm_and_si128(eq0, eq1), mm_and_si128(eq2, eq3))
    if mm_movemask_epi8(eq0123) != 0xffff:
      return false
    p += 64
  i += 16 * iterations

  for i in i ..< image.data.len:
    if image.data[i] != color:
      return false

proc isTransparentSse2*(image: Image): bool {.simd.} =
  var
    i: int
    p = cast[uint](image.data[0].addr)
  # Align to 16 bytes
  while i < image.data.len and (p and 15) != 0:
    if image.data[i].a != 0:
      return false
    inc i
    p += 4

  result = true

  let
    vecZero = mm_setzero_si128()
    iterations = (image.data.len - i) div 16
  for _ in 0 ..< iterations:
    let
      values0 = mm_load_si128(cast[pointer](p))
      values1 = mm_load_si128(cast[pointer](p + 16))
      values2 = mm_load_si128(cast[pointer](p + 32))
      values3 = mm_load_si128(cast[pointer](p + 48))
      values01 = mm_or_si128(values0, values1)
      values23 = mm_or_si128(values2, values3)
      values0123 = mm_or_si128(values01, values23)
    if mm_movemask_epi8(mm_cmpeq_epi8(values0123, vecZero)) != 0xffff:
      return false
    p += 64
  i += 16 * iterations

  for i in i ..< image.data.len:
    if image.data[i].a != 0:
      return false

proc isOpaqueSse2*(data: var seq[ColorRGBX], start, len: int): bool {.simd.} =
  result = true

  var
    i = start
    p = cast[uint](data[0].addr)
  # Align to 16 bytes
  while i < (start + len) and (p and 15) != 0:
    if data[i].a != 255:
      return false
    inc i
    p += 4

  let
    vec255 = mm_set1_epi8(255)
    iterations = (start + len - i) div 16
  for _ in 0 ..< iterations:
    let
      values0 = mm_load_si128(cast[pointer](p))
      values1 = mm_load_si128(cast[pointer](p + 16))
      values2 = mm_load_si128(cast[pointer](p + 32))
      values3 = mm_load_si128(cast[pointer](p + 48))
      values01 = mm_and_si128(values0, values1)
      values23 = mm_and_si128(values2, values3)
      values0123 = mm_and_si128(values01, values23)
      eq = mm_cmpeq_epi8(values0123, vec255)
    if (mm_movemask_epi8(eq) and 0x00008888) != 0x00008888:
      return false
    p += 64
  i += 16 * iterations

  for i in i ..< start + len:
    if data[i].a != 255:
      return false

proc toPremultipliedAlphaSse2*(data: var seq[ColorRGBA | ColorRGBX]) {.simd.} =
  var i: int

  # Not worth aligning

  let
    alphaMask = mm_set1_epi32(cast[int32](0xff000000))
    oddMask = mm_set1_epi16(0xff00)
    vec128 = mm_set1_epi16(128)
    hiMask = mm_set1_epi16(255 shl 8)
    iterations = data.len div 4
  for _ in 0 ..< iterations:
    let
      values = mm_loadu_si128(data[i].addr)
      alpha = mm_and_si128(values, alphaMask)
      eq = mm_cmpeq_epi8(values, alphaMask)
    if (mm_movemask_epi8(eq) and 0x00008888) != 0x00008888:
      let
        evenMultiplier = mm_or_si128(alpha, mm_srli_epi32(alpha, 16))
        oddMultiplier = mm_or_si128(evenMultiplier, alphaMask)
      var
        colorsEven = mm_slli_epi16(values, 8)
        colorsOdd = mm_and_si128(values, oddMask)
      colorsEven = mm_mulhi_epu16(colorsEven, evenMultiplier)
      colorsOdd = mm_mulhi_epu16(colorsOdd, oddMultiplier)
      let
        tmpEven = mm_add_epi16(colorsEven, vec128)
        tmpOdd = mm_add_epi16(colorsOdd, vec128)
      colorsEven = mm_srli_epi16(tmpEven, 8)
      colorsOdd = mm_srli_epi16(tmpOdd, 8)
      colorsEven = mm_add_epi16(colorsEven, tmpEven)
      colorsOdd = mm_add_epi16(colorsOdd, tmpOdd)
      colorsEven = mm_srli_epi16(colorsEven, 8)
      colorsOdd = mm_and_si128(colorsOdd, hiMask)
      mm_storeu_si128(data[i].addr, mm_or_si128(colorsEven, colorsOdd))
    i += 4

  for i in i ..< data.len:
    var rgbx = data[i]
    if rgbx.a != 255:
      rgbx.r = ((rgbx.r.uint32 * rgbx.a + 127) div 255).uint8
      rgbx.g = ((rgbx.g.uint32 * rgbx.a + 127) div 255).uint8
      rgbx.b = ((rgbx.b.uint32 * rgbx.a + 127) div 255).uint8
      data[i] = rgbx

proc invertSse2*(image: Image) {.simd.} =
  var
    i: int
    p = cast[uint](image.data[0].addr)
  # Align to 16 bytes
  while i < image.data.len and (p and 15) != 0:
    var rgbx = image.data[i]
    rgbx.r = 255 - rgbx.r
    rgbx.g = 255 - rgbx.g
    rgbx.b = 255 - rgbx.b
    rgbx.a = 255 - rgbx.a
    image.data[i] = rgbx
    inc i
    p += 4

  let
    vec255 = mm_set1_epi8(255)
    iterations = (image.data.len - i) div 16
  for _ in 0 ..< iterations:
    let
      a = mm_load_si128(cast[pointer](p))
      b = mm_load_si128(cast[pointer](p + 16))
      c = mm_load_si128(cast[pointer](p + 32))
      d = mm_load_si128(cast[pointer](p + 48))
    mm_store_si128(cast[pointer](p), mm_sub_epi8(vec255, a))
    mm_store_si128(cast[pointer](p + 16), mm_sub_epi8(vec255, b))
    mm_store_si128(cast[pointer](p + 32), mm_sub_epi8(vec255, c))
    mm_store_si128(cast[pointer](p + 48), mm_sub_epi8(vec255, d))
    p += 64
  i += 16 * iterations

  for i in i ..< image.data.len:
    var rgbx = image.data[i]
    rgbx.r = 255 - rgbx.r
    rgbx.g = 255 - rgbx.g
    rgbx.b = 255 - rgbx.b
    rgbx.a = 255 - rgbx.a
    image.data[i] = rgbx

  toPremultipliedAlphaSse2(image.data)

proc applyOpacitySse2*(image: Image, opacity: float32) {.simd.} =
  let opacity = round(255 * opacity).uint16
  if opacity == 255:
    return

  if opacity == 0:
    fillUnsafeSse2(image.data, rgbx(0, 0, 0, 0), 0, image.data.len)
    return

  var
    i: int
    p = cast[uint](image.data[0].addr)
  # Align to 16 bytes
  while i < image.data.len and (p and 15) != 0:
    var rgbx = image.data[i]
    rgbx.r = ((rgbx.r * opacity) div 255).uint8
    rgbx.g = ((rgbx.g * opacity) div 255).uint8
    rgbx.b = ((rgbx.b * opacity) div 255).uint8
    rgbx.a = ((rgbx.a * opacity) div 255).uint8
    image.data[i] = rgbx
    inc i
    p += 4

  let
    oddMask = mm_set1_epi16(0xff00)
    div255 = mm_set1_epi16(0x8081)
    zeroVec = mm_setzero_si128()
    opacityVec = mm_slli_epi16(mm_set1_epi16(opacity), 8)
    iterations = (image.data.len - i) div 4
  for _ in 0 ..< iterations:
    let values = mm_loadu_si128(cast[pointer](p))
    if mm_movemask_epi8(mm_cmpeq_epi16(values, zeroVec)) != 0xffff:
      var
        valuesEven = mm_slli_epi16(values, 8)
        valuesOdd = mm_and_si128(values, oddMask)
      valuesEven = mm_mulhi_epu16(valuesEven, opacityVec)
      valuesOdd = mm_mulhi_epu16(valuesOdd, opacityVec)
      valuesEven = mm_srli_epi16(mm_mulhi_epu16(valuesEven, div255), 7)
      valuesOdd = mm_srli_epi16(mm_mulhi_epu16(valuesOdd, div255), 7)
      mm_store_si128(
        cast[pointer](p),
        mm_or_si128(valuesEven, mm_slli_epi16(valuesOdd, 8))
      )
    p += 16
  i += 4 * iterations

  for i in i ..< image.data.len:
    var rgbx = image.data[i]
    rgbx.r = ((rgbx.r * opacity) div 255).uint8
    rgbx.g = ((rgbx.g * opacity) div 255).uint8
    rgbx.b = ((rgbx.b * opacity) div 255).uint8
    rgbx.a = ((rgbx.a * opacity) div 255).uint8
    image.data[i] = rgbx

proc ceilSse2*(image: Image) {.simd.} =
  var
    i: int
    p = cast[uint](image.data[0].addr)
  # Align to 16 bytes
  while i < image.data.len and (p and 15) != 0:
    var rgbx = image.data[i]
    rgbx.r = if rgbx.r == 0: 0 else: 255
    rgbx.g = if rgbx.g == 0: 0 else: 255
    rgbx.b = if rgbx.b == 0: 0 else: 255
    rgbx.a = if rgbx.a == 0: 0 else: 255
    image.data[i] = rgbx
    inc i
    p += 4

  let
    vecZero = mm_setzero_si128()
    vec255 = mm_set1_epi8(255)
    iterations = (image.data.len - i) div 8
  for _ in 0 ..< iterations:
    var
      values0 = mm_loadu_si128(cast[pointer](p))
      values1 = mm_loadu_si128(cast[pointer](p + 16))
    values0 = mm_cmpeq_epi8(values0, vecZero)
    values1 = mm_cmpeq_epi8(values1, vecZero)
    values0 = mm_andnot_si128(values0, vec255)
    values1 = mm_andnot_si128(values1, vec255)
    mm_store_si128(cast[pointer](p), values0)
    mm_store_si128(cast[pointer](p + 16), values1)
    p += 32
  i += 8 * iterations

  for i in i ..< image.data.len:
    var rgbx = image.data[i]
    rgbx.r = if rgbx.r == 0: 0 else: 255
    rgbx.g = if rgbx.g == 0: 0 else: 255
    rgbx.b = if rgbx.b == 0: 0 else: 255
    rgbx.a = if rgbx.a == 0: 0 else: 255
    image.data[i] = rgbx

proc minifyBy2Sse2*(image: Image, power = 1): Image {.simd.} =
  ## Scales the image down by an integer scale.
  if power < 0:
    raise newException(PixieError, "Cannot minifyBy2 with negative power")
  if power == 0:
    return image.copy()

  var src = image
  for _ in 1 .. power:
    # When minifying an image of odd size, round the result image size up
    # so a 99 x 99 src image returns a 50 x 50 image.
    let
      srcWidthIsOdd = (src.width mod 2) != 0
      srcHeightIsOdd = (src.height mod 2) != 0
      resultEvenWidth = src.width div 2
      resultEvenHeight = src.height div 2
    result = newImage(
      if srcWidthIsOdd: resultEvenWidth + 1 else: resultEvenWidth,
      if srcHeightIsOdd: resultEvenHeight + 1 else: resultEvenHeight
    )
    let
      oddMask = mm_set1_epi16(0xff00)
      loMask = mm_set_epi32(0, 0, uint32.high, uint32.high)
      hiMask = mm_set_epi32(uint32.high, uint32.high, 0, 0)
      vec2 = mm_set1_epi16(2)
    for y in 0 ..< resultEvenHeight:
      let
        topRowStart = src.dataIndex(0, y * 2)
        bottomRowStart = src.dataIndex(0, y * 2 + 1)

      template loadEven(src: Image, idx: int): M128i =
        var
          a = mm_loadu_si128(src.data[idx].addr)
          b = mm_loadu_si128(src.data[idx + 4].addr)
        a = mm_shuffle_epi32(a, MM_SHUFFLE(3, 3, 2, 0))
        b = mm_shuffle_epi32(b, MM_SHUFFLE(2, 0, 3, 3))
        a = mm_and_si128(a, loMask)
        b = mm_and_si128(b, hiMask)
        mm_or_si128(a, b)

      var x: int
      while x <= resultEvenWidth - 9:
        let
          top = loadEven(src, topRowStart + x * 2)
          bottom = loadEven(src, bottomRowStart + x * 2)
          topShifted = loadEven(src, topRowStart + x * 2 + 1)
          bottomShifted = loadEven(src, bottomRowStart + x * 2 + 1)
          topEven = mm_andnot_si128(oddMask, top)
          topOdd = mm_srli_epi16(top, 8)
          bottomEven = mm_andnot_si128(oddMask, bottom)
          bottomOdd = mm_srli_epi16(bottom, 8)
          topShiftedEven = mm_andnot_si128(oddMask, topShifted)
          topShiftedOdd = mm_srli_epi16(topShifted, 8)
          bottomShiftedEven = mm_andnot_si128(oddMask, bottomShifted)
          bottomShiftedOdd = mm_srli_epi16(bottomShifted, 8)
          topAddedEven = mm_add_epi16(topEven, topShiftedEven)
          bottomAddedEven = mm_add_epi16(bottomEven, bottomShiftedEven)
          topAddedOdd = mm_add_epi16(topOdd, topShiftedOdd)
          bottomAddedOdd = mm_add_epi16(bottomOdd, bottomShiftedOdd)
          addedEven = mm_add_epi16(topAddedEven, bottomAddedEven)
          addedOdd = mm_add_epi16(topAddedOdd, bottomAddedOdd)
          addedEvenRounding = mm_add_epi16(addedEven, vec2)
          addedOddRounding = mm_add_epi16(addedOdd, vec2)
          addedEvenDiv4 = mm_srli_epi16(addedEvenRounding, 2)
          addedOddDiv4 = mm_srli_epi16(addedOddRounding, 2)
          merged = mm_or_si128(addedEvenDiv4, mm_slli_epi16(addedOddDiv4, 8))
        mm_storeu_si128(result.data[result.dataIndex(x, y)].addr, merged)
        x += 4

      for x in x ..< resultEvenWidth:
        let
          a = src.data[topRowStart + x * 2]
          b = src.data[topRowStart + x * 2 + 1]
          c = src.data[bottomRowStart + x * 2 + 1]
          d = src.data[bottomRowStart + x * 2]
          mixed = rgbx(
            ((a.r.uint32 + b.r + c.r + d.r + 2) div 4).uint8,
            ((a.g.uint32 + b.g + c.g + d.g + 2) div 4).uint8,
            ((a.b.uint32 + b.b + c.b + d.b + 2) div 4).uint8,
            ((a.a.uint32 + b.a + c.a + d.a + 2) div 4).uint8
          )
        result.data[result.dataIndex(x, y)] = mixed

      if srcWidthIsOdd:
        let rgbx = mix(
          src.data[src.dataIndex(src.width - 1, y * 2 + 0)],
          src.data[src.dataIndex(src.width - 1, y * 2 + 1)],
          0.5
        ) * 0.5
        result.data[result.dataIndex(result.width - 1, y)] = rgbx

    if srcHeightIsOdd:
      for x in 0 ..< resultEvenWidth:
        let rgbx = mix(
          src.data[src.dataIndex(x * 2 + 0, src.height - 1)],
          src.data[src.dataIndex(x * 2 + 1, src.height - 1)],
          0.5
        ) * 0.5
        result.data[result.dataIndex(x, result.height - 1)] = rgbx

      if srcWidthIsOdd:
        result.data[result.dataIndex(result.width - 1, result.height - 1)] =
          src.data[src.dataIndex(src.width - 1, src.height - 1)] * 0.25

    # Set src as this result for if we do another power
    src = result

proc magnifyBy2Sse2*(image: Image, power = 1): Image {.simd.} =
  ## Scales image up by 2 ^ power.
  if power < 0:
    raise newException(PixieError, "Cannot magnifyBy2 with negative power")

  let scale = 2 ^ power
  result = newImage(image.width * scale, image.height * scale)

  for y in 0 ..< image.height:
    # Write one row of pixels duplicated by scale
    let
      sourceRowStart = image.dataIndex(0, y)
      resultRowStart = result.dataIndex(0, y * scale)
    var x: int
    if scale == 2:
      while x <= image.width - 4:
        let values = mm_loadu_si128(image.data[sourceRowStart + x].addr)
        mm_storeu_si128(
          result.data[resultRowStart + x * scale].addr,
          mm_unpacklo_epi32(values, values)
        )
        mm_storeu_si128(
          result.data[resultRowStart + x * scale + 4].addr,
          mm_unpackhi_epi32(values, values)
        )
        x += 4
    for x in x ..< image.width:
      let
        rgbx = image.data[sourceRowStart + x]
        resultIdx = resultRowStart + x * scale
      for i in 0 ..< scale:
        result.data[resultIdx + i] = rgbx
    # Copy that row of pixels into (scale - 1) more rows
    for i in 1 ..< scale:
      copyMem(
        result.data[resultRowStart + result.width * i].addr,
        result.data[resultRowStart].addr,
        result.width * 4
      )

template applyCoverage(rgbxVec, coverage: M128i): M128i =
  ## Unpack the first 4 coverage bytes.
  var unpacked = mm_unpacklo_epi8(mm_setzero_si128(), coverage)
  unpacked = mm_unpacklo_epi8(mm_setzero_si128(), unpacked)
  unpacked = mm_or_si128(unpacked, mm_srli_epi32(unpacked, 16))

  var
    rgbxEven = mm_slli_epi16(rgbxVec, 8)
    rgbxOdd = mm_and_si128(rgbxVec, oddMask)
  rgbxEven = mm_mulhi_epu16(rgbxEven, unpacked)
  rgbxOdd = mm_mulhi_epu16(rgbxOdd, unpacked)
  rgbxEven = mm_srli_epi16(mm_mulhi_epu16(rgbxEven, div255), 7)
  rgbxOdd = mm_srli_epi16(mm_mulhi_epu16(rgbxOdd, div255), 7)

  mm_or_si128(rgbxEven, mm_slli_epi16(rgbxOdd, 8))

proc blendLineCoverageOverwriteSse2*(
  line: ptr UncheckedArray[ColorRGBX],
  coverages: ptr UncheckedArray[uint8],
  rgbx: ColorRGBX,
  len: int
) {.simd.} =
  var i: int
  while i < len and (cast[uint](line[i].addr) and 15) != 0:
    let coverage = coverages[i]
    if coverage != 0:
      line[i] = rgbx * coverage
    inc i

  let
    rgbxVec = mm_set1_epi32(cast[uint32](rgbx))
    vecZero = mm_setzero_si128()
    vec255 = mm_set1_epi8(255)
    oddMask = mm_set1_epi16(0xff00)
    div255 = mm_set1_epi16(0x8081)
  while i < len - 16:
    let
      coverage = mm_loadu_si128(coverages[i].addr)
      eqZero = mm_cmpeq_epi8(coverage, vecZero)
      eq255 = mm_cmpeq_epi8(coverage, vec255)
    if mm_movemask_epi8(eqZero) == 0xffff:
      i += 16
    elif mm_movemask_epi8(eq255) == 0xffff:
      for _ in 0 ..< 4:
        mm_store_si128(line[i].addr, rgbxVec)
        i += 4
    else:
      var coverage = coverage
      for _ in 0 ..< 4:
        mm_store_si128(line[i].addr, rgbxVec.applyCoverage(coverage))
        coverage = mm_srli_si128(coverage, 4)
        i += 4

  for i in i ..< len:
    let coverage = coverages[i]
    if coverage != 0:
      line[i] = rgbx * coverage

proc blendLineNormalSse2*(
  line: ptr UncheckedArray[ColorRGBX], rgbx: ColorRGBX, len: int
) {.simd.} =
  var i: int
  while i < len and (cast[uint](line[i].addr) and 15) != 0:
    line[i] = blendNormal(line[i], rgbx)
    inc i

  let
    source = mm_set1_epi32(cast[uint32](rgbx))
    alphaMask = mm_set1_epi32(cast[int32](0xff000000))
    oddMask = mm_set1_epi16(cast[int16](0xff00))
    div255 = mm_set1_epi16(cast[int16](0x8081))
    vecAlpha255 = mm_set1_epi32(cast[int32]([0.uint8, 255, 0, 255]))
  while i < len - 4:
    let backdrop = mm_load_si128(line[i].addr)
    mm_store_si128(line[i].addr, blendNormalSimd(backdrop, source))
    i += 4

  for i in i ..< len:
    line[i] = blendNormal(line[i], rgbx)

proc blendLineNormalSse2*(
  a, b: ptr UncheckedArray[ColorRGBX], len: int
) {.simd.} =
  var i: int
  while i < len and (cast[uint](a[i].addr) and 15) != 0:
    a[i] = blendNormal(a[i], b[i])
    inc i

  let
    alphaMask = mm_set1_epi32(cast[int32](0xff000000))
    oddMask = mm_set1_epi16(cast[int16](0xff00))
    div255 = mm_set1_epi16(cast[int16](0x8081))
    vec255 = mm_set1_epi8(255)
    vecAlpha255 = mm_set1_epi32(cast[int32]([0.uint8, 255, 0, 255]))
  while i < len - 4:
    let
      source = mm_loadu_si128(b[i].addr)
      eq255 = mm_cmpeq_epi8(source, vec255)
    if (mm_movemask_epi8(eq255) and 0x00008888) == 0x00008888: # Opaque source
      mm_store_si128(a[i].addr, source)
    else:
      let backdrop = mm_load_si128(a[i].addr)
      mm_store_si128(a[i].addr, blendNormalSimd(backdrop, source))
    i += 4

  for i in i ..< len:
    a[i] = blendNormal(a[i], b[i])

proc blendLineCoverageNormalSse2*(
  line: ptr UncheckedArray[ColorRGBX],
  coverages: ptr UncheckedArray[uint8],
  rgbx: ColorRGBX,
  len: int
) {.simd.} =
  var i: int
  while i < len and (cast[uint](line[i].addr) and 15) != 0:
    let coverage = coverages[i]
    if coverage == 0:
      discard
    else:
      line[i] = blendNormal(line[i], rgbx * coverage)
    inc i

  let
    rgbxVec = mm_set1_epi32(cast[uint32](rgbx))
    vecZero = mm_setzero_si128()
    vec255 = mm_set1_epi8(255)
    alphaMask = mm_set1_epi32(cast[int32](0xff000000))
    oddMask = mm_set1_epi16(cast[int16](0xff00))
    div255 = mm_set1_epi16(cast[int16](0x8081))
    vecAlpha255 = mm_set1_epi32(cast[int32]([0.uint8, 255, 0, 255]))
  while i < len - 16:
    let
      coverage = mm_loadu_si128(coverages[i].addr)
      eqZero = mm_cmpeq_epi8(coverage, vecZero)
      eq255 = mm_cmpeq_epi8(coverage, vec255)
    if mm_movemask_epi8(eqZero) == 0xffff:
      i += 16
    elif mm_movemask_epi8(eq255) == 0xffff and rgbx.a == 255:
      for _ in 0 ..< 4:
        mm_store_si128(line[i].addr, rgbxVec)
        i += 4
    else:
      var coverage = coverage
      for _ in 0 ..< 4:
        let
          backdrop = mm_loadu_si128(line[i].addr)
          source = rgbxVec.applyCoverage(coverage)
        mm_store_si128(line[i].addr, blendNormalSimd(backdrop, source))
        coverage = mm_srli_si128(coverage, 4)
        i += 4

  for i in i ..< len:
    let coverage = coverages[i]
    if coverage == 0:
      discard
    else:
      line[i] = blendNormal(line[i], rgbx * coverage)

proc blendLineMaskSse2*(
  line: ptr UncheckedArray[ColorRGBX], rgbx: ColorRGBX, len: int
) {.simd.} =
  var i: int
  while i < len and (cast[uint](line[i].addr) and 15) != 0:
    line[i] = blendMask(line[i], rgbx)
    inc i

  let
    source = mm_set1_epi32(cast[uint32](rgbx))
    alphaMask = mm_set1_epi32(cast[int32](0xff000000))
    oddMask = mm_set1_epi16(cast[int16](0xff00))
    div255 = mm_set1_epi16(cast[int16](0x8081))
  while i < len - 4:
    let backdrop = mm_load_si128(line[i].addr)
    mm_store_si128(line[i].addr, blendMaskSimd(backdrop, source))
    i += 4

  for i in i ..< len:
    line[i] = blendMask(line[i], rgbx)

proc blendLineMaskSse2*(
  a, b: ptr UncheckedArray[ColorRGBX], len: int
) {.simd.} =
  var i: int
  while i < len and (cast[uint](a[i].addr) and 15) != 0:
    a[i] = blendMask(a[i], b[i])
    inc i

  let
    alphaMask = mm_set1_epi32(cast[int32](0xff000000))
    oddMask = mm_set1_epi16(cast[int16](0xff00))
    div255 = mm_set1_epi16(cast[int16](0x8081))
    vec255 = mm_set1_epi8(255)
  while i < len - 4:
    let
      source = mm_loadu_si128(b[i].addr)
      eq255 = mm_cmpeq_epi8(source, vec255)
    if (mm_movemask_epi8(eq255) and 0x00008888) == 0x00008888: # Opaque source
      discard
    else:
      let backdrop = mm_load_si128(a[i].addr)
      mm_store_si128(a[i].addr, blendMaskSimd(backdrop, source))
    i += 4

  for i in i ..< len:
    a[i] = blendMask(a[i], b[i])

proc blendLineCoverageMaskSse2*(
  line: ptr UncheckedArray[ColorRGBX],
  coverages: ptr UncheckedArray[uint8],
  rgbx: ColorRGBX,
  len: int
) {.simd.} =
  var i: int
  while i < len and (cast[uint](line[i].addr) and 15) != 0:
    let coverage = coverages[i]
    if coverage == 0:
      line[i] = rgbx(0, 0, 0, 0)
    elif coverage == 255:
      discard
    else:
      line[i] = blendMask(line[i], rgbx * coverage)
    inc i

  let
    rgbxVec = mm_set1_epi32(cast[uint32](rgbx))
    vecZero = mm_setzero_si128()
    vec255 = mm_set1_epi8(255)
    alphaMask = mm_set1_epi32(cast[int32](0xff000000))
    oddMask = mm_set1_epi16(cast[int16](0xff00))
    div255 = mm_set1_epi16(cast[int16](0x8081))
  while i < len - 16:
    let
      coverage = mm_loadu_si128(coverages[i].addr)
      eqZero = mm_cmpeq_epi8(coverage, vecZero)
      eq255 = mm_cmpeq_epi8(coverage, vec255)
    if mm_movemask_epi8(eqZero) == 0xffff:
      for _ in 0 ..< 4:
        mm_store_si128(line[i].addr, vecZero)
        i += 4
    elif mm_movemask_epi8(eq255) == 0xffff and rgbx.a == 255:
      i += 16
    else:
      var coverage = coverage
      for _ in 0 ..< 4:
        let
          backdrop = mm_loadu_si128(line[i].addr)
          source = rgbxVec.applyCoverage(coverage)
        mm_store_si128(line[i].addr, blendMaskSimd(backdrop, source))
        coverage = mm_srli_si128(coverage, 4)
        i += 4

  for i in i ..< len:
    let coverage = coverages[i]
    if coverage == 0:
      line[i] = rgbx(0, 0, 0, 0)
    elif coverage == 255:
      discard
    else:
      line[i] = blendMask(line[i], rgbx * coverage)

when defined(release):
  {.pop.}



================================================
FILE: tests/all.nim
================================================
import
  test_bmp,
  test_contexts,
  test_fonts,
  test_gif,
  test_images,
  test_images_draw,
  test_jpeg,
  test_paints,
  test_paths,
  test_png,
  test_ppm,
  test_qoi,
  test_svg,
  ../examples/text,
  ../examples/text_spans,
  ../examples/square,
  ../examples/line,
  ../examples/rounded_rectangle,
  ../examples/heart,
  ../examples/masking,
  ../examples/gradient,
  ../examples/image_tiled,
  ../examples/shadow,
  ../examples/blur,
  ../examples/tiger



================================================
FILE: tests/bench_blends.nim
================================================
import benchy, chroma, pixie/blends, pixie/images, vmath

let
  backdrop = newImage(256, 256)
  source = newImage(256, 256)
source.fill(rgba(100, 100, 100, 100))

template reset() =
  backdrop.fill(rgba(0, 0, 0, 255))

reset()

timeIt "blendNormal":
  for i in 0 ..< backdrop.data.len:
    backdrop.data[i] = blendNormal(backdrop.data[i], source.data[i])

reset()

timeIt "blendDarken":
  for i in 0 ..< backdrop.data.len:
    backdrop.data[i] = blendDarken(backdrop.data[i], source.data[i])

reset()

timeIt "blendMultiply":
  for i in 0 ..< backdrop.data.len:
    backdrop.data[i] = blendMultiply(backdrop.data[i], source.data[i])

# reset()

# timeIt "blendLinearBurn":
#   for i in 0 ..< backdrop.data.len:
#     backdrop.data[i] = blendLinearBurn(backdrop.data[i], source.data[i])

reset()

timeIt "blendColorBurn":
  for i in 0 ..< backdrop.data.len:
    backdrop.data[i] = blendColorBurn(backdrop.data[i], source.data[i])

reset()

timeIt "blendLighten":
  for i in 0 ..< backdrop.data.len:
    backdrop.data[i] = blendLighten(backdrop.data[i], source.data[i])

reset()

timeIt "blendScreen":
  for i in 0 ..< backdrop.data.len:
    backdrop.data[i] = blendScreen(backdrop.data[i], source.data[i])

# reset()

# timeIt "blendLinearDodge":
#   for i in 0 ..< backdrop.data.len:
#     backdrop.data[i] = blendLinearDodge(backdrop.data[i], source.data[i])

reset()

timeIt "blendColorDodge":
  for i in 0 ..< backdrop.data.len:
    backdrop.data[i] = blendColorDodge(backdrop.data[i], source.data[i])

reset()

timeIt "blendOverlay":
  for i in 0 ..< backdrop.data.len:
    backdrop.data[i] = blendOverlay(backdrop.data[i], source.data[i])

reset()

timeIt "blendSoftLight":
  for i in 0 ..< backdrop.data.len:
    backdrop.data[i] = blendSoftLight(backdrop.data[i], source.data[i])

reset()

timeIt "blendHardLight":
  for i in 0 ..< backdrop.data.len:
    backdrop.data[i] = blendHardLight(backdrop.data[i], source.data[i])

reset()

timeIt "blendDifference":
  for i in 0 ..< backdrop.data.len:
    backdrop.data[i] = blendDifference(backdrop.data[i], source.data[i])

reset()

timeIt "blendExclusion":
  for i in 0 ..< backdrop.data.len:
    backdrop.data[i] = blendExclusion(backdrop.data[i], source.data[i])

reset()

timeIt "blendHue":
  for i in 0 ..< backdrop.data.len:
    backdrop.data[i] = blendHue(backdrop.data[i], source.data[i])

reset()

timeIt "blendSaturation":
  for i in 0 ..< backdrop.data.len:
    backdrop.data[i] = blendSaturation(backdrop.data[i], source.data[i])

reset()

timeIt "blendColor":
  for i in 0 ..< backdrop.data.len:
    backdrop.data[i] = blendColor(backdrop.data[i], source.data[i])

reset()

timeIt "blendLuminosity":
  for i in 0 ..< backdrop.data.len:
    backdrop.data[i] = blendLuminosity(backdrop.data[i], source.data[i])

reset()

timeIt "blendMask":
  for i in 0 ..< backdrop.data.len:
    backdrop.data[i] = blendMask(backdrop.data[i], source.data[i])

reset()

timeIt "blendSubtractMask":
  for i in 0 ..< backdrop.data.len:
    backdrop.data[i] = blendSubtractMask(backdrop.data[i], source.data[i])

reset()

timeIt "blendExcludeMask":
  for i in 0 ..< backdrop.data.len:
    backdrop.data[i] = blendExcludeMask(backdrop.data[i], source.data[i])



================================================
FILE: tests/bench_fonts.nim
================================================
import benchy, pixie

const text = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis in quam in nulla bibendum luctus. Integer dui lectus, ultricies commodo enim quis, laoreet lacinia erat. Vivamus ultrices maximus risus, non aliquam quam sagittis quis. Ut nec diam vitae tortor interdum ullamcorper in aliquet velit. Ut sed lobortis mi. Nulla venenatis lectus varius justo lacinia, quis sollicitudin nunc ultrices. Donec a suscipit arcu, id egestas neque. Nullam commodo pharetra est. Nullam gravida nibh eget quam venenatis lacinia. Vestibulum et libero arcu. Sed dignissim enim eros. Nullam eleifend luctus erat sed luctus. Nunc tincidunt, mi nec tincidunt tristique, ex nulla lobortis sem, sit amet finibus purus justo non massa."

var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
font.size = 16

let image = newImage(500, 300)

timeIt "typeset":
  discard font.typeset(text, bounds = vec2(image.width.float32, 0))

timeIt "fill text":
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(font, text, bounds = vec2(image.width.float32, 0))



================================================
FILE: tests/bench_gif.nim
================================================
import benchy, pixie/fileformats/gif

let data = readFile("tests/fileformats/gif/audrey.gif")

timeIt "gif decode":
  discard decodeGif(data)



================================================
FILE: tests/bench_images.nim
================================================
import benchy, chroma, pixie, pixie/internal

let image = newImage(2560, 1440)

proc reset() =
  image.fill(rgba(63, 127, 191, 191))

reset()

timeIt "fill":
  image.fill(rgba(255, 255, 255, 255))
  doAssert image[0, 0] == rgba(255, 255, 255, 255)

reset()

timeIt "fill_rgba":
  image.fill(rgba(63, 127, 191, 191))
  doAssert image[0, 0] == rgba(63, 127, 191, 191)

image.fill(rgba(100, 0, 100, 100))
timeIt "isOneColor":
  doAssert image.isOneColor()

image.fill(rgba(0, 0, 0, 0))
timeIt "isTransparent":
  doAssert image.isTransparent()

image.fill(rgba(255, 255, 255, 255))
timeIt "isOpaque":
  doAssert image.isOpaque()

reset()

timeIt "subImage":
  discard image.subImage(0, 0, 256, 256)

reset()

timeIt "superImage":
  discard image.superImage(-10, -10, 2580, 1460)

reset()

timeIt "minifyBy2":
  let minified = image.minifyBy2()
  doAssert minified[0, 0] == rgba(63, 127, 191, 191)

reset()

timeIt "magnifyBy2":
  let minified = image.magnifyBy2()
  doAssert minified[0, 0] == rgba(63, 127, 191, 191)

reset()

timeIt "flipHorizontal":
  image.flipHorizontal()

reset()

timeIt "flipVertical":
  image.flipVertical()

reset()

timeIt "rotate90":
  image.rotate90()

reset()

timeIt "invert":
  image.invert()

reset()

timeIt "applyOpacity":
  reset()
  image.applyOpacity(0.5)

reset()

timeIt "toPremultipliedAlpha":
  image.data.toPremultipliedAlpha()

reset()

timeIt "toStraightAlpha":
  image.data.toStraightAlpha()

reset()

timeIt "ceil":
  reset()
  image.ceil()

block:
  let image = newImage(200, 200)
  image.fill(rgbx(255, 0, 0, 255))

  timeIt "blur":
    image.blur(20)

reset()

timeIt "mix integers":
  for i in 0 ..< 100000:
    let c = image[0, 0]
    var z: int
    for t in 0 .. 100:
      z += mix(c, c, t.float32 / 100).a.int
    doAssert z > 0

timeIt "mix floats":
  for i in 0 ..< 1000:
    let c = image[0, 0].color
    var z: int
    for t in 0 .. 100:
      z += mix(c, c, t.float32 / 100).rgba().a.int
    doAssert z > 0



================================================
FILE: tests/bench_images_draw.nim
================================================
import benchy, chroma, pixie, random, vmath

block:
  let
    a = newImage(1000, 1000)
    b = newImage(500, 500)
  a.fill(rgba(255, 0, 0, 255))
  b.fill(rgba(0, 255, 0, 255))

  timeIt "big-on-bigger NormalBlend":
    a.draw(b, translate(vec2(25, 25)), NormalBlend)

block:
  let
    a = newImage(1000, 1000)
    b = newImage(500, 500)
  a.fill(rgba(255, 0, 0, 255))
  b.fill(rgba(0, 255, 0, 255))

  timeIt "big-on-bigger MaskBlend":
    a.draw(b, translate(vec2(25, 25)), MaskBlend)

block:
  let
    a = newImage(1000, 1000)
    b = newImage(500, 500)
  a.fill(rgba(255, 0, 0, 255))
  b.fill(rgba(0, 255, 0, 255))

  timeIt "big-on-bigger OverwriteBlend":
    a.draw(b, translate(vec2(25, 25)), OverwriteBlend)

block:
  let
    a = newImage(1000, 1000)
    b = newImage(500, 500)
  a.fill(rgba(255, 0, 0, 255))
  b.fill(rgba(0, 255, 0, 255))

  timeIt "scale x0.5":
    a.draw(b, translate(vec2(25, 25)) * scale(vec2(0.5, 0.5)), NormalBlend)

block:
  let
    a = newImage(1000, 1000)
    b = newImage(500, 500)
  a.fill(rgba(255, 0, 0, 255))
  b.fill(rgba(0, 255, 0, 255))

  timeIt "scale x2":
    a.draw(b, translate(vec2(25, 25)) * scale(vec2(2, 2)), NormalBlend)

block:
  let
    a = newImage(1000, 1000)
    b = newImage(500, 500)
  a.fill(rgba(255, 0, 0, 255))
  b.fill(rgba(0, rand(255).uint8, 0, 255))

  timeIt "smooth x-translate":
    a.draw(b, translate(vec2(25.2, 0)), NormalBlend)

block:
  let
    a = newImage(1000, 1000)
    b = newImage(500, 500)
  a.fill(rgba(255, 0, 0, 255))
  b.fill(rgba(0, rand(255).uint8, 0, 255))

  timeIt "smooth y-translate":
    a.draw(b, translate(vec2(0, 25.2)), NormalBlend)

block:
  let
    a = newImage(1000, 1000)
    b = newImage(500, 500)
  a.fill(rgba(255, 0, 0, 255))
  b.fill(rgba(0, rand(255).uint8, 0, 255))

  timeIt "smooth translate":
    a.draw(b, translate(vec2(25.2, 25.2)), NormalBlend)

block:
  let
    a = newImage(1000, 1000)
    b = newImage(500, 500)
  a.fill(rgba(255, 0, 0, 255))
  b.fill(rgba(0, rand(255).uint8, 0, 255))

  timeIt "smooth rotate 45":
    a.draw(b, translate(vec2(0, 500)) * rotate(toRadians(45)), NormalBlend)

block:
  let
    a = newImage(100, 100)
    b = newImage(50, 50)

  timeIt "shadow no offset":
    b.fill(rgba(0, 0, 0, 255))
    a.draw(b, translate(vec2(25, 25)))
    discard a.shadow(
      offset = vec2(0, 0),
      spread = 10,
      blur = 10,
      color = rgba(0, 0, 0, 255)
    )

block:
  let
    a = newImage(100, 100)
    b = newImage(50, 50)

  timeIt "shadow with offset":
    b.fill(rgba(0, 0, 0, 255))
    a.draw(b, translate(vec2(25, 25)))
    discard a.shadow(
      offset = vec2(10, 10),
      spread = 10,
      blur = 10,
      color = rgba(0, 0, 0, 255)
    )



================================================
FILE: tests/bench_jpeg.nim
================================================
import benchy, os, pixie/fileformats/jpeg

const
  jpegFiles* = [
    "tests/fileformats/jpeg/masters/mandrill.jpg",
    "tests/fileformats/jpeg/masters/exif_overrun.jpg",
    "tests/fileformats/jpeg/masters/grayscale_test.jpg",
    "tests/fileformats/jpeg/masters/progressive.jpg"
  ]

for file in jpegFiles:
  let data = readFile(file)
  timeIt "pixie " & file.splitPath.tail & " decode":
    discard decodeJpeg(data)

# import stb_image/read as stbi
# block:
#   for file in jpegFiles:
#     let data = readFile(file)
#     var name = file.splitPath.tail

#     timeIt "stb " & file.splitPath.tail & " decode":
#       var width, height, channels: int
#       discard loadFromMemory(
#         cast[seq[byte]](data),
#         width,
#         height,
#         channels,
#         stbi.RGBA
#       )



================================================
FILE: tests/bench_paints.nim
================================================
import benchy, pixie

let image = newImage(1000, 1000)

timeIt "GradientLinear vertical":
  let paint = newPaint(LinearGradientPaint)
  paint.gradientHandlePositions = @[
    vec2(50, 0),
    vec2(50, 1000),
  ]
  paint.gradientStops = @[
    ColorStop(color: color(1, 0, 0, 1), position: 0),
    ColorStop(color: color(1, 0, 0, 0.15625), position: 1.0),
  ]
  image.fillGradient(paint)

timeIt "GradientLinear horizontal":
  let paint = newPaint(LinearGradientPaint)
  paint.gradientHandlePositions = @[
    vec2(0, 50),
    vec2(1000, 50),
  ]
  paint.gradientStops = @[
    ColorStop(color: color(1, 0, 0, 1), position: 0),
    ColorStop(color: color(1, 0, 0, 0.15625), position: 1.0),
  ]
  image.fillGradient(paint)

# timeIt "GradientLinear radial":
#   discard

let image100 = newImage(100, 100)

timeIt "GradientLinear angular":
  let paint = newPaint(AngularGradientPaint)
  paint.gradientHandlePositions = @[
    vec2(500, 500),
    vec2(1000, 500),
    vec2(500, 1000)
  ]
  paint.gradientStops = @[
    ColorStop(color: color(1, 0, 0, 1), position: 0),
    ColorStop(color: color(1, 0, 0, 0.15625), position: 1.0),
  ]
  image100.fillGradient(paint)



================================================
FILE: tests/bench_paths.nim
================================================
import benchy, pixie

let pathStr = "m57.611-8.591c-1.487,1.851-4.899,4.42-1.982,6.348,0.194,0.129,0.564,0.133,0.737-0.001,2.021-1.565,4.024-2.468,6.46-3.05,0.124-0.029,0.398,0.438,0.767,0.277,1.613-0.703,3.623-0.645,4.807-1.983,3.767,0.224,7.332-0.892,10.723-2.2,1.161-0.448,2.431-1.007,3.632-1.509,1.376-0.576,2.58-1.504,3.692-2.645,0.133-0.136,0.487-0.046,0.754-0.046-0.04-0.863,0.922-0.99,1.169-1.612,0.092-0.232-0.058-0.628,0.075-0.73,2.138-1.63,3.058-3.648,1.889-6.025-0.285-0.578-0.534-1.196-1.1-1.672-1.085-0.911-2.187-0.057-3.234-0.361-0.159,0.628-0.888,0.456-1.274,0.654-0.859,0.439-2.192-0.146-3.051,0.292-1.362,0.695-2.603,0.864-4.025,1.241-0.312,0.082-1.09-0.014-1.25,0.613-0.134-0.134-0.282-0.368-0.388-0.346-1.908,0.396-3.168,0.61-4.469,2.302-0.103,0.133-0.545-0.046-0.704,0.089-0.957,0.808-1.362,2.042-2.463,2.714-0.201,0.123-0.553-0.045-0.747,0.084-0.646,0.431-1.013,1.072-1.655,1.519-0.329,0.229-0.729-0.096-0.697-0.352,0.245-1.947,0.898-3.734,0.323-5.61,2.077-2.52,4.594-4.469,6.4-7.2,0.015-2.166,0.707-4.312,0.594-6.389-0.01-0.193-0.298-0.926-0.424-1.273-0.312-0.854,0.594-1.92-0.25-2.644-1.404-1.203-2.696-0.327-3.52,1.106-1.838,0.39-3.904,1.083-5.482-0.151-1.007-0.787-1.585-1.693-2.384-2.749-0.985-1.302-0.65-2.738-0.58-4.302,0.006-0.128-0.309-0.264-0.309-0.398,0.001-0.135,0.221-0.266,0.355-0.4-0.706-0.626-0.981-1.684-2-2,0.305-1.092-0.371-1.976-1.242-2.278-1.995-0.691-3.672,1.221-5.564,1.294-0.514,0.019-0.981-1.019-1.63-1.344-0.432-0.216-1.136-0.249-1.498,0.017-0.688,0.504-1.277,0.618-2.035,0.823-1.617,0.436-2.895,1.53-4.375,2.385-1.485,0.857-2.44,2.294-3.52,3.614-0.941,1.152-1.077,3.566,0.343,4.066,1.843,0.65,3.147-2.053,5.113-1.727,0.312,0.051,0.518,0.362,0.408,0.75,0.389,0.109,0.607-0.12,0.8-0.4,0.858,1.019,2.022,1.356,2.96,2.229,0.97,0.904,2.716,0.486,3.731,1.483,1.529,1.502,0.97,4.183,2.909,5.488-0.586,1.313-1.193,2.59-1.528,4.017-0.282,1.206,0.712,2.403,1.923,2.312,1.258-0.094,1.52-0.853,2.005-1.929,0.267,0.267,0.736,0.564,0.695,0.78-0.457,2.387-1.484,4.38-1.942,6.811-0.059,0.317-0.364,0.519-0.753,0.409-0.468,4.149-4.52,6.543-7.065,9.708-0.403,0.502-0.407,1.751,0.002,2.154,1.403,1.387,3.363-0.159,5.063-0.662,0.213-1.206,1.072-2.148,2.404-2.092,0.256,0.01,0.491-0.532,0.815-0.662,0.348-0.138,0.85,0.086,1.136-0.112,1.729-1.195,3.137-2.301,4.875-3.49,0.192-0.131,0.536,0.028,0.752-0.08,0.325-0.162,0.512-0.549,0.835-0.734,0.348-0.2,0.59,0.09,0.783,0.37-0.646,0.349-0.65,1.306-1.232,1.508-0.775,0.268-1.336,0.781-2.01,1.228-0.292,0.193-0.951-0.055-1.055,0.124-0.598,1.028-1.782,1.466-2.492,2.349z"

timeIt "parsePath":
  discard parsePath(pathStr)

block:
  let path = parsePath("""
    M 10,30
    A 20,20 0,0,1 50,30
    A 20,20 0,0,1 90,30
    Q 90,60 50,90
    Q 10,60 10,30 z
  """)
  timeIt "fillOverlaps":
    doAssert path.fillOverlaps(vec2(1, 1)) == false

const
  width = 500
  height = 300
  radius = 20

let paint = newPaint(SolidPaint)
paint.color = color(0, 0, 0, 0.5)

let rect = newPath()
rect.rect(10, 10, 480, 280)

let roundedRect = newPath()
roundedRect.roundedRect(10.5, 10.5, 479, 279, radius, radius, radius, radius)
# roundedRect.roundedRect(10, 10, 480, 280, radius, radius, radius, radius)

let image = newImage(width, height)

timeIt "rect OverwriteBlend":
  paint.blendMode = OverwriteBlend
  image.fillPath(rect, paint)

timeIt "rect NormalBlend":
  paint.blendMode = NormalBlend
  image.fillPath(rect, paint)

timeIt "rect MaskBlend":
  paint.blendMode = MaskBlend
  image.fill(rgbx(255, 255, 255, 255))
  image.fillPath(rect, paint)

timeIt "rect SubtractMaskBlend":
  paint.blendMode = SubtractMaskBlend
  image.fill(rgbx(255, 255, 255, 255))
  image.fillPath(rect, paint)

timeIt "rect ExcludeMaskBlend":
  paint.blendMode = ExcludeMaskBlend
  image.fill(rgbx(255, 255, 255, 255))
  image.fillPath(rect, paint)

timeIt "roundedRect OverwriteBlend":
  paint.blendMode = OverwriteBlend
  image.fillPath(roundedRect, paint)

timeIt "roundedRect NormalBlend":
  paint.blendMode = NormalBlend
  image.fillPath(roundedRect, paint)

timeIt "roundedRect MaskBlend":
  paint.blendMode = MaskBlend
  image.fill(rgbx(255, 255, 255, 255))
  image.fillPath(roundedRect, paint)

timeIt "roundedRect SubtractMaskBlend":
  paint.blendMode = SubtractMaskBlend
  image.fill(rgbx(255, 255, 255, 255))
  image.fillPath(roundedRect, paint)

timeIt "roundedRect ExcludeMaskBlend":
  paint.blendMode = ExcludeMaskBlend
  image.fill(rgbx(255, 255, 255, 255))
  image.fillPath(roundedRect, paint)



================================================
FILE: tests/bench_png.nim
================================================
import benchy, pixie/fileformats/png

let
  filePath = "tests/fileformats/png/lenna.png"
  data = readFile(filePath)

block:
  let
    decodedPng = decodePng(data)
    decodedImage = newImage(decodedPng)

  timeIt "pixie decode":
    discard decodePng(data)

  timeIt "pixie decode + alpha":
    discard decodePng(data).convertToImage()

  timeIt "pixie encode":
    discard encodePng(decodedPng)

  timeIt "pixie encode + alpha":
    discard encodePng(decodedImage)

# import nimPNG
# block:
#   timeIt "nimPNG decode":
#     discard decodePNG32(data)

#   let decoded = decodePNG32(data)
#   timeIt "nimPNG encode":
#     discard encodePNG32(decoded.data, decoded.width, decoded.height)

# import stb_image/read as stbi, stb_image/write as stbr
# block:
#   timeIt "stb_image decode":
#     var width, height, channels: int
#     discard loadFromMemory(
#       cast[seq[byte]](data),
#       width,
#       height,
#       channels,
#       stbi.RGBA
#     )

#   var width, height, channels: int
#   let decoded = loadFromMemory(
#     cast[seq[byte]](data),
#     width,
#     height,
#     channels,
#     stbi.RGBA
#   )

#   timeIt "stb_image encode":
#     discard writePNG(width, height, channels, decoded).len

# import cairo
# block:
#   timeIt "cairo decode":
#     discard imageSurfaceCreateFromPng(filePath.cstring)

#   let decoded = imageSurfaceCreateFromPng(filePath.cstring)
#   timeIt "cairo encode":
#     var write: WriteFunc =
#       proc(closure: pointer, data: cstring, len: int32): Status {.cdecl.} =
#         StatusSuccess
#     discard decoded.writeToPng(write, nil)



================================================
FILE: tests/bench_qoi.nim
================================================
import benchy, pixie/fileformats/qoi

let data = readFile("tests/fileformats/qoi/testcard_rgba.qoi")

timeIt "pixie decode":
  discard decodeQoi(data)



================================================
FILE: tests/bench_svg.nim
================================================
import benchy, pixie/fileformats/svg

let
  data = readFile("tests/fileformats/svg/Ghostscript_Tiger.svg")
  parsed = parseSvg(data)

timeIt "svg render":
  discard newImage(parsed)



================================================
FILE: tests/common.nim
================================================
import algorithm, os

proc findAllFonts*(rootPath: string): seq[string] =
  for fontPath in walkDirRec(rootPath):
    if splitFile(fontPath).ext in [".ttf", ".otf"]:
      result.add(fontPath)
  result.sort()



================================================
FILE: tests/config.nims
================================================
--path:"../src"



================================================
FILE: tests/fuzz_bmp.nim
================================================
import flatty/binny, os, pixie/common, pixie/fileformats/bmp, random, strformat

randomize()

var originals = @["tests/fileformats/bmp/knight.32.bmp"]
for file in walkFiles("tests/fileformats/bmp/bmpsuite/*"):
  originals.add(file)

for i in 0 ..< 1000:
  let file = originals[rand(originals.len-1)]
  var data = readFile(file)
  let
    pos = rand(data.len-1)
    value = rand(255).char
    # pos = 27355
    # value = '&'
  data[pos] = value

  let
    width = data.readInt32(18).int
    height = data.readInt32(22).int
  if abs(width) > 1000 or abs(height) > 1000:
    echo "too big"
    continue

  echo &"{i} {file} {pos} {repr(value)}"
  try:
    let img = decodeBmp(data)
    doAssert img.height > 0 and img.width > 0
  except PixieError:
    discard

  data = data[0 ..< pos]
  try:
    let img = decodeBmp(data)
    doAssert img.height > 0 and img.width > 0
  except PixieError:
    discard



================================================
FILE: tests/fuzz_gif.nim
================================================
import pixie/common, pixie/fileformats/gif, random, strformat

randomize()

let original = readFile("tests/fileformats/gif/sunflower.gif")

for i in 0 ..< 10_000:
  var data = original
  let
    pos = rand(data.len)
    value = rand(255).char
    # pos = 27355
    # value = '&'
  data[pos] = value
  echo &"{i} {pos} {value}"
  try:
    let img = newImage(decodeGif(data))
    doAssert img.height > 0 and img.width > 0
  except PixieError:
    discard

  data = data[0 ..< pos]
  try:
    let img = newImage(decodeGif(data))
    doAssert img.height > 0 and img.width > 0
  except PixieError:
    discard



================================================
FILE: tests/fuzz_image_draw.nim
================================================
import pixie, random

randomize()

for i in 0 ..< 250:
  let a = newImage(rand(1 .. 20), rand(1 .. 20))
  for j in 0 ..< 25:
    let b = newImage(rand(1 .. 20), rand(1 .. 20))

    let translation = vec2(rand(-25..25).float32, rand(-25..25).float32)

    echo a, " ", b, " ", translation

    a.draw(b, translate(vec2(translation.x.trunc, translation.y.trunc)))
    a.draw(b, translate(translation))

for i in 0 ..< 250:
  let a = newImage(rand(1 .. 2000), rand(1 .. 2000))
  for j in 0 ..< 25:
    let b = newImage(rand(1 .. 1000), rand(1 .. 1000))

    let translation = vec2(rand(-2500..2500).float32, rand(-2500..2500).float32)

    echo a, " ", b, " ", translation

    a.draw(b, translate(vec2(translation.x.trunc, translation.y.trunc)))
    a.draw(b, translate(translation))

for i in 0 ..< 25:
  let a = newImage(rand(1 .. 20), rand(1 .. 20))
  for j in 0 ..< 25:
    let b = newImage(rand(1 .. 20), rand(1 .. 20))

    let
      translation = vec2(rand(25.0), rand(25.0)) - vec2(5, 5)
      rotation = rand(2 * PI).float32

    echo a, " ", b, " ", translation, " ", rotation

    a.draw(b, translate(vec2(translation.x, translation.y)))
    a.draw(b, translate(translation) * rotate(rotation))

for i in 0 ..< 25:
  let a = newImage(rand(1 .. 2000), rand(1 .. 2000))
  for j in 0 ..< 25:
    let b = newImage(rand(1 .. 1000), rand(1 .. 1000))

    let
      translation = vec2(rand(2500.0), rand(2500.0)) - vec2(500, 500)
      rotation = rand(2 * PI).float32

    echo a, " ", b, " ", translation, " ", rotation

    a.draw(b, translate(vec2(translation.x, translation.y)))
    a.draw(b, translate(translation) * rotate(rotation))



================================================
FILE: tests/fuzz_jpeg.nim
================================================
import jpegsuite, pixie/common, pixie/fileformats/jpeg, random, strformat

randomize()

for i in 0 ..< 10_000:
  let file = sample(jpegSuiteFiles)
  var data = readFile(file)
  let
    pos = rand(0 ..< data.len)
    value = rand(255).uint8
  data[pos] = value.char
  echo &"{i} {file} {pos} {value}"

  try:
    let img = decodeJpeg(data)
    doAssert img.height > 0 and img.width > 0
  except PixieError:
    discard
  data = data[0 ..< pos]
  try:
    let img = decodeJpeg(data)
    doAssert img.height > 0 and img.width > 0
  except PixieError:
    discard



================================================
FILE: tests/fuzz_leaks.nim
================================================
import pixie, random

when not defined(pixieLeakCheck):
  quit("Requires -d:pixieLeakCheck")

randomize()

for i in 0 ..< 100_000:

  let image = newImage(400, 400)
  image.fill(rgba(255, 255, 255, 255))

  let ctx = newContext(image)
  ctx.translate(200, 200)
  ctx.scale(vec2(rand(0.1 .. 1.2), rand(0.1 .. 1.2)))
  ctx.rotate(rand(0.0 .. 2*PI))

  ctx.strokeStyle = "#000000"
  ctx.lineCap = sample([RoundCap, ButtCap, SquareCap])
  ctx.lineJoin = sample([MiterJoin, RoundJoin, BevelJoin])
  ctx.miterLimit = 2
  ctx.lineWidth = rand(0.1 .. 20.0)

  ctx.moveTo(rand(-100 .. 100).float32, rand(-100 .. 100).float32)
  for i in 0 ..< rand(0 .. 100):
    ctx.lineTo(rand(-100 .. 100).float32, rand(-100 .. 100).float32)
  ctx.stroke()

  # image.writeFile("tests/fuzz_leaks.png")
  # break



================================================
FILE: tests/fuzz_leaks2.nim
================================================
import os, pixie, random

when not defined(pixieLeakCheck):
  quit("Requires -d:pixieLeakCheck")

randomize()

for i in 0 ..< 100_000:
  let image = newImage(400, 400)
  image.fill(rgba(255, 255, 255, 255))

  let ctx = newContext(image)

  ctx.translate(200, 200)
  ctx.scale(vec2(rand(0.1 .. 1.7), rand(0.1 .. 1.7)))
  ctx.rotate(rand(0.0 .. 2*PI))

  ctx.strokeStyle = "#000000"
  ctx.lineCap = sample([RoundCap, ButtCap, SquareCap])
  ctx.lineJoin = sample([MiterJoin, RoundJoin, BevelJoin])
  ctx.lineWidth = rand(0.1 .. 1.0)

  var first = true
  var number = rand(2 .. 100)
  for a in 0 .. number:
    let th = a.float32 / number.float32 * PI
    let pos = vec2(sin(th) * 100, cos(th) * 100)
    if first:
      ctx.moveTo(pos)
      first = false
    else:
      ctx.lineTo(pos)
  ctx.stroke()

  # image.writeFile("tests/fuzz_leaks2.png")
  # break



================================================
FILE: tests/fuzz_leaks3.nim
================================================
import pixie, pixie/fileformats/svg, random

when not defined(pixieLeakCheck):
  quit("Requires -d:pixieLeakCheck")

randomize()

let data = readFile("tests/fileformats/svg/Ghostscript_Tiger.svg")

for i in 0 ..< 100_000:
  var image = decodeSvg(data, rand(300 .. 1800), rand(30 .. 1800))

  # image.writeFile("tests/fuzz_leaks3.png")
  # break



================================================
FILE: tests/fuzz_opentype.nim
================================================
import common, pixie, random, strformat, unicode

randomize()

let fontPaths = findAllFonts("tests/fonts")

doAssert fontPaths.len > 0

for i in 0 ..< 10000:
  var
    file = fontPaths[rand(fontPaths.len - 1)]
    data = readFile(file)
    pos = rand(data.len)
    value = rand(255).char
  data[pos] = value
  echo &"{i} {file} {pos} {value.uint8}"
  try:
    let font = parseOtf(data)
    doAssert font != nil
    for i in 0.uint16 ..< uint16.high:
      discard font.getGlyphPath(Rune(i.int))
  except PixieError:
    discard

  data = data[0 ..< pos]
  try:
    let font = parseOtf(data)
    doAssert font != nil
    for i in 0.uint16 ..< uint16.high:
      discard font.getGlyphPath(Rune(i.int))
  except PixieError:
    discard



================================================
FILE: tests/fuzz_paths.nim
================================================
import pixie/common, pixie/paths, random, strformat

randomize()

const pathStr = "m57.611-8.591c-1.487,1.851-4.899,4.42-1.982,6.348,0.194,0.129,0.564,0.133,0.737-0.001,2.021-1.565,4.024-2.468,6.46-3.05,0.124-0.029,0.398,0.438,0.767,0.277,1.613-0.703,3.623-0.645,4.807-1.983,3.767,0.224,7.332-0.892,10.723-2.2,1.161-0.448,2.431-1.007,3.632-1.509,1.376-0.576,2.58-1.504,3.692-2.645,0.133-0.136,0.487-0.046,0.754-0.046-0.04-0.863,0.922-0.99,1.169-1.612,0.092-0.232-0.058-0.628,0.075-0.73,2.138-1.63,3.058-3.648,1.889-6.025-0.285-0.578-0.534-1.196-1.1-1.672-1.085-0.911-2.187-0.057-3.234-0.361-0.159,0.628-0.888,0.456-1.274,0.654-0.859,0.439-2.192-0.146-3.051,0.292-1.362,0.695-2.603,0.864-4.025,1.241-0.312,0.082-1.09-0.014-1.25,0.613-0.134-0.134-0.282-0.368-0.388-0.346-1.908,0.396-3.168,0.61-4.469,2.302-0.103,0.133-0.545-0.046-0.704,0.089-0.957,0.808-1.362,2.042-2.463,2.714-0.201,0.123-0.553-0.045-0.747,0.084-0.646,0.431-1.013,1.072-1.655,1.519-0.329,0.229-0.729-0.096-0.697-0.352,0.245-1.947,0.898-3.734,0.323-5.61,2.077-2.52,4.594-4.469,6.4-7.2,0.015-2.166,0.707-4.312,0.594-6.389-0.01-0.193-0.298-0.926-0.424-1.273-0.312-0.854,0.594-1.92-0.25-2.644-1.404-1.203-2.696-0.327-3.52,1.106-1.838,0.39-3.904,1.083-5.482-0.151-1.007-0.787-1.585-1.693-2.384-2.749-0.985-1.302-0.65-2.738-0.58-4.302,0.006-0.128-0.309-0.264-0.309-0.398,0.001-0.135,0.221-0.266,0.355-0.4-0.706-0.626-0.981-1.684-2-2,0.305-1.092-0.371-1.976-1.242-2.278-1.995-0.691-3.672,1.221-5.564,1.294-0.514,0.019-0.981-1.019-1.63-1.344-0.432-0.216-1.136-0.249-1.498,0.017-0.688,0.504-1.277,0.618-2.035,0.823-1.617,0.436-2.895,1.53-4.375,2.385-1.485,0.857-2.44,2.294-3.52,3.614-0.941,1.152-1.077,3.566,0.343,4.066,1.843,0.65,3.147-2.053,5.113-1.727,0.312,0.051,0.518,0.362,0.408,0.75,0.389,0.109,0.607-0.12,0.8-0.4,0.858,1.019,2.022,1.356,2.96,2.229,0.97,0.904,2.716,0.486,3.731,1.483,1.529,1.502,0.97,4.183,2.909,5.488-0.586,1.313-1.193,2.59-1.528,4.017-0.282,1.206,0.712,2.403,1.923,2.312,1.258-0.094,1.52-0.853,2.005-1.929,0.267,0.267,0.736,0.564,0.695,0.78-0.457,2.387-1.484,4.38-1.942,6.811-0.059,0.317-0.364,0.519-0.753,0.409-0.468,4.149-4.52,6.543-7.065,9.708-0.403,0.502-0.407,1.751,0.002,2.154,1.403,1.387,3.363-0.159,5.063-0.662,0.213-1.206,1.072-2.148,2.404-2.092,0.256,0.01,0.491-0.532,0.815-0.662,0.348-0.138,0.85,0.086,1.136-0.112,1.729-1.195,3.137-2.301,4.875-3.49,0.192-0.131,0.536,0.028,0.752-0.08,0.325-0.162,0.512-0.549,0.835-0.734,0.348-0.2,0.59,0.09,0.783,0.37-0.646,0.349-0.65,1.306-1.232,1.508-0.775,0.268-1.336,0.781-2.01,1.228-0.292,0.193-0.951-0.055-1.055,0.124-0.598,1.028-1.782,1.466-2.492,2.349z"

for i in 0 ..< 10_000:
  var data = pathStr
  let
    pos = rand(data.len - 1)
    value = rand(255).char
  data[pos] = value
  echo &"{i} {pos} {value.uint8}"
  try:
    discard parsePath(data)
  except PixieError:
    discard

  data = data[0 ..< pos]
  try:
    discard parsePath(data)
  except PixieError:
    discard



================================================
FILE: tests/fuzz_png.nim
================================================
import pixie/common, pixie/fileformats/png, pngsuite, random, strformat

randomize()

for i in 0 ..< 10_000:
  let file = pngSuiteFiles[rand(pngSuiteFiles.len - 1)]
  var data = readFile(&"tests/fileformats/png/pngsuite/{file}.png")
  let
    pos = 29 + rand(data.len - 30)
    value = rand(255).uint8
  data[pos] = value.char
  echo &"{i} {file} {pos} {value}"
  try:
    let img = decodePng(data)
    doAssert img.height > 0 and img.width > 0
  except PixieError:
    discard

  data = data[0 ..< pos]
  try:
    let img = decodePng(data)
    doAssert img.height > 0 and img.width > 0
  except PixieError:
    discard



================================================
FILE: tests/fuzz_qoi.nim
================================================
import pixie/common, pixie/fileformats/qoi, std/random, strformat

randomize()

let original = readFile("tests/fileformats/qoi/testcard_rgba.qoi")

for i in 0 ..< 10_000:
  var data = original
  let
    pos = rand(data.len)
    value = rand(255).uint8
  data[pos] = value.char
  echo &"{i} {pos} {value}"
  try:
    let img = decodeQoi(data)
    doAssert img.height > 0 and img.width > 0
  except PixieError:
    discard

  data = data[0 ..< pos]
  try:
    let img = decodeQoi(data)
    doAssert img.height > 0 and img.width > 0
  except PixieError:
    discard



================================================
FILE: tests/fuzz_svg.nim
================================================
import pixie/common, pixie/fileformats/svg, random, strformat

randomize()

let original = readFile("tests/fileformats/svg/Ghostscript_Tiger.svg")

for i in 0 ..< 10_000:
  var data = original
  let
    pos = rand(data.len)
    value = rand(255).char
  data[pos] = value
  echo &"{i} {pos} {value}"
  try:
    discard decodeSvg(data)
  except PixieError:
    discard



================================================
FILE: tests/jpegsuite.nim
================================================
const jpegSuiteFiles* = [
  "tests/fileformats/jpeg/masters/red.jpg",
  "tests/fileformats/jpeg/masters/green.jpg",
  "tests/fileformats/jpeg/masters/blue.jpg",
  "tests/fileformats/jpeg/masters/white.jpg",
  "tests/fileformats/jpeg/masters/black.jpg",

  "tests/fileformats/jpeg/masters/8x8.jpg",
  "tests/fileformats/jpeg/masters/8x8_progressive.jpg",

  "tests/fileformats/jpeg/masters/16x16.jpg",
  "tests/fileformats/jpeg/masters/16x16_progressive.jpg",

  "tests/fileformats/jpeg/masters/quality_01.jpg",
  "tests/fileformats/jpeg/masters/quality_10.jpg",
  "tests/fileformats/jpeg/masters/quality_25.jpg",
  "tests/fileformats/jpeg/masters/quality_50.jpg",
  "tests/fileformats/jpeg/masters/quality_100.jpg",

  "tests/fileformats/jpeg/masters/cat_4_4_4.jpg",
  "tests/fileformats/jpeg/masters/cat_4_4_4.jpg",
  "tests/fileformats/jpeg/masters/cat_4_2_2.jpg",
  "tests/fileformats/jpeg/masters/cat_4_2_0.jpg",
  "tests/fileformats/jpeg/masters/cat_4_1_1.jpg",
  "tests/fileformats/jpeg/masters/cat_4_2_0_progressive.jpg",
  "tests/fileformats/jpeg/masters/cat_4_4_4_progressive.jpg",
  "tests/fileformats/jpeg/masters/cat_restart_markers_5.jpg",
  "tests/fileformats/jpeg/masters/cat_restart_markers_5_progressive.jpg",

  "tests/fileformats/jpeg/masters/mandrill.jpg",
  "tests/fileformats/jpeg/masters/exif_overrun.jpg",
  "tests/fileformats/jpeg/masters/grayscale_test.jpg",
  "tests/fileformats/jpeg/masters/progressive.jpg",

  "tests/fileformats/jpeg/masters/testimg.jpg",
  "tests/fileformats/jpeg/masters/testimgp.jpg",
  "tests/fileformats/jpeg/masters/testorig.jpg",
  "tests/fileformats/jpeg/masters/testprog.jpg",

  "tests/fileformats/jpeg/masters/f1-exif.jpg",
  "tests/fileformats/jpeg/masters/f2-exif.jpg",
  "tests/fileformats/jpeg/masters/f3-exif.jpg",
  "tests/fileformats/jpeg/masters/f4-exif.jpg",
  "tests/fileformats/jpeg/masters/f5-exif.jpg",
  "tests/fileformats/jpeg/masters/f6-exif.jpg",
  "tests/fileformats/jpeg/masters/f7-exif.jpg",
  "tests/fileformats/jpeg/masters/f8-exif.jpg",

  "tests/fileformats/jpeg/masters/restartmarker.jpg",
]



================================================
FILE: tests/megatest_emoji.nim
================================================
import cligen, os, pixie, pixie/fileformats/svg, strformat

# Clone https://github.com/twitter/twemoji
# Check out commit 59cb0eacce837d0f5de30223bd8f530e447f547a

# Clone https://github.com/hfg-gmuend/openmoji
# Check out commit c1f14ae0be29b20c7eed215d1e03df23b1c9a5d5

# Clone https://github.com/EmojiTwo/emojitwo
# Check out commit d79b4477eb8f9110fc3ce7bed2cc66030a77933e

# Clone https://github.com/googlefonts/noto-emoji
# Check out commit 948b1a7f1ed4ec7e27930ad8e027a740db3fe25e

type EmojiSet = object
  name: string
  path: string

const
  emojiSets = [
    EmojiSet(name: "twemoji", path: "../twemoji/assets/svg/*"),
    EmojiSet(name: "openmoji", path: "../openmoji/color/svg/*"),
    EmojiSet(name: "emojitwo", path: "../emojitwo/svg/*"),
    EmojiSet(name: "noto-emoji", path: "../noto-emoji/svg/*")
  ]
  width = 32
  height = 32

proc renderEmojiSet(index: int) =
  let emojiSet = emojiSets[index]

  var images: seq[(string, Image)]

  for filePath in walkFiles(emojiSet.path):
    let (_, name, _) = splitFile(filePath)
    var image: Image
    try:
      image = newImage(parseSvg(readFile(filePath), width, height))
    except PixieError:
      echo &"Failed decoding {name}"
      image = newImage(width, height)
    images.add((name, image))

  let
    columns = 40
    rows = (images.len + columns - 1) div columns
    rendered = newImage((width + 4) * columns, (height + 4) * rows)

  for i in 0 ..< rows:
    for j in 0 ..< max(images.len - i * columns, 0):
      let
        (_, icon) = images[i * columns + j]
        pos = vec2(((width + 4) * j + 2).float32, ((height + 4) * i + 2).float32)
      rendered.draw(
        icon,
        translate(pos),
        OverwriteBlend
      )

  rendered.writeFile(&"tests/fileformats/svg/{emojiSet.name}.png")

proc main(index = -1) =
  if index >= 0:
    renderEmojiSet(index)
  else:
    for i in 0 ..< emojiSets.len:
      renderEmojiSet(i)

dispatch(main)



================================================
FILE: tests/megatest_fonts.nim
================================================
import common, pixie

# Clone https://github.com/treeform/fidgetfonts

let fontPaths = findAllFonts("../fidgetfonts")

for fontPath in fontPaths:
  echo fontPath
  try:
    var font = readFont(fontPath)
  except PixieError:
    echo "ERROR: ", getCurrentExceptionMsg()



================================================
FILE: tests/megatest_icons.nim
================================================
import cligen, os, pixie, pixie/fileformats/svg, strformat

# Clone https://github.com/twbs/icons
# Check out commit f364cb14dfc0703b9e3ef10c8b490a71dfef1e9d

# Clone https://github.com/icons8/flat-color-icons
# Check out commit 8eccbbbd8b2af1d2c9593e7cfba5ecb0d68ee378

# Clone https://github.com/ionic-team/ionicons
# Check out commit 0d7f507677f8d317ce6882729ffecf46e215e01a

# Clone https://github.com/tabler/tabler-icons
# Check out commit ccf2784b57e42a2b2221963f92146fd7b249b5b7

# Clone https://github.com/simple-icons/simple-icons
# Check out commit 355454cb6caa02aba70638631c557d4e06205710

type IconSet = object
  name: string
  path: string

const
  iconSets = [
    IconSet(name: "twbs-icons", path: "../icons/icons/*"),
    IconSet(name: "flat-color-icons", path: "../flat-color-icons/svg/*"),
    IconSet(name: "ionicons", path: "../ionicons/src/svg/*"),
    IconSet(name: "tabler-icons", path: "../tabler-icons/icons/*"),
    IconSet(name: "simple-icons", path: "../simple-icons/icons/*")
  ]
  width = 32
  height = 32

proc renderIconSet(index: int) =
  let iconSet = iconSets[index]

  var images: seq[(string, Image)]

  for filePath in walkFiles(iconSet.path):
    let
      (_, name, _) = splitFile(filePath)
      image = newImage(parseSvg(readFile(filePath), width, height))

    images.add((name, image))

  let
    columns = 40
    rows = (images.len + columns - 1) div columns
    rendered = newImage((width + 4) * columns, (height + 4) * rows)

  for i in 0 ..< rows:
    for j in 0 ..< max(images.len - i * columns, 0):
      let
        (_, icon) = images[i * columns + j]
        pos = vec2(((width + 4) * j + 2).float32, ((height + 4) * i + 2).float32)
      rendered.draw(
        icon,
        translate(pos),
        OverwriteBlend
      )

  rendered.writeFile(&"tests/fileformats/svg/{iconSet.name}.png")

proc main(index = -1) =
  if index >= 0:
    renderIconSet(index)
  else:
    for i in 0 ..< iconSets.len:
      renderIconSet(i)

dispatch(main)



================================================
FILE: tests/pngsuite.nim
================================================
# http://www.schaik.com/pngsuite/

const
  pngSuiteFiles* = [
    # Basic
    "basn0g01", # black & white
    "basn0g02", # 2 bit (4 level) grayscale
    "basn0g04", # 4 bit (16 level) grayscale
    "basn0g08", # 8 bit (256 level) grayscale
    # "basn0g16", # 16 bit (64k level) grayscale
    "basn2c08", # 3x8 bits rgb color
    # "basn2c16", # 3x16 bits rgb color
    "basn3p01", # 1 bit (2 color) paletted
    "basn3p02", # 2 bit (4 color) paletted
    "basn3p04", # 4 bit (16 color) paletted
    "basn3p08", # 8 bit (256 color) paletted
    "basn4a08", # 8 bit grayscale + 8 bit alpha-channel
    # "basn4a16", # 16 bit grayscale + 16 bit alpha-channel
    "basn6a08", # 3x8 bits rgb color + 8 bit alpha-channel
    # "basn6a16", # 3x16 bits rgb color + 16 bit alpha-channel

    # Interlaced
    # "basi0g01", # black & white
    # "basi0g02", # 2 bit (4 level) grayscale
    # "basi0g04", # 4 bit (16 level) grayscale
    # "basi0g08", # 8 bit (256 level) grayscale
    # "basi0g16", # 16 bit (64k level) grayscale
    # "basi2c08", # 3x8 bits rgb color
    # "basi2c16", # 3x16 bits rgb color
    # "basi3p01", # 1 bit (2 color) paletted
    # "basi3p02", # 2 bit (4 color) paletted
    # "basi3p04", # 4 bit (16 color) paletted
    # "basi3p08", # 8 bit (256 color) paletted
    # "basi4a08", # 8 bit grayscale + 8 bit alpha-channel
    # "basi4a16", # 16 bit grayscale + 16 bit alpha-channel
    # "basi6a08", # 3x8 bits rgb color + 8 bit alpha-channel
    # "basi6a16", # 3x16 bits rgb color + 16 bit alpha-channel

    # Odd sizes
    # "s01i3p01", # 1x1 paletted file, interlaced
    "s01n3p01", # 1x1 paletted file, no interlacing
    # "s02i3p01", # 2x2 paletted file, interlaced
    "s02n3p01", # 2x2 paletted file, no interlacing
    # "s03i3p01", # 3x3 paletted file, interlaced
    "s03n3p01", # 3x3 paletted file, no interlacing
    # "s04i3p01", # 4x4 paletted file, interlaced
    "s04n3p01", # 4x4 paletted file, no interlacing
    # "s05i3p02", # 5x5 paletted file, interlaced
    "s05n3p02", # 5x5 paletted file, no interlacing
    # "s06i3p02", # 6x6 paletted file, interlaced
    "s06n3p02", # 6x6 paletted file, no interlacing
    # "s07i3p02", # 7x7 paletted file, interlaced
    "s07n3p02", # 7x7 paletted file, no interlacing
    # "s08i3p02", # 8x8 paletted file, interlaced
    "s08n3p02", # 8x8 paletted file, no interlacing
    # "s09i3p02", # 9x9 paletted file, interlaced
    "s09n3p02", # 9x9 paletted file, no interlacing
    # "s32i3p04", # 32x32 paletted file, interlaced
    "s32n3p04", # 32x32 paletted file, no interlacing
    # "s33i3p04", # 33x33 paletted file, interlaced
    "s33n3p04", # 33x33 paletted file, no interlacing
    # "s34i3p04", # 34x34 paletted file, interlaced
    "s34n3p04", # 34x34 paletted file, no interlacing
    # "s35i3p04", # 35x35 paletted file, interlaced
    "s35n3p04", # 35x35 paletted file, no interlacing
    # "s36i3p04", # 36x36 paletted file, interlaced
    "s36n3p04", # 36x36 paletted file, no interlacing
    # "s37i3p04", # 37x37 paletted file, interlaced
    "s37n3p04", # 37x37 paletted file, no interlacing
    # "s38i3p04", # 38x38 paletted file, interlaced
    "s38n3p04", # 38x38 paletted file, no interlacing
    # "s39i3p04", # 39x39 paletted file, interlaced
    "s39n3p04", # 39x39 paletted file, no interlacing
    # "s40i3p04", # 40x40 paletted file, interlaced
    "s40n3p04", # 40x40 paletted file, no interlacing

    # "bgai4a08", # 8 bit grayscale, alpha, no background chunk, interlaced
    # "bgai4a16", # 16 bit grayscale, alpha, no background chunk, interlaced
    "bgan6a08", # 3x8 bits rgb color, alpha, no background chunk
    # "bgan6a16", # 3x16 bits rgb color, alpha, no background chunk
    "bgbn4a08", # 8 bit grayscale, alpha, black background chunk
    # "bggn4a16", # 16 bit grayscale, alpha, gray background chunk
    "bgwn6a08", # 3x8 bits rgb color, alpha, white background chunk
    # "bgyn6a16", # 3x16 bits rgb color, alpha, yellow background chunk

    # "tbbn0g04", # transparent, black background chunk
    # # "tbbn2c16", # transparent, blue background chunk
    "tbbn3p08", # transparent, black background chunk
    # # "tbgn2c16", # transparent, green background chunk
    "tbgn3p08", # transparent, light-gray background chunk
    "tbrn2c08", # transparent, red background chunk
    # # "tbwn0g16", # transparent, white background chunk
    "tbwn3p08", # transparent, white background chunk
    "tbyn3p08", # transparent, yellow background chunk
    "tp0n0g08", # not transparent for reference (logo on gray)
    "tp0n2c08", # not transparent for reference (logo on gray)
    "tp0n3p08", # not transparent for reference (logo on gray)
    "tp1n3p08", # transparent, but no background chunk
    "tm3n3p02", # multiple levels of transparency, 3 entries

    # "g03n0g16", # grayscale, file-gamma = 0.35
    "g03n2c08", # color, file-gamma = 0.35
    "g03n3p04", # paletted, file-gamma = 0.35
    # "g04n0g16", # grayscale, file-gamma = 0.45
    "g04n2c08", # color, file-gamma = 0.45
    "g04n3p04", # paletted, file-gamma = 0.45
    # "g05n0g16", # grayscale, file-gamma = 0.55
    "g05n2c08", # color, file-gamma = 0.55
    "g05n3p04", # paletted, file-gamma = 0.55
    # "g07n0g16", # grayscale, file-gamma = 0.70
    "g07n2c08", # color, file-gamma = 0.70
    "g07n3p04", # paletted, file-gamma = 0.70
    # "g10n0g16", # grayscale, file-gamma = 1.00
    "g10n2c08", # color, file-gamma = 1.00
    "g10n3p04", # paletted, file-gamma = 1.00
    # "g25n0g16", # grayscale, file-gamma = 2.50
    "g25n2c08", # color, file-gamma = 2.50
    "g25n3p04", # paletted, file-gamma = 2.50

    "f00n0g08", # grayscale, no interlacing, filter-type 0
    "f00n2c08", # color, no interlacing, filter-type 0
    "f01n0g08", # grayscale, no interlacing, filter-type 1
    "f01n2c08", # color, no interlacing, filter-type 1
    "f02n0g08", # grayscale, no interlacing, filter-type 2
    "f02n2c08", # color, no interlacing, filter-type 2
    "f03n0g08", # grayscale, no interlacing, filter-type 3
    "f03n2c08", # color, no interlacing, filter-type 3
    "f04n0g08", # grayscale, no interlacing, filter-type 4
    "f04n2c08", # color, no interlacing, filter-type 4
    "f99n0g04", # bit-depth 4, filter changing per scanline

    # "pp0n2c16", # six-cube palette-chunk in true-color image
    "pp0n6a08", # six-cube palette-chunk in true-color+alpha image
    "ps1n0g08", # six-cube suggested palette (1 byte) in grayscale image
    # "ps1n2c16", # six-cube suggested palette (1 byte) in true-color image
    "ps2n0g08", # six-cube suggested palette (2 bytes) in grayscale image
    # "ps2n2c16", # six-cube suggested palette (2 bytes) in true-color image

    "ccwn2c08", # chroma chunk w:0.3127,0.3290 r:0.64,0.33 g:0.30,0.60 b:0.15,0.06
    "ccwn3p08", # chroma chunk w:0.3127,0.3290 r:0.64,0.33 g:0.30,0.60 b:0.15,0.06
    "cdfn2c08", # physical pixel dimensions, 8x32 flat pixels
    "cdhn2c08", # physical pixel dimensions, 32x8 high pixels
    "cdsn2c08", # physical pixel dimensions, 8x8 square pixels
    "cdun2c08", # physical pixel dimensions, 1000 pixels per 1 meter
    "ch1n3p04", # histogram 15 colors
    "ch2n3p08", # histogram 256 colors
    "cm0n0g04", # modification time, 01-jan-2000 12:34:56
    "cm7n0g04", # modification time, 01-jan-1970 00:00:00
    "cm9n0g04", # modification time, 31-dec-1999 23:59:59
    # "cs3n2c16", # color, 13 significant bits
    "cs3n3p08", # paletted, 3 significant bits
    "cs5n2c08", # color, 5 significant bits
    "cs5n3p08", # paletted, 5 significant bits
    "cs8n2c08", # color, 8 significant bits (reference)
    "cs8n3p08", # paletted, 8 significant bits (reference)
    "ct0n0g04", # no textual data
    "ct1n0g04", # with textual data
    "ctzn0g04", # with compressed textual data
    "cten0g04", # international UTF-8, english
    "ctfn0g04", # international UTF-8, finnish
    "ctgn0g04", # international UTF-8, greek
    "cthn0g04", # international UTF-8, hindi
    "ctjn0g04", # international UTF-8, japanese
    "exif2c08", # chunk with jpeg exif data

    # "oi1n0g16", # grayscale mother image with 1 idat-chunk
    # "oi1n2c16", # color mother image with 1 idat-chunk
    # "oi2n0g16", # grayscale image with 2 idat-chunks
    # "oi2n2c16", # color image with 2 idat-chunks
    # "oi4n0g16", # grayscale image with 4 unequal sized idat-chunks
    # "oi4n2c16", # color image with 4 unequal sized idat-chunks
    # "oi9n0g16", # grayscale image with all idat-chunks length one
    # "oi9n2c16", # color image with all idat-chunks length one

    "z00n2c08", # color, no interlacing, compression level 0 (none)
    "z03n2c08", # color, no interlacing, compression level 3
    "z06n2c08", # color, no interlacing, compression level 6 (default)
    "z09n2c08", # color, no interlacing, compression level 9 (maximum)
  ]

  pngSuiteCorruptedFiles* = [
    "xs1n0g01", # signature byte 1 MSBit reset to zero
    "xs2n0g01", # signature byte 2 is a 'Q'
    "xs4n0g01", # signature byte 4 lowercase
    "xs7n0g01", # 7th byte a space instead of control-Z
    "xcrn0g04", # added cr bytes
    "xlfn0g04", # added lf bytes
    # "xhdn0g08", # incorrect IHDR checksum
    "xc1n0g08", # color type 1
    "xc9n2c08", # color type 9
    "xd0n2c08", # bit-depth 0
    "xd3n2c08", # bit-depth 3
    "xd9n2c08", # bit-depth 99
    "xdtn0g01", # missing IDAT chunk
    # "xcsn0g01" # incorrect IDAT checksum
  ]



================================================
FILE: tests/test_bmp.nim
================================================
import os, pixie, pixie/fileformats/bmp

# block:
#   var image = newImage(4, 2)

#   image[0, 0] = rgba(0, 0, 255, 255)
#   image[1, 0] = rgba(0, 255, 0, 255)
#   image[2, 0] = rgba(255, 0, 0, 255)
#   image[3, 0] = rgba(255, 255, 255, 255)

#   image[0, 1] = rgba(0, 0, 255, 127)
#   image[1, 1] = rgba(0, 255, 0, 127)
#   image[2, 1] = rgba(255, 0, 0, 127)
#   image[3, 1] = rgba(255, 255, 255, 127)

#   writeFile("tests/fileformats/bmp/test4x2.bmp", encodeBmp(image))

#   var image2 = decodeBmp(encodeBmp(image))
#   doAssert image2.width == image.width
#   doAssert image2.height == image.height
#   doAssert image2.data == image.data

# block:
#   var image = newImage(16, 16)
#   image.fill(rgba(255, 0, 0, 127))
#   writeFile("tests/fileformats/bmp/test16x16.bmp", encodeBmp(image))

#   var image2 = decodeBmp(encodeBmp(image))
#   doAssert image2.width == image.width
#   doAssert image2.height == image.height
#   doAssert image2.data == image.data

block:
  for bits in [32, 24]:
    let
      path = "tests/fileformats/bmp/knight." & $bits & ".master.bmp"
      image = decodeBmp(readFile(path))
    writeFile("tests/fileformats/bmp/knight." & $bits & ".bmp", encodeBmp(image))

block:
  let image = decodeBmp(readFile(
    "tests/fileformats/bmp/rgb.24.master.bmp"
  ))
  writeFile("tests/fileformats/bmp/rgb.24.bmp", encodeBmp(image))

block:
  for file in walkFiles("tests/fileformats/bmp/bmpsuite/*"):
    # echo file
    let
      image = decodeBmp(readFile(file))
      dimensions = decodeBmpDimensions(readFile(file))
    #image.writeFile(file.replace("bmpsuite", "output") & ".png")
    doAssert image.width == dimensions.width
    doAssert image.height == dimensions.height

block:
  let image = newImage(100, 100)
  image.fill(color(1, 0, 0, 1))

  let
    encoded = encodeDib(image)
    decoded = decodeDib(encoded.cstring, encoded.len, true)

  doAssert image.data == decoded.data



================================================
FILE: tests/test_contexts.nim
================================================
import chroma, pixie, xrays

block:
  let ctx = newContext(newImage(300, 160))

  ctx.beginPath()
  ctx.fillStyle = "#ff6"
  ctx.fillRect(0, 0, ctx.image.width.float32, ctx.image.height.float32)

  ctx.beginPath()
  ctx.fillStyle = "blue"
  ctx.moveTo(20, 20)
  ctx.lineTo(180, 20)
  ctx.lineTo(130, 130)
  ctx.closePath()
  ctx.fill()

  ctx.clearRect(10, 10, 120, 100)

  ctx.image.xray("tests/contexts/clearRect_1.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.beginPath()
  ctx.strokeStyle = "blue"
  ctx.moveTo(20, 20)
  ctx.lineTo(200, 20)
  ctx.stroke()

  ctx.beginPath()
  ctx.strokeStyle = "green"
  ctx.moveTo(20, 20)
  ctx.lineTo(120, 120)
  ctx.stroke()

  ctx.image.xray("tests/contexts/beginPath_1.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.beginPath()
  ctx.moveTo(50, 50)
  ctx.lineTo(200, 50)
  ctx.moveTo(50, 90)
  ctx.lineTo(280, 120)
  ctx.stroke()

  ctx.image.xray("tests/contexts/moveTo_1.png")

block:
  let ctx = newContext(newImage(300, 150))

  let region = newPath()
  region.moveTo(30, 90)
  region.lineTo(110, 20)
  region.lineTo(240, 130)
  region.lineTo(60, 130)
  region.lineTo(190, 20)
  region.lineTo(270, 90)
  region.closePath()

  ctx.fillStyle = "green"
  ctx.fill(region, EvenOdd)

  ctx.image.xray("tests/contexts/fill_1.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.rect(10, 10, 150, 100)
  ctx.stroke()

  ctx.image.xray("tests/contexts/stroke_1.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.lineWidth = 26
  ctx.strokeStyle = "orange"
  ctx.moveTo(20, 20)
  ctx.lineTo(160, 20)
  ctx.stroke()

  ctx.lineWidth = 14
  ctx.strokeStyle = "green"
  ctx.moveTo(20, 80)
  ctx.lineTo(220, 80)
  ctx.stroke()

  ctx.lineWidth = 4
  ctx.strokeStyle = "pink"
  ctx.moveTo(20, 140)
  ctx.lineTo(280, 140)
  ctx.stroke()

  ctx.image.xray("tests/contexts/stroke_2.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.lineWidth = 26
  ctx.strokeStyle = "red"

  ctx.beginPath()
  ctx.rect(25, 25, 100, 100)
  ctx.fill()
  ctx.stroke()

  ctx.beginPath()
  ctx.rect(175, 25, 100, 100)
  ctx.stroke()
  ctx.fill()

  ctx.image.xray("tests/contexts/stroke_3.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.beginPath()
  ctx.moveTo(20, 140)
  ctx.lineTo(120, 10)
  ctx.lineTo(220, 140)
  ctx.closePath()
  ctx.stroke()

  ctx.image.xray("tests/contexts/closePath_1.png")

block:
  let ctx = newContext(newImage(300, 150))

  let
    start = vec2(50, 20)
    cp1 = vec2(230, 30)
    cp2 = vec2(150, 80)
    to = vec2(250, 100)

  ctx.beginPath()
  ctx.moveTo(start)
  ctx.bezierCurveTo(cp1, cp2, to)
  ctx.stroke()

  ctx.image.xray("tests/contexts/bezierCurveTo_1.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.beginPath()
  ctx.moveTo(30, 30)
  ctx.bezierCurveTo(120, 160, 180, 10, 220, 140)
  ctx.stroke()

  ctx.image.xray("tests/contexts/bezierCurveTo_2.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.moveTo(50, 20)
  ctx.quadraticCurveTo(230, 30, 50, 100)
  ctx.stroke()

  ctx.image.xray("tests/contexts/quadracticCurveTo_1.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.beginPath()
  ctx.moveTo(20, 110)
  ctx.quadraticCurveTo(230, 150, 250, 20)
  ctx.stroke()

  ctx.image.xray("tests/contexts/quadracticCurveTo_2.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.beginPath()
  ctx.ellipse(100, 75, 75, 50)
  ctx.stroke()

  ctx.image.xray("tests/contexts/ellipse_1.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.strokeStyle = "green"
  ctx.strokeRect(20, 10, 160, 100)

  ctx.image.xray("tests/contexts/strokeRect_1.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.lineJoin = BevelJoin
  ctx.lineWidth = 15
  ctx.strokeStyle = "#38f"
  ctx.strokeRect(30, 30, 160, 90)

  ctx.image.xray("tests/contexts/strokeRect_2.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.setTransform(mat3(1, 0.2, 0, 0.8, 1, 0, 0, 0, 1))
  ctx.fillRect(0, 0, 100, 100)

  ctx.image.xray("tests/contexts/setTransform_1.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.setTransform(mat3(1, 0.2, 0, 0.8, 1, 0, 0, 0, 1))
  ctx.fillRect(0, 0, 100, 100)

  ctx.image.xray("tests/contexts/resetTransform_1.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.rotate(45 * PI / 180)
  ctx.fillRect(60, 0, 100, 30)

  ctx.image.xray("tests/contexts/resetTransform_1.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.transform(mat3(1, 0, 0, 1.7, 1, 0, 0, 0, 1))
  ctx.fillStyle = "gray"
  ctx.fillRect(40, 40, 50, 20)
  ctx.fillRect(40, 90, 50, 20)

  ctx.resetTransform()
  ctx.fillStyle = "red"
  ctx.fillRect(40, 40, 50, 20)
  ctx.fillRect(40, 90, 50, 20)

  ctx.image.xray("tests/contexts/resetTransform_2.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.translate(110, 30)
  ctx.fillStyle = "red"
  ctx.fillRect(0, 0, 80, 80)

  ctx.setTransform(mat3(1, 0, 0, 0, 1, 0, 0, 0, 1))

  ctx.fillStyle = "gray"
  ctx.fillRect(0, 0, 80, 80)

  ctx.image.xray("tests/contexts/translate_1.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.scale(9, 3)
  ctx.fillStyle = "red"
  ctx.fillRect(10, 10, 8, 20)

  ctx.setTransform(mat3(1, 0, 0, 0, 1, 0, 0, 0, 1))

  ctx.fillStyle = "gray"
  ctx.fillRect(10, 10, 8, 20)

  ctx.image.xray("tests/contexts/scale_1.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.fillStyle = "gray"
  ctx.fillRect(100, 0, 80, 20)

  ctx.rotate(45 * PI / 180)
  ctx.fillStyle = "red"
  ctx.fillRect(100, 0, 80, 20)

  ctx.image.xray("tests/contexts/rotate_1.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.font = "tests/fonts/Roboto-Regular_1.ttf"
  ctx.fontSize = 50
  ctx.save()
  ctx.fontSize = 30
  ctx.restore()

  ctx.fillText("Hello world", 50, 90)

  ctx.image.xray("tests/contexts/fillText_1.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.font = "tests/fonts/Roboto-Regular_1.ttf"
  ctx.fontSize = 50

  ctx.strokeText("Hello world", 50, 90)

  ctx.image.xray("tests/contexts/strokeText_1.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.save()

  ctx.fillStyle = "green"
  ctx.fillRect(10, 10, 100, 100)

  ctx.restore()

  ctx.fillRect(150, 40, 100, 100)

  ctx.image.xray("tests/contexts/save_1.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.beginPath()
  ctx.circle(100, 75, 50)
  ctx.clip()

  ctx.fillStyle = "blue"
  ctx.fillRect(0, 0, ctx.image.width.float32, ctx.image.height.float32)
  ctx.fillStyle = "orange"
  ctx.fillRect(0, 0, 100, 100)

  ctx.image.xray("tests/contexts/clip_1.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.fillStyle = "blue"
  ctx.fillRect(0, 0, ctx.image.width.float32, ctx.image.height.float32)

  ctx.beginPath()
  ctx.circle(100, 75, 50)
  ctx.clip()

  ctx.fillStyle = "red"
  ctx.fillRect(0, 0, ctx.image.width.float32, ctx.image.height.float32)
  ctx.fillStyle = "orange"
  ctx.fillRect(0, 0, 100, 100)

  ctx.image.xray("tests/contexts/clip_1b.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.save()

  ctx.beginPath()
  ctx.circle(100, 75, 50)
  ctx.clip()

  ctx.fillStyle = "red"
  ctx.fillRect(0, 0, ctx.image.width.float32, ctx.image.height.float32)
  ctx.fillStyle = "orange"
  ctx.fillRect(0, 0, 100, 100)

  ctx.restore()

  ctx.fillStyle = "blue"
  ctx.fillRect(0, 0, ctx.image.width.float32, ctx.image.height.float32)

  ctx.image.xray("tests/contexts/clip_1c.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.fillStyle = "blue"
  ctx.fillRect(0, 0, ctx.image.width.float32, ctx.image.height.float32)

  ctx.beginPath()
  ctx.circle(100, 75, 50)
  ctx.clip()

  ctx.saveLayer()

  ctx.fillStyle = "red"
  ctx.fillRect(0, 0, ctx.image.width.float32, ctx.image.height.float32)
  ctx.fillStyle = "orange"
  ctx.fillRect(0, 0, 100, 100)

  ctx.restore()

  ctx.image.xray("tests/contexts/clip_1d.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.save()

  ctx.beginPath()
  ctx.circle(100, 75, 50)
  ctx.clip()

  ctx.saveLayer()

  ctx.fillStyle = "red"
  ctx.fillRect(0, 0, ctx.image.width.float32, ctx.image.height.float32)
  ctx.fillStyle = "orange"
  ctx.fillRect(0, 0, 100, 100)

  ctx.restore() # Pop the layer
  ctx.restore() # Pop the clip

  ctx.fillStyle = "blue"
  ctx.fillRect(0, 0, ctx.image.width.float32, ctx.image.height.float32)

  ctx.image.xray("tests/contexts/clip_1e.png")

block:
  let ctx = newContext(newImage(300, 150))

  ctx.save()

  ctx.beginPath()
  ctx.circle(100, 75, 50)
  ctx.clip()

  ctx.saveLayer()

  ctx.fillStyle = "red"
  ctx.fillRect(0, 0, ctx.image.width.float32, ctx.image.height.float32)

  ctx.restore()
  ctx.saveLayer()

  ctx.fillStyle = "orange"
  ctx.fillRect(0, 0, 100, 100)

  ctx.restore() # Pop the layer

  ctx.image.xray("tests/contexts/clip_1f.png")

block:
  let ctx = newContext(newImage(300, 150))

  let region = newPath()
  region.rect(80, 10, 20, 130)
  region.rect(40, 50, 100, 50)
  ctx.clip(region, EvenOdd)

  ctx.fillStyle = "blue"
  ctx.fillRect(0, 0, ctx.image.width.float32, ctx.image.height.float32)

  ctx.image.xray("tests/contexts/clip_2.png")

block:
  let image = newImage(300, 150)

  let ctx = newContext(image)

  var circlePath = newPath()
  circlePath.circle(150, 75, 75)
  var squarePath = newPath()
  squarePath.rect(85, 10, 130, 130)

  ctx.clip(circlePath)
  ctx.clip(squarePath)

  ctx.fillStyle = "blue"
  ctx.fillRect(0, 0, ctx.image.width.float32, ctx.image.height.float32)

  image.xray("tests/contexts/clip_3.png")

block:
  let image = newImage(300, 150)

  let ctx = newContext(image)
  ctx.font = "tests/fonts/Roboto-Regular_1.ttf"
  ctx.fontSize = 50
  ctx.fillStyle = "blue"

  ctx.saveLayer()

  var circlePath = newPath()
  circlePath.circle(150, 75, 75)

  ctx.clip(circlePath)

  ctx.fillText("Hello world", 50, 90)

  ctx.restore()

  image.xray("tests/contexts/clip_text.png")

block:
  let ctx = newContext(100, 100)
  ctx.font = "tests/fonts/Roboto-Regular_1.ttf"

  let metrics = ctx.measureText("Hello world")
  doAssert metrics.width == 60

block:
  let
    image = newImage(300, 150)
    ctx = newContext(image)

  var y = 15.float32

  proc drawDashedLine(pattern: seq[float32]) =
    ctx.beginPath()
    ctx.setLineDash(pattern)
    ctx.moveTo(0, y)
    ctx.lineTo(300, y)
    ctx.stroke()
    y += 20

  drawDashedLine(@[])
  drawDashedLine(@[1.float32, 1])
  drawDashedLine(@[10.float32, 10])
  drawDashedLine(@[20.float32, 5])
  drawDashedLine(@[15.float32, 3, 3, 3])
  drawDashedLine(@[20.float32, 3, 3, 3, 3, 3, 3, 3])
  drawDashedLine(@[12.float32, 3, 3])

  image.xray("tests/contexts/setLineDash_1.png")

block:
  let
    image = newImage(300, 150)
    ctx = newContext(image)

  image.fill(rgba(255, 255, 255, 255))

  let paint = newPaint(SolidPaint)
  paint.color = color(0, 0, 1, 1)
  paint.blendMode = ExclusionBlend

  ctx.fillStyle = paint

  ctx.fillRect(10, 10, 100, 100)

  image.xray("tests/contexts/blendmode_1.png")

block:
  let
    image = newImage(300, 150)
    ctx = newContext(image)

  image.fill(rgba(255, 255, 255, 255))

  ctx.globalAlpha = 0.5

  ctx.fillStyle = "blue"
  ctx.fillRect(10, 10, 100, 100)

  ctx.fillStyle = "red"
  ctx.fillRect(50, 50, 100, 100)

  image.xray("tests/contexts/globalAlpha_1.png")

block:
  let
    image = newImage(100, 100)
    ctx = newContext(image)
    testImage = readImage("tests/images/pip1.png")
  ctx.drawImage(testImage, 0, 0)
  ctx.drawImage(testImage, 30, 30)
  image.xray("tests/contexts/draw_image.png")

block:
  let
    image = newImage(100, 100)
    ctx = newContext(image)
    testImage = readImage("tests/images/pip1.png")
  ctx.translate(30, 30)
  ctx.drawImage(testImage, -30, -30)
  ctx.drawImage(testImage, 0, 0)
  image.xray("tests/contexts/draw_image_translated.png")

block:
  let
    image = newImage(100, 100)
    ctx = newContext(image)
    testImage = readImage("tests/images/pip1.png")
  ctx.scale(2, 2)
  ctx.drawImage(testImage, 0, 0)
  ctx.scale(0.25, 0.25)
  ctx.drawImage(testImage, 0, 0)
  image.xray("tests/contexts/draw_image_scaled.png")

block:
  let
    image = newImage(100, 100)
    ctx = newContext(image)
    testImage = readImage("tests/images/pip1.png")
  ctx.drawImage(testImage, 30, 30, 20, 20)
  image.xray("tests/contexts/draw_image_self_scaled.png")

block:
  let
    image = newImage(300, 227)
    ctx = newContext(image)
    rhino = readImage("tests/images/rhino.png")
  ctx.drawImage(rhino, 33, 71, 104, 124, 21, 20, 87, 104)
  image.xray("tests/contexts/draw_image_rhino.png")

block:
  let
    image = newImage(300, 227)
    ctx = newContext(image)
    rhino = readImage("tests/images/rhino.png")
  ctx.drawImage(rhino, rect(33, 71, 104, 124), rect(21, 20, 87, 104))
  image.xray("tests/contexts/draw_image_rhino2.png")

block:
  let
    image = newImage(100, 100)
    ctx = newContext(image)
  ctx.rect(10, 10, 100, 100)
  doAssert ctx.isPointInPath(30, 70)

block:
  let
    image = newImage(300, 150)
    ctx = newContext(image)
  ctx.arc(150, 75, 50, 0, 2 * PI)
  doAssert ctx.isPointInPath(150, 50)

block:
  let
    image = newImage(100, 100)
    ctx = newContext(image)
  ctx.rect(10, 10, 100, 100)
  doAssert ctx.isPointInStroke(50, 10)

block:
  let
    image = newImage(300, 150)
    ctx = newContext(image)
  ctx.ellipse(150, 75, 40, 60)
  ctx.lineWidth = 25
  doAssert ctx.isPointInStroke(110, 75)

block:
  let ctx = newContext(newImage(100, 100))
  ctx.fillStyle.color = color(1, 0, 0, 1)
  ctx.save()
  ctx.fillStyle.color = color(0, 0, 1, 1)
  ctx.restore()
  ctx.fillRect(0, 0, ctx.image.width.float32, ctx.image.height.float32)
  ctx.image.xray("tests/contexts/paintSaveRestore.png")

block:
  # From https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/textBaseline
  let
    image = newImage(550, 500)
    ctx = newContext(image)
  image.fill(rgba(255, 255, 255, 255))

  const baselines = @[
    TopBaseline,
    HangingBaseline,
    MiddleBaseline,
    AlphabeticBaseline,
    IdeographicBaseline,
    BottomBaseline,
  ]

  ctx.font = "tests/fonts/Roboto-Regular_1.ttf"
  ctx.fontSize = 28
  ctx.strokeStyle = "red"

  for index, baseline in baselines:
    ctx.textBaseline = baseline
    let y = (75 + index * 75).float32
    ctx.beginPath()
    ctx.moveTo(0, y + 0.5)
    ctx.lineTo(550, y + 0.5)
    ctx.stroke()
    ctx.fillText("Abcdefghijklmnop (" & $baseline & ")", 0, y)

  ctx.image.xray("tests/contexts/textBaseline_1.png")



================================================
FILE: tests/test_fonts.nim
================================================
import os, pixie, strformat, unicode, xrays

proc wh(image: Image): Vec2 =
  ## Return with and height as a size vector.
  vec2(image.width.float32, image.height.float32)

block:
  var font = readFont("tests/fonts/NotoEmoji.otf")
  font.size = 26
  let image = newImage(800, 300)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(font, """
ðŸš‘ðŸ‘ðŸ‘­ðŸ”‰ðŸš·ðŸ¦£ðŸ’†ðŸ”ðŸ’ºðŸšµðŸ•¦ðŸ”¦ðŸ—“ðŸ¦ŸðŸ˜¶ðŸ¦„âŒ›ðŸ™ðŸ˜„ðŸ‡½
ðŸ ðŸ’“ðŸ¦—ðŸŽ­ðŸ›ðŸ”´ðŸ«•ðŸ§¶ðŸ–ðŸ¦ðŸ‹ðŸŒ—ðŸ›¬ðŸ•ðŸ’¡ðŸ‘‰ðŸŽ¯ðŸ•”ðŸšðŸš²
ðŸµðŸŽðŸ’³ðŸ¥¬ðŸŸ¦ðŸª˜ðŸ“ ðŸ“ŠðŸŽ§ðŸŽ¦ðŸŽðŸŒŒðŸª²ðŸ¦©ðŸ¤¢â˜ŽðŸšºðŸš¾ðŸ‘ºðŸšƒ
ðŸ¨ðŸŒ†ðŸ¥‰ðŸ’­ðŸ—³ðŸ¦µðŸŸªðŸ“†ðŸ¥®â¯ðŸ©´ðŸ’·ðŸ¦²âž—ðŸŒ¶ðŸ§œðŸ––â°ðŸ›—ðŸ”»
ðŸ“ðŸ§žðŸ˜ƒðŸŒ´ðŸš¶ó¾ «ðŸ¦™ðŸ”Žâ²ðŸ”µðŸ–â˜¦ðŸ˜ªðŸŒ¯ðŸ™†ðŸ‡ºðŸ˜‚ðŸ…ðŸ‡¿ðŸšŸðŸ¤œ
ðŸ“¼ðŸ‘°ðŸðŸ“½â˜ªðŸ”„ðŸ¤ðŸ”§ðŸ¦¸ðŸ°ðŸ³ðŸ”œðŸŽ¥ðŸš‹ðŸ‡«ðŸ¦¨ðŸœðŸ†–ðŸ¤ðŸª–â""")

  image.xray("tests/fonts/masters/emoji.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 24

  let bounds = font.layoutBounds("Word")
  doAssert bounds == vec2(56, 28)

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 24

  let bounds = font.layoutBounds("Word\n")
  doAssert bounds == vec2(56, 56)

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 64
  let image = newImage(200, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(font, "fill")

  image.xray("tests/fonts/masters/image_fill.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 64
  let image = newImage(200, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.strokeText(font, "stroke")

  image.xray("tests/fonts/masters/image_stroke.png")

block:
  # SVG Fonts have no masters
  block:
    var font = readFont("tests/fonts/Changa-Bold.svg")
    font.size = 48
    let image = newImage(200, 100)
    image.fillText(font, "Changa")
    image.xray("tests/fonts/svg_changa.png")

  block:
    var font = readFont("tests/fonts/DejaVuSans.svg")
    font.size = 48
    let image = newImage(200, 100)
    image.fillText(font, "Deja vu ")
    image.xray("tests/fonts/svg_dejavu.png")

  block:
    var font = readFont("tests/fonts/IBMPlexSans-Regular.svg")
    font.size = 48
    let image = newImage(200, 100)
    image.fillText(font, "IBM ")
    image.xray("tests/fonts/svg_ibm.png")

  block:
    var font = readFont("tests/fonts/Moon-Bold.svg")
    font.size = 48
    let image = newImage(200, 100)
    image.fillText(font, "Moon ")
    image.xray("tests/fonts/svg_moon.png")

  block:
    var font = readFont("tests/fonts/Ubuntu.svg")
    font.size = 48
    let image = newImage(200, 100)
    image.fillText(font, "Ubuntu ")
    image.xray("tests/fonts/svg_ubuntu.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 72

  let image = newImage(200, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(font, "asdf")

  image.xray("tests/fonts/masters/basic1.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 72

  let image = newImage(200, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(font, "A cow")

  image.xray("tests/fonts/masters/basic2.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 24

  let image = newImage(200, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(font, "A bit of text HERE")

  image.xray("tests/fonts/masters/basic3.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 24
  font.lineHeight = 100

  let image = newImage(200, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(font, "Line height")

  image.xray("tests/fonts/masters/basic4.png")

block:
  var font = readFont("tests/fonts/Ubuntu-Regular_1.ttf")
  font.size = 24

  let image = newImage(200, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(font, "Another font")

  image.xray("tests/fonts/masters/basic5.png")

block:
  var font = readFont("tests/fonts/Aclonica-Regular_1.ttf")
  font.size = 24

  let image = newImage(200, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(font, "Different font")

  image.xray("tests/fonts/masters/basic6.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 24

  let image = newImage(200, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(font, "First line")
  image.fillText(
    font, "Second line", translate(vec2(0, font.defaultLineHeight))
  )

  image.xray("tests/fonts/masters/basic7.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 24

  let image = newImage(200, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(
    font,
    "Wrapping text to new line",
    bounds = vec2(200, 0)
  )

  image.xray("tests/fonts/masters/basic8.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 24

  let image = newImage(200, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(
    font,
    "Long words: Supercalifragilisticexpialidocious\nAntidisestablishmentarianism",
    bounds = vec2(100, 0)
  )

  image.xray("tests/fonts/masters/basic8b.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 24

  let image = newImage(200, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(
    font,
    "Supercalifragilisticexpialidocious",
    bounds = vec2(200, 0)
  )

  image.xray("tests/fonts/masters/basic9.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 24

  let image = newImage(200, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(
    font,
    "a b c d e f g h i j k l m n o p",
    bounds = vec2(200, 0),
    hAlign = RightAlign
  )

  image.xray("tests/fonts/masters/basic10.png")

const
  paragraph = "ShehadcometotheconclusionthatyoucouldtellalotaboutapersonbytheirearsThewaytheystuckoutandthesizeoftheearlobescouldgiveyou"
  paragraph_2 = "She had come to the conclusion that you could tell a lot about a person by their ears The way they stuck out and the size of the earlobes could give you wonderful insights into the person Of course she couldnt scientifically prove any of this but that didnt matter to her Before anything else she would size up the ears of the person she was talking to Shes asked the question so many times that she barely listened to the answers anymore The answers were always the same Well not exactly the same but the same in a general sense A more accurate description was the answers never surprised her"
  paragraph_3 = "She had come to the conclusion that you could tell a lot about a person by their ears The way they stuck out and the size of the earlobes could give you wonderful insights into the person. Of course, she couldn't scientifically prove any of this, but that didn't matter to her. Before anything else, she would size up the ears of the person she was talking to. She's asked the question so many times that she barely listened to the answers anymore. The answers were always the same. Well, not exactly the same, but the same in a general sense. A more accurate description was the answers never surprised her."
  paragraphs = [paragraph, paragraph_2, paragraph_3]

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 16

  let image = newImage(1000, 150)

  for i, text in paragraphs:
    image.fill(rgba(255, 255, 255, 255))
    image.fillText(
      font,
      text,
      bounds = image.wh
    )

    let name = if i > 0: &"paragraph1_{i + 1}" else: "paragraph1"
    image.xray(&"tests/fonts/masters/{name}.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 16
  font.noKerningAdjustments = true

  let image = newImage(1000, 150)

  for i, text in paragraphs:
    image.fill(rgba(255, 255, 255, 255))
    image.fillText(
      font,
      text,
      bounds = image.wh
    )

    let name = if i > 0: &"paragraph1_nokern_{i + 1}" else: "paragraph1_nokern"
    image.xray(&"tests/fonts/masters/{name}.png")

block:
  var font = readFont("tests/fonts/Ubuntu-Regular_1.ttf")
  font.size = 16

  let image = newImage(1000, 150)

  for i, text in paragraphs:
    image.fill(rgba(255, 255, 255, 255))
    image.fillText(
      font,
      text,
      bounds = image.wh
    )

    let name = if i > 0: &"paragraph2_{i + 1}" else: "paragraph2"
    image.xray(&"tests/fonts/masters/{name}.png")

block:
  var font = readFont("tests/fonts/Ubuntu-Regular_1.ttf")
  font.size = 16
  font.noKerningAdjustments = true

  let image = newImage(1000, 150)

  for i, text in paragraphs:
    image.fill(rgba(255, 255, 255, 255))
    image.fillText(
      font,
      text,
      bounds = image.wh
    )

    let name = if i > 0: &"paragraph2_nokern_{i + 1}" else: "paragraph2_nokern"
    image.xray(&"tests/fonts/masters/{name}.png")

block:
  var font = readFont("tests/fonts/IBMPlexSans-Regular_2.ttf")
  font.size = 16

  let image = newImage(1000, 150)

  for i, text in paragraphs:
    image.fill(rgba(255, 255, 255, 255))
    image.fillText(
      font,
      text,
      bounds = image.wh
    )

    let name = if i > 0: &"paragraph3_{i + 1}" else: "paragraph3"
    image.xray(&"tests/fonts/masters/{name}.png")

block:
  var font = readFont("tests/fonts/IBMPlexSans-Regular_2.ttf")
  font.size = 16
  font.noKerningAdjustments = true

  let image = newImage(1000, 150)

  for i, text in paragraphs:
    image.fill(rgba(255, 255, 255, 255))
    image.fillText(
      font,
      text,
      bounds = image.wh
    )

    let name = if i > 0: &"paragraph3_nokern_{i + 1}" else: "paragraph3_nokern"
    image.xray(&"tests/fonts/masters/{name}.png")

block:
  var font = readFont("tests/fonts/NotoSans-Regular_4.ttf")
  font.size = 16

  let image = newImage(1000, 150)

  for i, text in paragraphs:
    image.fill(rgba(255, 255, 255, 255))
    image.fillText(
      font,
      text,
      bounds = image.wh
    )

    let name = if i > 0: &"paragraph4_{i + 1}" else: "paragraph4"
    image.xray(&"tests/fonts/masters/{name}.png")

block:
  var font = readFont("tests/fonts/NotoSans-Regular_4.ttf")
  font.size = 16
  font.noKerningAdjustments = true

  let image = newImage(1000, 150)

  for i, text in paragraphs:
    image.fill(rgba(255, 255, 255, 255))
    image.fillText(
      font,
      text,
      bounds = image.wh
    )

    let name = if i > 0: &"paragraph4_nokern_{i + 1}" else: "paragraph4_nokern"
    image.xray(&"tests/fonts/masters/{name}.png")

block:
  var font = readFont("tests/fonts/Pacifico-Regular_4.ttf")
  font.size = 16

  let image = newImage(1000, 150)

  for i, text in paragraphs:
    image.fill(rgba(255, 255, 255, 255))
    image.fillText(
      font,
      text,
      bounds = image.wh
    )

    let name = if i > 0: &"paragraph5_{i + 1}" else: "paragraph5"
    image.xray(&"tests/fonts/masters/{name}.png")

block:
  var font = readFont("tests/fonts/Pacifico-Regular_4.ttf")
  font.size = 16
  font.noKerningAdjustments = true

  let image = newImage(1000, 150)

  for i, text in paragraphs:
    image.fill(rgba(255, 255, 255, 255))
    image.fillText(
      font,
      text,
      bounds = image.wh
    )

    let name = if i > 0: &"paragraph5_nokern_{i + 1}" else: "paragraph5_nokern"
    image.xray(&"tests/fonts/masters/{name}.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 100

  let image = newImage(1400, 200)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(
    font,
    "Shehadcometotheconclusion",
    bounds = image.wh
  )

  image.xray("tests/fonts/masters/huge1.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 100
  font.noKerningAdjustments = true

  let image = newImage(1400, 200)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(
    font,
    "Shehadcometotheconclusion",
    bounds = image.wh
  )

  image.xray("tests/fonts/masters/huge1_nokern.png")

block:
  var font = readFont("tests/fonts/Ubuntu-Regular_1.ttf")
  font.size = 100

  let image = newImage(1400, 200)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(
    font,
    "Shehadcometotheconclusion",
    bounds = image.wh
  )

  image.xray("tests/fonts/masters/huge2.png")

block:
  var font = readFont("tests/fonts/Ubuntu-Regular_1.ttf")
  font.size = 100
  font.noKerningAdjustments = true

  let image = newImage(1400, 200)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(
    font,
    "Shehadcometotheconclusion",
    bounds = image.wh
  )

  image.xray("tests/fonts/masters/huge2_nokern.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 100

  let image = newImage(1400, 200)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(
    font,
    "Wrapping text to the next line",
    bounds = image.wh
  )

  image.xray("tests/fonts/masters/huge3.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 100
  font.noKerningAdjustments = true

  let image = newImage(1400, 200)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(
    font,
    "Wrapping text to the next line",
    bounds = image.wh
  )

  image.xray("tests/fonts/masters/huge3_nokern.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 50

  let image = newImage(1400, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(
    font,
    "HA HT HX HY IA IT IX IY MA MT MX MY NA NT NX NY",
    bounds = image.wh
  )

  image.xray("tests/fonts/masters/pairs1.png")

block:
  var font = readFont("tests/fonts/Ubuntu-Regular_1.ttf")
  font.size = 50

  let image = newImage(1400, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(
    font,
    "V( V) V- V/ V: v; v? v@ VT VV VW VX VY V] Vu Vz V{",
    bounds = image.wh
  )

  image.xray("tests/fonts/masters/pairs2.png")

block:
  var font = readFont("tests/fonts/IBMPlexSans-Regular_2.ttf")
  font.size = 50

  let image = newImage(1400, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(
    font,
    "B, B. BA BJ BT BW BY Bf Bg Bt bw By",
    bounds = image.wh
  )

  image.xray("tests/fonts/masters/pairs3.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 18

  let image = newImage(200, 150)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(
    font,
    """First line
Second line
Third line
Fourth line
Fifth line
Sixth line
Seventh line""",
    bounds = image.wh
  )

  image.xray("tests/fonts/masters/lines1.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 18
  font.lineHeight = 30

  let image = newImage(200, 150)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(
    font,
    """First line
Second line
Third line
Fourth line
Fifth line""",
    bounds = image.wh
  )

  image.xray("tests/fonts/masters/lines2.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 36

  let image = newImage(800, 800)
  image.fill(rgba(255, 255, 255, 255))

  image.fillText(
    font,
    "TopLeft",
    bounds = image.wh,
    hAlign = LeftAlign,
    vAlign = TopAlign
  )

  image.fillText(
    font,
    "TopCenter",
    bounds = image.wh,
    hAlign = CenterAlign,
    vAlign = TopAlign
  )

  image.fillText(
    font,
    "TopRight",
    bounds = image.wh,
    hAlign = RightAlign,
    vAlign = TopAlign
  )

  image.fillText(
    font,
    "MiddleLeft",
    bounds = image.wh,
    hAlign = LeftAlign,
    vAlign = MiddleAlign
  )

  image.fillText(
    font,
    "MiddleCenter",
    bounds = image.wh,
    hAlign = CenterAlign,
    vAlign = MiddleAlign
  )

  image.fillText(
    font,
    "MiddleRight",
    bounds = image.wh,
    hAlign = RightAlign,
    vAlign = MiddleAlign
  )

  image.fillText(
    font,
    "BottomLeft",
    bounds = image.wh,
    hAlign = LeftAlign,
    vAlign = BottomAlign
  )

  image.fillText(
    font,
    "BottomCenter",
    bounds = image.wh,
    hAlign = CenterAlign,
    vAlign = BottomAlign
  )

  image.fillText(
    font,
    "BottomRight",
    bounds = image.wh,
    hAlign = RightAlign,
    vAlign = BottomAlign
  )

  image.xray("tests/fonts/masters/alignments.png")

block:
  var font = readFont("tests/fonts/IBMPlexSans-Regular_2.ttf")
  font.size = 48
  font.paint = newPaint(LinearGradientPaint)
  font.paint.gradientHandlePositions = @[
    vec2(0, 50),
    vec2(100, 50),
  ]
  font.paint.gradientStops = @[
    ColorStop(color: color(1, 0, 0, 1), position: 0),
    ColorStop(color: color(1, 0, 0, 0.5), position: 1.0),
  ]

  let image = newImage(100, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(font, "Text")

  image.xray("tests/fonts/masters/image_paint_fill.png")

block:
  var font1 = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font1.size = 80

  var font2 = readFont("tests/fonts/Aclonica-Regular_1.ttf")
  font2.size = 100

  var font3 = readFont("tests/fonts/Ubuntu-Regular_1.ttf")
  font3.size = 48

  let spans = @[
    newSpan("One span ", font1),
    newSpan("Two span", font2),
    newSpan(" Three span", font3)
  ]

  let image = newImage(700, 250)
  image.fill(rgba(255, 255, 255, 255))

  let arrangement = typeset(spans, bounds = image.wh)

  image.fillText(arrangement)

  image.xray("tests/fonts/masters/spans1.png")

  let ctx = newContext(image)
  ctx.fillStyle = rgba(127, 127, 127, 127)
  for i, rect in arrangement.selectionRects:
    ctx.fillRect(rect)

  image.xray("tests/fonts/masters/selection_rects1.png")

block:
  var font1 = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font1.size = 80

  var font2 = readFont("tests/fonts/Aclonica-Regular_1.ttf")
  font2.size = 100

  var font3 = readFont("tests/fonts/Ubuntu-Regular_1.ttf")
  font3.size = 48

  let spans = @[
    newSpan("One span ", font1),
    newSpan("Two span", font2),
    newSpan(" Three span", font3)
  ]

  let image = newImage(475, 400)
  image.fill(rgba(255, 255, 255, 255))

  let arrangement = typeset(spans, bounds = image.wh)

  image.fillText(arrangement)

  image.xray("tests/fonts/masters/spans2.png")

  let ctx = newContext(image)
  ctx.fillStyle = rgba(127, 127, 127, 127)
  for i, rect in arrangement.selectionRects:
    ctx.fillRect(rect)

  image.xray("tests/fonts/masters/selection_rects2.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 16

  let image = newImage(75, 75)
  image.fill(rgba(255, 255, 255, 255))

  let arrangement = typeset(
    font, "Wrapping text to the next line", bounds = image.wh
  )

  image.fillText(arrangement)

  let ctx = newContext(image)
  ctx.fillStyle = rgba(127, 127, 127, 127)
  for i, rect in arrangement.selectionRects:
    ctx.fillRect(rect)

  image.xray("tests/fonts/masters/selection_rects3.png")

block:
  let
    roboto = readTypeface("tests/fonts/Roboto-Regular_1.ttf")
    aclonica = readTypeface("tests/fonts/Aclonica-Regular_1.ttf")
    ubuntu = readTypeface("tests/fonts/Ubuntu-Regular_1.ttf")
    ibm = readTypeface("tests/fonts/IBMPlexSans-Regular_2.ttf")
    noto = readTypeface("tests/fonts/NotoSans-Regular_4.ttf")

  var font1 = newFont(roboto)
  font1.size = 64

  var font2 = newFont(aclonica)
  font2.size = 80

  var font3 = newFont(ibm)
  font3.size = 40

  var font4 = newFont(ubuntu)
  font4.size = 56

  var font5 = newFont(noto)
  font5.size = 72

  var font6 = newFont(roboto)
  font6.size = 48

  var font7 = newFont(noto)
  font7.size = 64

  var font8 = newFont(ubuntu)
  font8.size = 54
  font8.paint.color = color(1, 0, 0, 1)

  var font9 = newFont(roboto)
  font9.size = 48

  var font10 = newFont(aclonica)
  font10.size = 48
  font10.lineHeight = 120

  let spans = @[
    newSpan("Using spans, ", font1),
    newSpan("Pixie ", font2),
    newSpan("can arrange and rasterize ", font3),
    newSpan("very complex text layouts. ", font4),
    newSpan("Spans", font5),
    newSpan(" can have different ", font6),
    newSpan("font sizes,", font7),
    newSpan(" colors", font8),
    newSpan(" and ", font9),
    newSpan("line heights.", font10)
  ]

  let image = newImage(600, 600)
  image.fill(rgba(255, 255, 255, 255))

  let arrangement = typeset(spans, bounds = image.wh)

  image.fillText(arrangement)

  image.xray("tests/fonts/masters/spans4.png")

block:
  let ubuntu = readTypeface("tests/fonts/Ubuntu-Regular_1.ttf")

  var font1 = newFont(ubuntu)
  font1.size = 15
  font1.paint = "#CACACA"

  var font2 = newFont(ubuntu)
  font2.size = 84

  var font3 = newFont(ubuntu)
  font3.size = 18
  font3.paint = "#007FF4"

  var font4 = newFont(ubuntu)
  font4.size = 20
  font4.paint = "#4F4F4F"

  let spans = @[
    newSpan("verb [with object] ", font1),
    newSpan("strallow\n", font2),
    newSpan("\nstralÂ·low\n", font3),
    newSpan("\n1. free (something) from restrictive restrictions \"the regulations are intended to strallow changes in public policy\" ", font4)
  ]

  let image = newImage(400, 400)
  image.fill(rgba(255, 255, 255, 255))

  let arrangement = typeset(spans, bounds = vec2(360, 360))

  image.fillText(arrangement, translate(vec2(20, 20)))

  image.xray("tests/fonts/masters/spans5.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 24
  font.underline = true

  let image = newImage(200, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(
    font,
    "Wrapping text to new line",
    bounds = vec2(200, 0)
  )

  image.xray("tests/fonts/masters/underline1.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 24
  font.underline = true
  font.paint = rgba(0, 0, 0, 127)

  let image = newImage(200, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(
    font,
    "Wrapping text to new line",
    bounds = vec2(200, 0)
  )

  image.xray("tests/fonts/masters/underline2.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 24
  font.underline = true

  let image = newImage(200, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.strokeText(
    font,
    "Wrapping text to new line",
    bounds = vec2(200, 0)
  )

  image.xray("tests/fonts/masters/underline3.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 24
  font.strikethrough = true

  let image = newImage(200, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(
    font,
    "Wrapping text to new line",
    bounds = vec2(200, 0)
  )

  image.xray("tests/fonts/masters/strikethrough1.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 24
  font.strikethrough = true
  font.paint = rgba(0, 0, 0, 127)

  let image = newImage(200, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(
    font,
    "Wrapping text to new line",
    bounds = vec2(200, 0)
  )

  image.xray("tests/fonts/masters/strikethrough2.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 24
  font.strikethrough = true

  let image = newImage(200, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.strokeText(
    font,
    "Wrapping text to new line",
    bounds = vec2(200, 0)
  )

  image.xray("tests/fonts/masters/strikethrough3.png")

block:
  let ubuntu = readTypeface("tests/fonts/Ubuntu-Regular_1.ttf")

  var font1 = newFont(ubuntu)
  font1.size = 15
  font1.paint = "#CACACA"

  var font2 = newFont(ubuntu)
  font2.size = 84

  var font3 = newFont(ubuntu)
  font3.size = 18
  font3.paint = "#007FF4"

  var font4 = newFont(ubuntu)
  font4.size = 20
  font4.paint = "#4F4F4F"

  var font5 = newFont(ubuntu)
  font5.size = 20
  font5.paint = "#4F4F4F"
  font5.underline = true

  var font6 = newFont(ubuntu)
  font6.size = 20
  font6.paint = "#4F4F4F"
  font6.strikethrough = true

  let spans = @[
    newSpan("verb [with object] ", font1),
    newSpan("strallow\n", font2),
    newSpan("\nstralÂ·low\n", font3),
    newSpan("\n1. free (something) from ", font4),
    newSpan("restrictive restrictions", font5),
    newSpan(" ", font4),
    newSpan("\"the regulations are intended to strallow changes in public policy\" ", font6)
  ]

  let image = newImage(400, 400)
  image.fill(rgba(255, 255, 255, 255))

  let arrangement = typeset(spans, bounds = vec2(360, 360))

  image.fillText(arrangement, translate(vec2(20, 20)))

  image.xray("tests/fonts/masters/spans6.png")

block:

  let typeface1 = readTypeface("tests/fonts/PinyonScript.ttf")

  var font1 = newFont(typeface1)
  font1.size = 82
  font1.lineHeight = 60
  font1.paint = "#000000"

  let spans = @[
    newSpan("Fancy text", font1),
  ]

  let image = newImage(400, 400)
  image.fill(rgba(255, 255, 255, 255))
  let ctx = newContext(image)
  ctx.fillStyle = "#FFD6D6"
  ctx.fillRect(rect(40, 170, 320, 60))

  let
    arrangement = typeset(spans, bounds = vec2(320, 60))
    snappedBounds = arrangement.computeBounds().snapToPixels()
    textImage = newImage(snappedBounds.w.int, snappedBounds.h.int)
  textImage.fillText(arrangement, translate(-snappedBounds.xy))

  image.draw(textImage, translate(snappedBounds.xy + vec2(40, 170)))

  # Enable this to show bounds
  # ctx.strokeStyle = "#FF0000"
  # ctx.translate(vec2(40, 170))
  # ctx.strokeRect(arrangement.computeBounds())

  # Enable this to show how text is drawing directly
  # image.fillText(arrangement, translate(vec2(40, 170)))

  image.xray("tests/fonts/masters/spans7.png")

block:
  var font = readFont("tests/fonts/Roboto-Regular_1.ttf")
  font.size = 36

  var paints: seq[Paint]
  paints.add(rgba(0, 0, 255, 127))
  paints.add(rgba(255, 0, 0, 127))

  font.paints = paints

  let image = newImage(200, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(
    font,
    "Multiple fills",
    bounds = vec2(200, 0)
  )

  image.xray("tests/fonts/masters/paints1.png")

block:
  var typeface = readTypeface("tests/fonts/Roboto-Regular_1.ttf")
  doAssert typeface.getKerningAdjustment('T'.Rune, 'e'.Rune) == -99.0

block:
  var font = readFont("tests/fonts/Inter-Regular.ttf")
  font.size = 26
  let image = newImage(800, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(font, "Grumpy wizards make toxic brew for the evil Queen and Jack.")

  image.xray("tests/fonts/masters/cff.png")

block:
  var font = readFont("tests/fonts/NotoSansJP-Regular.ttf")
  font.size = 26
  let image = newImage(800, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(font, "ä»°ã‚³ã‚½ä¼šç¥¨ã‚«ã‚¯å¸°äº†ãƒŽçµ‚æº–æ¸¯ã¿ã›ã‚¹è­°å¾³ãƒ¢ãƒã‚¿æè«‹ãƒ«ã¾ã¤åŠ›è·¯ãŠ")

  image.xray("tests/fonts/masters/cff_jp.png")

block:
  var font = readFont("tests/fonts/Inter-Regular.ttf")
  font.size = 26
  font.underline = true
  let image = newImage(800, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(font, "Grumpy wizards make toxic brew for the evil Queen and Jack.")

  image.xray("tests/fonts/masters/cff_underline.png")

block:
  var font = readFont("tests/fonts/Inter-Regular.ttf")
  font.size = 26
  font.strikethrough = true
  let image = newImage(800, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(font, "Grumpy wizards make toxic brew for the evil Queen and Jack.")

  image.xray("tests/fonts/masters/cff_strikethrough.png")

block:
  var font = readFont("tests/fonts/Inter-Regular.ttf")
  var typeface = readTypeface("tests/fonts/NotoSansJP-Regular.ttf")
  font.typeface.fallbacks.add(typeface)
  font.size = 26
  let image = newImage(800, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(font, "Grumpy ã‚¦ã‚£ã‚¶ãƒ¼ãƒ‰ make æœ‰æ¯’ãªé†¸é€  for the æ‚ªã„å¥³çŽ‹ and Jack.")

  image.xray("tests/fonts/masters/fallback.png")

block:
  let
    font = readFont("tests/fonts/Inter-Regular.ttf")
    typeface1 = readTypeface("tests/fonts/Aclonica-Regular_1.ttf")
    typeface2 = readTypeface("tests/fonts/Ubuntu-Regular_1.ttf")
    typeface3 = readTypeface("tests/fonts/NotoSansJP-Regular.ttf")

  #  font
  #   |.... typeface1
  #         |.... typeface2
  #         |.... typeface3 (with JP)

  font.typeface.fallbacks.add(typeface1)
  typeface1.fallbacks.add(typeface2)
  typeface1.fallbacks.add(typeface3)

  font.size = 26
  let image = newImage(800, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(font, "Grumpy ã‚¦ã‚£ã‚¶ãƒ¼ãƒ‰ make æœ‰æ¯’ãªé†¸é€  for the æ‚ªã„å¥³çŽ‹ and Jack.")

  image.xray("tests/fonts/masters/fallback2.png")

block:
  var font = readFont("tests/fonts/Inter-Regular.ttf")

  font.size = 26
  let image = newImage(800, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(font, "This[î‚™]Advance!")

  image.xray("tests/fonts/masters/tofu_advance.png")

block:
  let image = newImage(200, 200)
  image.fill(color(1, 1, 1, 1))

  let paint = newPaint(SolidPaint)
  paint.color = color(1, 0, 0, 1)

  let ctx = newContext(image)
  ctx.lineWidth = 1
  ctx.strokeStyle = paint
  ctx.strokeRect(0, 60, 200, 80)

  let text = "AbCd\naBcD"

  let font = pixie.read_font("tests/fonts/Inter-Bold.ttf")
  font.size = 40
  font.line_height = 27

  let arrangement1 = font.typeset(
    text,
    vec2(200, 80),
    CenterAlign,
    TopAlign
  )

  # let p1 = newPath()
  # p1.rect(arrangement1.selectionRects[0])
  # image.fillpath(p1, rgba(196, 196, 196, 255), translate(vec2(0, 266)))

  font.paint.color = color(1, 0, 0, 1)
  image.fillText(arrangement1, translate(vec2(0, 60)))

  let arrangement2 = font.typeset(
    text,
    vec2(200, 80),
    CenterAlign,
    MiddleAlign
  )

  # let p2 = newPath()
  # p2.rect(arrangement2.selectionRects[0])
  # image.fillpath(p2, rgba(196, 196, 196, 255), translate(vec2(0, 266)))

  font.paint.color = color(0, 1, 0, 1)
  image.fillText(arrangement2, translate(vec2(0, 60)))

  font.paint.color = color(0, 0, 1, 1)
  image.fillText(
      font,
      text,
      bounds = vec2(200, 80),
      hAlign = CenterAlign,
      vAlign = BottomAlign,
      transform = translate(vec2(0, 60))
  )

  image.xray("tests/fonts/masters/customlineheight.png")

block:
  var font = readTypefaces("tests/fonts/PTSans.ttc")[0].newFont
  font.size = 72
  let image = newImage(200, 100)
  image.fill(rgba(255, 255, 255, 255))
  image.fillText(font, "AbCd")

block:
  var typefaces = readTypefaces("tests/fonts/PTSans.ttc")
  for i, typeface in typefaces:
    echo i, ": ", typeface.name

when defined(windows):
  block:
    let files = @[
      "/Windows/Fonts/batang.ttc",
      "/Windows/Fonts/BIZ-UDGothicB.ttc",
      "/Windows/Fonts/BIZ-UDGothicR.ttc",
      "/Windows/Fonts/BIZ-UDMinchoM.ttc",
      "/Windows/Fonts/cambria.ttc",
      "/Windows/Fonts/gulim.ttc",
      "/Windows/Fonts/meiryo.ttc",
      "/Windows/Fonts/meiryob.ttc",
      "/Windows/Fonts/mingliub.ttc",
      "/Windows/Fonts/msgothic.ttc",
      "/Windows/Fonts/msjh.ttc",
      "/Windows/Fonts/msjhbd.ttc",
      "/Windows/Fonts/msjhl.ttc",
      "/Windows/Fonts/msmincho.ttc",
      "/Windows/Fonts/msyh.ttc",
      "/Windows/Fonts/msyhbd.ttc",
      "/Windows/Fonts/msyhl.ttc",
      "/Windows/Fonts/simsun.ttc",
      "/Windows/Fonts/Sitka.ttc",
      "/Windows/Fonts/SitkaB.ttc",
      "/Windows/Fonts/SitkaI.ttc",
      "/Windows/Fonts/SitkaZ.ttc",
      "/Windows/Fonts/UDDigiKyokashoN-B.ttc",
      "/Windows/Fonts/UDDigiKyokashoN-R.ttc",
      "/Windows/Fonts/YuGothB.ttc",
      "/Windows/Fonts/YuGothL.ttc",
      "/Windows/Fonts/YuGothM.ttc",
      "/Windows/Fonts/YuGothR.ttc",
    ]
    for file in files:
      if fileExists(file):
        echo file
        var typefaces = readTypefaces(file)
        for i, typeface in typefaces:
          echo i, ": ", typeface.name



================================================
FILE: tests/test_gif.nim
================================================
import pixie, pixie/fileformats/gif, xrays

block:
  let
    path = "tests/fileformats/gif/3x5.gif"
    image = readImage(path)
    dimensions = decodeGifDimensions(readFile(path))
  image.xray("tests/fileformats/gif/3x5.png")
  doAssert image.width == dimensions.width
  doAssert image.height == dimensions.height

block:
  let
    path = "tests/fileformats/gif/audrey.gif"
    image = readImage(path)
    dimensions = decodeGifDimensions(readFile(path))
  image.xray("tests/fileformats/gif/audrey.png")
  doAssert image.width == dimensions.width
  doAssert image.height == dimensions.height

block:
  let
    path = "tests/fileformats/gif/sunflower.gif"
    image = readImage(path)
    dimensions = decodeGifDimensions(readFile(path))
  image.xray("tests/fileformats/gif/sunflower.png")
  doAssert image.width == dimensions.width
  doAssert image.height == dimensions.height

block:
  let
    path = "tests/fileformats/gif/sunflower.gif"
    image = readImage(path)
    dimensions = decodeGifDimensions(readFile(path))
  image.xray("tests/fileformats/gif/sunflower.png")
  doAssert image.width == dimensions.width
  doAssert image.height == dimensions.height

block:
  let img4 = readImage("tests/fileformats/gif/newtons_cradle.gif")
  img4.xray("tests/fileformats/gif/newtons_cradle.png")

  let animatedGif =
    decodeGif(readFile("tests/fileformats/gif/newtons_cradle.gif"))
  doAssert animatedGif.frames.len == 36
  doAssert animatedGif.intervals.len == animatedGif.frames.len



================================================
FILE: tests/test_images.nim
================================================
import chroma, pixie, pixie/internal, vmath, xrays

block:
  let image = newImage(10, 10)
  image[0, 0] = rgba(255, 255, 255, 255)
  doAssert image[0, 0] == rgba(255, 255, 255, 255)

block:
  let image = newImage(10, 10)
  image.fill(rgba(255, 0, 0, 255))
  doAssert image[0, 0] == rgba(255, 0, 0, 255)

block:
  let
    image = newImage(256, 256)
    subImage = image.subImage(0, 0, 128, 128)
  doAssert subImage.width == 128 and subImage.height == 128

block:
  let image = newImage(10, 10)
  image.fill(rgba(255, 0, 0, 128))
  image.data.toPremultipliedAlpha()
  doAssert image[9, 9] == rgba(128, 0, 0, 128)

block:
  var data = newSeq[ColorRGBX](100)
  fillUnsafe(data, rgbx(100, 0, 0, 128), 0, data.len)
  data.toStraightAlpha()
  doAssert data[10] == rgbx(199, 0, 0, 128)

block:
  let image = newImage(100, 100)
  image.fill(rgbx(200, 200, 200, 200))
  image.applyOpacity(0.5)
  doAssert image[0, 0] == rgbx(100, 100, 100, 100)
  doAssert image[88, 88] == rgbx(100, 100, 100, 100)

block:
  let
    a = newImage(101, 101)
    b = newImage(50, 50)

  a.fill(rgba(255, 0, 0, 255))
  b.fill(rgba(0, 255, 0, 255))

  a.draw(b)

  a.xray("tests/images/flipped1.png")
  a.flipVertical()
  a.xray("tests/images/flipped2.png")
  a.flipHorizontal()
  a.xray("tests/images/flipped3.png")

block:
  let
    a = readImage("tests/images/flipped1.png")
    b = a.superImage(-10, 0, 20, 20)
  b.xray("tests/images/superimage1.png")

block:
  let
    a = readImage("tests/images/flipped1.png")
    b = a.superImage(-10, -10, 20, 20)
  b.xray("tests/images/superimage2.png")

block:
  let
    a = readImage("tests/images/flipped1.png")
    b = a.superImage(90, 0, 120, 120)
  b.xray("tests/images/superimage3.png")

block:
  let
    a = readImage("tests/images/flipped1.png")
    b = a.superImage(90, 90, 120, 120)
  b.xray("tests/images/superimage4.png")

block:
  let
    a = readImage("tests/images/flipped1.png")
    b = a.superImage(-10, -10, 120, 120)
  b.xray("tests/images/superimage5.png")

block:
  let
    a = readImage("tests/images/flipped1.png")
    b = a.superImage(45, 45, 20, 20)
  b.xray("tests/images/superimage6.png")

block:
  let
    a = readImage("tests/images/flipped1.png")
    b = a.minifyBy2()
  b.xray("tests/images/minifiedBy2.png")

block:
  let
    a = readImage("tests/images/minifiedBy2.png")
    b = a.magnifyBy2()
  b.xray("tests/images/magnifiedBy2.png")

block:
  let
    a = readImage("tests/images/flipped1.png")
    b = a.minifyBy2(2)
  b.xray("tests/images/minifiedBy4.png")

block:
  let
    a = readImage("tests/images/minifiedBy4.png")
    b = a.magnifyBy2(2)
  b.xray("tests/images/magnifiedBy4.png")

block:
  let
    a = readImage("tests/fileformats/png/mandrill.png")
    b = a.minifyBy2()
  b.xray("tests/images/minifiedMandrill.png")

block:
  let a = newImage(100, 100)
  a.fill(rgbx(50, 100, 150, 200))
  a.invert()
  doAssert a[0, 0] == rgbx(44, 33, 23, 55)

block:
  let ctx = newContext(100, 100)
  ctx.fillStyle = rgba(255, 255, 255, 255)
  ctx.image.fill(rgba(0, 0, 0, 255))
  ctx.fillRect(rect(25, 25, 50, 50), )
  ctx.image.blur(20)
  ctx.image.xray("tests/images/imageblur20.png")

block:
  let ctx = newContext(100, 100)
  ctx.fillStyle = rgba(255, 255, 255, 255)
  ctx.image.fill(rgba(0, 0, 0, 255))
  ctx.fillRect(rect(25, 25, 50, 50))
  ctx.image.blur(20, rgba(0, 0, 0, 255))
  ctx.image.xray("tests/images/imageblur20oob.png")

block:
  let image = newImage(100, 100)
  doAssert image.isOneColor()

block:
  let image = newImage(100, 100)
  image.fill(rgba(255, 255, 255, 255))
  doAssert image.isOneColor()

block:
  let image = newImage(100, 100)
  image.fill(rgba(1, 2, 3, 4))
  doAssert image.isOneColor()

block:
  let image = newImage(100, 100)
  image[99, 99] = rgba(255, 255, 255, 255)
  doAssert not image.isOneColor()

block:
  let image = newImage(100, 100)
  doAssert image.isTransparent()

block:
  let image = newImage(100, 100)
  image.fill(rgba(255, 255, 255, 0))
  doAssert image.isTransparent()

block:
  let image = newImage(100, 100)
  image[99, 99] = rgba(255, 255, 255, 255)
  doAssert not image.isTransparent()

block:
  let image = newImage(100, 100)
  image.fill(rgba(255, 255, 255, 255))
  doAssert not image.isTransparent()

block:
  let image = newImage(100, 100)
  image.fill(rgba(255, 255, 255, 255))
  doAssert image.isOpaque()

block:
  let image = newImage(100, 100)
  image.fill(rgba(255, 255, 255, 255))
  image[9, 13] = rgbx(250, 250, 250, 250)
  doAssert not image.isOpaque()

block:
  let a = newImage(400, 400)
  let b = newImage(156, 434)
  b.fill(rgba(255, 0, 0, 255))
  a.draw(
    b,
    mat3(
      -0.5, -4.371138828673793e-008, 0.0,
      -4.371138828673793e-008, 0.5, 0.0,
      292.0, 45.0, 1.0
    )
  )

block:
  var
    colors: seq[ColorRGBA]
    premultiplied: seq[ColorRGBX]
  for a in 0.uint8 .. 255:
    for r in 0.uint8 .. 255:
      let
        rgba = rgba(r, 0, 0, a)
        floats = rgba.color()
        premul = color(floats.r * floats.a, 0, 0, floats.a)
        rgbx = rgbx(
          round(premul.r * 255).uint8,
          0,
          0,
          round(premul.a * 255).uint8
        )
      colors.add(rgba)
      premultiplied.add(rgbx)

  var converted = cast[seq[ColorRGBX]](colors)
  toPremultipliedAlpha(converted)

  for i in 0 ..< premultiplied.len:
    doAssert premultiplied[i] == converted[i]
    doAssert colors[i].rgbx == converted[i]

block:
  let image = newImage(100, 100)
  image.fill("white")
  doAssert image[10, 10] == rgba(255, 255, 255, 255)

block:
  # opaqueBounds of fully transparent image.
  let image = newImage(100, 100)
  doAssert image.opaqueBounds() == rect(0, 0, 0, 0)

block:
  # opaqueBounds of fully opaque image.
  let image = newImage(100, 100)
  image.fill(rgbx(255, 255, 255, 255))
  doAssert image.opaqueBounds() == rect(0.0, 0.0, 100.0, 100.0)

block:
  let image = newImage(160, 160)
  image.fillPath(
    """
      M 20 20
      L 140 20
      L 80 140
      z
    """,
    parseHtmlColor("#FC427B").rgba,
    scale(vec2(0.3, 0.3))
  )
  let rect = image.opaqueBounds()
  let trimmedImage = image.subImage(rect)
  trimmedImage.xray("tests/images/opaqueBounds.png")



================================================
FILE: tests/test_images_draw.nim
================================================
import pixie, strformat, xrays

block:
  let
    a = newImage(1000, 1000)
    b = newImage(500, 500)
  a.fill(rgba(255, 0, 0, 255))
  b.fill(rgba(0, 255, 0, 255))

  a.draw(b, translate(vec2(250, 250)))
  a.xray("tests/images/rotate0.png")

block:
  let
    a = newImage(1000, 1000)
    b = newImage(500, 500)
  a.fill(rgba(255, 0, 0, 255))
  b.fill(rgba(0, 255, 0, 255))

  a.draw(b, translate(vec2(250, 250)) * rotate(90 * PI.float32 / 180))
  a.xray("tests/images/rotate90.png")

block:
  let
    a = newImage(1000, 1000)
    b = newImage(500, 500)
  a.fill(rgba(255, 0, 0, 255))
  b.fill(rgba(0, 255, 0, 255))

  a.draw(b, translate(vec2(250, 250)) * rotate(180 * PI.float32 / 180))
  a.xray("tests/images/rotate180.png")

block:
  let
    a = newImage(1000, 1000)
    b = newImage(500, 500)
  a.fill(rgba(255, 0, 0, 255))
  b.fill(rgba(0, 255, 0, 255))

  a.draw(b, translate(vec2(250, 250)) * rotate(270 * PI.float32 / 180))
  a.xray("tests/images/rotate270.png")

block:
  let
    a = newImage(1000, 1000)
    b = newImage(500, 500)
  a.fill(rgba(255, 0, 0, 255))
  b.fill(rgba(0, 255, 0, 255))

  a.draw(b, translate(vec2(250, 250)) * rotate(360 * PI.float32 / 180))
  a.xray("tests/images/rotate360.png")

block:
  let ctx = newContext(100, 100)
  ctx.fillStyle = rgba(255, 255, 0, 255)
  ctx.image.fill(rgba(0, 255, 255, 255))
  ctx.fillRect(rect(vec2(10, 10), vec2(30, 30)))
  ctx.image.xray("tests/images/drawRect.png")

block:
  let ctx = newContext(100, 100)
  ctx.strokeStyle = rgba(255, 255, 0, 255)
  ctx.lineWidth = 10
  ctx.image.fill(rgba(0, 255, 255, 255))
  ctx.strokeRect(rect(vec2(10, 10), vec2(30, 30)))
  ctx.image.xray("tests/images/strokeRect.png")

block:
  let ctx = newContext(100, 100)
  ctx.fillStyle = rgba(255, 255, 0, 255)
  ctx.image.fill(rgba(0, 255, 255, 255))
  ctx.fillRoundedRect(rect(vec2(10, 10), vec2(30, 30)), 10)
  ctx.image.xray("tests/images/drawRoundedRect.png")

block:
  let ctx = newContext(100, 100)
  ctx.strokeStyle = rgba(255, 255, 0, 255)
  ctx.lineWidth = 10
  ctx.image.fill(rgba(0, 255, 255, 255))
  ctx.strokeRoundedRect(rect(vec2(10, 10), vec2(30, 30)), 10)
  ctx.image.xray("tests/images/strokeRoundedRect.png")

block:
  let ctx = newContext(100, 100)
  ctx.strokeStyle = rgba(255, 255, 0, 255)
  ctx.lineWidth = 10
  ctx.image.fill(rgba(0, 255, 255, 255))
  ctx.strokeSegment(segment(vec2(10, 10), vec2(90, 90)))
  ctx.image.xray("tests/images/drawSegment.png")

block:
  let ctx = newContext(100, 100)
  ctx.fillStyle = rgba(255, 255, 0, 255)
  ctx.image.fill(rgba(0, 255, 255, 255))
  ctx.fillEllipse(vec2(50, 50), 25, 25)
  ctx.image.xray("tests/images/drawEllipse.png")

block:
  let ctx = newContext(100, 100)
  ctx.strokeStyle = rgba(255, 255, 0, 255)
  ctx.lineWidth = 10
  ctx.image.fill(rgba(0, 255, 255, 255))
  ctx.strokeEllipse(vec2(50, 50), 25, 25)
  ctx.image.xray("tests/images/strokeEllipse.png")

block:
  let ctx = newContext(100, 100)
  ctx.fillStyle = rgba(255, 255, 0, 255)
  ctx.image.fill(rgba(0, 255, 255, 255))
  ctx.fillPolygon(vec2(50, 50), 30, 6)
  ctx.image.xray("tests/images/drawPolygon.png")

block:
  let ctx = newContext(100, 100)
  ctx.strokeStyle = rgba(255, 255, 0, 255)
  ctx.lineWidth = 10
  ctx.image.fill(rgba(0, 255, 255, 255))
  ctx.strokePolygon(vec2(50, 50), 30, 6)
  ctx.image.xray("tests/images/strokePolygon.png")

block:
  let
    a = newImage(1000, 1000)
    b = newImage(500, 500)
  a.fill(rgba(255, 0, 0, 255))
  b.fill(rgba(0, 255, 0, 255))

  a.draw(b, translate(vec2(250, 250)) * scale(vec2(0.5, 0.5)))
  a.xray("tests/images/scaleHalf.png")

block:
  let
    a = newImage(100, 100)
    b = newImage(99, 99)
  a.fill(rgba(255, 255, 255, 255))
  b.fill(rgbx(0, 0, 0, 255))
  a.draw(b, translate(vec2(0.5, 0.5)))
  a.xray("tests/images/masters/smooth1.png")

block:
  let
    a = newImage(100, 100)
    b = newImage(50, 50)
  a.fill(rgba(255, 255, 255, 255))
  b.fill(rgbx(0, 0, 0, 255))
  a.draw(b, translate(vec2(0, 50)) * rotate(45.toRadians))
  a.xray("tests/images/masters/smooth2.png")

block:
  let
    a = newImage(100, 100)
    b = newImage(50, 50)
  a.fill(rgba(255, 255, 255, 255))
  b.fill(rgba(0, 0, 0, 255))
  a.draw(b, translate(vec2(25.2, 25)))
  a.xray("tests/images/masters/smooth3.png")

block:
  let
    a = newImage(100, 100)
    b = newImage(50, 50)
  a.fill(rgba(255, 255, 255, 255))
  b.fill(rgba(0, 0, 0, 255))
  a.draw(b, translate(vec2(25.2, 25.6)))
  a.xray("tests/images/masters/smooth4.png")

block:
  let
    a = newImage(100, 100)
    b = newImage(10, 10)
  a.fill(rgba(255, 255, 255, 255))
  b.fill(rgbx(255, 0, 0, 255))
  let m = translate(vec2(50, 50)) * rotate(30.toRadians)
  a.draw(b, m)
  a.xray("tests/images/masters/smooth5.png")

block:
  let
    a = newImage(100, 100)
    b = readImage(&"tests/images/turtle.png")
  a.fill(rgba(255, 255, 255, 255))
  let m = translate(vec2(50, 50)) * rotate(30.toRadians)
  a.draw(b, m)
  a.xray("tests/images/masters/smooth6.png")

block:
  let
    a = newImage(100, 100)
    b = readImage(&"tests/images/turtle@10x.png")
  a.fill(rgba(255, 255, 255, 255))
  let m = translate(vec2(50, 50)) * rotate(30.toRadians) * scale(vec2(0.1, 0.1))
  a.draw(b, m)
  a.xray("tests/images/masters/smooth7.png")

block:
  let
    a = newImage(100, 100)
    b = readImage(&"tests/images/turtle.png")
  a.fill(rgba(255, 255, 255, 255))
  let m = scale(vec2(2, 2))
  a.draw(b, m)
  a.xray("tests/images/masters/smooth8.png")

block:
  let
    a = newImage(100, 100)
    b = readImage(&"tests/images/turtle.png")
  a.fill(rgba(255, 255, 255, 255))
  let m = translate(vec2(1, 1)) * scale(vec2(2, 2))
  a.draw(b, m)
  a.xray("tests/images/masters/smooth9.png")

block:
  let
    a = newImage(100, 100)
    b = readImage(&"tests/images/turtle.png")
  a.fill(rgba(255, 255, 255, 255))
  let m = translate(vec2(0.5, 0.5)) * scale(vec2(2, 2))
  a.draw(b, m)
  a.xray("tests/images/masters/smooth10.png")

block:
  let
    a = newImage(100, 100)
    b = readImage(&"tests/images/turtle.png")
  a.fill(rgba(255, 255, 255, 255))
  let m = translate(vec2(-43.29, -103.87)) *
    rotate(-15.toRadians) *
    scale(vec2(263.86/40, 263.86/40))
  a.draw(b, m)
  a.xray("tests/images/masters/smooth11.png")

block:
  let
    a = newImage(100, 100)
    b = readImage(&"tests/images/turtle.png")
  a.fill(rgba(255, 255, 255, 255))
  let m = translate(vec2(50, 50)) * rotate(-5.toRadians)
  a.draw(b, m * translate(vec2(0, 0)))
  a.draw(b, m * translate(vec2(-40, 0)))
  a.draw(b, m * translate(vec2(-40, -40)))
  a.draw(b, m * translate(vec2(0, -40)))
  a.xray("tests/images/masters/smooth12.png")

block:
  let
    a = newImage(100, 100)
    b = newImage(99, 99)
  a.fill(rgba(255, 255, 255, 255))
  b.fill(rgba(0, 0, 0, 255))
  a.draw(b, scale(vec2(0.5, 0.5)))
  a.xray("tests/images/masters/minify_odd.png")

block:
  let
    rock = readImage("tests/images/rock.png")
    minified = rock.minifyBy2()
  minified.xray("tests/images/masters/rock_minified.png")

block:
  let
    rock = readImage("tests/images/rock.png")
    minified = rock.minifyBy2(2)
  minified.xray("tests/images/masters/rock_minified2.png")

block:
  let pathStr = """
  M 0 0
  L 20 0
  L 20 20
  L 0 20
  z
  """
  let
    image = newImage(20, 20)
    strokeImage = newImage(20, 20)
  image.fillPath(pathStr, color(1.0, 0.5, 0.25, 1.0))
  strokeImage.strokePath(pathStr, color(1, 1, 1, 1), strokeWidth = 4)
  image.draw(strokeImage)

  image.xray("tests/images/fillOptimization.png")
  doAssert image[10, 10] == rgbx(255, 128, 64, 255)

block:
  let a = newImage(100, 100)
  a.fill(color(1, 1, 1, 1))

  let draws = [
    # Overlaps in bounds
    (vec2(-50, -50), color(1, 0, 0, 1)),
    (vec2(50, -50), color(0, 1, 0, 1)),
    (vec2(50, 50), color(0, 0, 1, 1)),
    (vec2(-50, 50), color(1, 1, 0, 1)),
    # Out of bounds
    (vec2(-100, 00), color(1, 0, 1, 1)),
    (vec2(0, -100), color(0, 1, 1, 1)),
    (vec2(100, 00), color(0.5, 0.5, 0.5, 1)),
    (vec2(0, 100), color(0.75, 0.75, 0, 1))
  ]
  for (translation, color) in draws:
    let
      b = newImage(100, 100)
      path = newPath()
    path.rect(0, 0, b.width.float32, b.height.float32)
    b.strokePath(path, color, strokeWidth = 20)

    a.draw(b, translate(translation))

  a.xray("tests/images/fillOptimization2.png")

block:
  let transforms = [
    translate(vec2(0, 0)),
    translate(vec2(50, -50)),
    translate(vec2(50, 50)),
    translate(vec2(-50, 50)),
    translate(vec2(-50, -50))
  ]

  let path = newPath()
  path.rect(10, 10, 80, 80)

  let mask = newImage(100, 100)
  mask.fillPath(path, color(1, 1, 1, 1))

  let a = newImage(100, 100)

  for i, transform in transforms:
    a.fill(color(0, 0, 1, 1))
    a.draw(mask, transform, blendMode = MaskBlend)
    a.xray("tests/images/maskClearsOnDraw" & $i & ".png")

block:
  let transforms = [
    translate(vec2(100, 100)),
    translate(vec2(100, -100)),
    translate(vec2(-100, 100)),
    translate(vec2(-100, -100)),
    translate(vec2(0, 1000)),
    translate(vec2(0, -1000)),
    translate(vec2(1000, 0)),
    translate(vec2(-1000, 0)),
    translate(vec2(1000, 1000)),
    translate(vec2(1000, -1000)),
    translate(vec2(-1000, 1000)),
    translate(vec2(-1000, -1000)),
  ]

  let path = newPath()
  path.rect(10, 10, 80, 80)

  let mask = newImage(100, 100)
  mask.fillPath(path, color(1, 1, 1, 1))

  let a = newImage(100, 100)

  for i, transform in transforms:
    a.fill(color(0, 0, 1, 1))
    a.draw(mask, transform, blendMode = MaskBlend)
    doAssert a.isTransparent()



================================================
FILE: tests/test_jpeg.nim
================================================
import jpegsuite, pixie, pixie/fileformats/jpeg

for file in jpegSuiteFiles:
  let
    image = readImage(file)
    dimensions = decodeJpegDimensions(readFile(file))
  doAssert image.width == dimensions.width
  doAssert image.height == dimensions.height



================================================
FILE: tests/test_paints.nim
================================================
import chroma, pixie, vmath, xrays

const heartShape = """
    M 10,30
    A 20,20 0,0,1 50,30
    A 20,20 0,0,1 90,30
    Q 90,60 50,90
    Q 10,60 10,30 z
  """

block:
  let image = newImage(100, 100)
  image.fillPath(
    heartShape,
    rgba(255, 0, 0, 255)
  )
  image.xray("tests/paths/paintSolid.png")

block:
  let paint = newPaint(ImagePaint)
  paint.image = readImage("tests/fileformats/png/mandrill.png")
  paint.imageMat = scale(vec2(0.2, 0.2))

  let image = newImage(100, 100)
  image.fillPath(heartShape, paint)
  image.xray("tests/paths/paintImage.png")

block:
  let paint = newPaint(ImagePaint)
  paint.image = readImage("tests/fileformats/png/mandrill.png")
  paint.imageMat = scale(vec2(0.2, 0.2))
  paint.opacity = 0.5

  let image = newImage(100, 100)
  image.fillPath(heartShape, paint)
  image.xray("tests/paths/paintImageOpacity.png")

block:
  let paint = newPaint(TiledImagePaint)
  paint.image = readImage("tests/fileformats/png/mandrill.png")
  paint.imageMat = scale(vec2(0.02, 0.02))

  let image = newImage(100, 100)
  image.fillPath(heartShape, paint)
  image.xray("tests/paths/paintImageTiled.png")

block:
  let paint = newPaint(TiledImagePaint)
  paint.image = readImage("tests/fileformats/png/mandrill.png")
  paint.imageMat = scale(vec2(0.02, 0.02))
  paint.opacity = 0.5

  let image = newImage(100, 100)
  image.fillPath(heartShape, paint)
  image.xray("tests/paths/paintImageTiledOpacity.png")

block:
  let paint = newPaint(LinearGradientPaint)
  paint.gradientHandlePositions = @[
    vec2(0, 50),
    vec2(100, 50),
  ]
  paint.gradientStops = @[
    ColorStop(color: color(1, 0, 0, 1), position: 0),
    ColorStop(color: color(1, 0, 0, 0.15625), position: 1.0),
  ]

  let image = newImage(100, 100)
  image.fillPath(heartShape, paint)
  image.xray("tests/paths/gradientLinear.png")

block:
  let paint = newPaint(LinearGradientPaint)
  paint.gradientHandlePositions = @[
    vec2(50, 0),
    vec2(50, 100),
  ]
  paint.gradientStops = @[
    ColorStop(color: color(1, 0, 0, 1), position: 0),
    ColorStop(color: color(1, 0, 0, 0.15625), position: 1.0),
  ]

  let image = newImage(100, 100)
  image.fillPath(heartShape, paint)
  image.xray("tests/paths/gradientLinear2.png")

block:
  let paint = newPaint(RadialGradientPaint)
  paint.gradientHandlePositions = @[
    vec2(50, 50),
    vec2(100, 50),
    vec2(50, 100)
  ]
  paint.gradientStops = @[
    ColorStop(color: color(1, 0, 0, 1), position: 0),
    ColorStop(color: color(1, 0, 0, 0.15625), position: 1.0),
  ]

  let image = newImage(100, 100)
  image.fillPath(heartShape, paint)
  image.xray("tests/paths/gradientRadial.png")

block:
  let paint = newPaint(AngularGradientPaint)
  paint.gradientHandlePositions = @[
    vec2(50, 50),
    vec2(100, 50),
    vec2(50, 100)
  ]
  paint.gradientStops = @[
    ColorStop(color: color(1, 0, 0, 1), position: 0),
    ColorStop(color: color(1, 0, 0, 0.15625), position: 1.0),
  ]

  let image = newImage(100, 100)
  image.fillPath(heartShape, paint)
  image.xray("tests/paths/gradientAngular.png")

block:
  let paint = newPaint(AngularGradientPaint)
  paint.gradientHandlePositions = @[
    vec2(50, 50),
    vec2(100, 50),
    vec2(50, 100)
  ]
  paint.gradientStops = @[
    ColorStop(color: color(1, 0, 0, 1), position: 0),
    ColorStop(color: color(1, 0, 0, 0.15625), position: 1.0),
  ]
  paint.opacity = 0.5

  let image = newImage(100, 100)
  image.fillPath(heartShape, paint)
  image.xray("tests/paths/gradientAngularOpacity.png")

block:
  let paint = newPaint(ImagePaint)
  paint.image = readImage("tests/fileformats/png/mandrill.png")
  paint.imageMat = scale(vec2(0.2, 0.2))
  paint.opacity = 0.5

  let image = newImage(128, 128)
  image.fill(rgbx(0, 255, 0, 255))
  image.fill(paint)
  image.xray("tests/paths/fillImagePaint.png")

block:
  let paint = newPaint(TiledImagePaint)
  paint.image = readImage("tests/fileformats/png/mandrill.png")
  paint.imageMat = scale(vec2(0.1, 0.1))
  paint.opacity = 0.5

  let image = newImage(128, 128)
  image.fill(rgbx(0, 255, 0, 255))
  image.fill(paint)
  image.xray("tests/paths/fillTiledImagePaint.png")



================================================
FILE: tests/test_paths.nim
================================================
import chroma, pixie, pixie/fileformats/png, strformat, xrays

block:
  let pathStr = """
  m 1 2 3 4 5 6
  """
  let path = parsePath(pathStr)
  doAssert $path == "m1 2 l3 4 l5 6"

block:
  let pathStr = """
  l 1 2 3 4 5 6
  """
  let path = parsePath(pathStr)
  doAssert $path == "l1 2 l3 4 l5 6"

block:
  let pathStr = """
    m 1 2
    l 3 4
    h 5
    v 6
    c 0 0 0 0 0 0
    q 1 1 1 1
    t 2 2
    a 7 7 7 7 7 7 7
    z
  """
  let path = parsePath(pathStr)
  doAssert $path == "m1 2 l3 4 h5 v6 c0 0 0 0 0 0 q1 1 1 1 t2 2 a7 7 7 7 7 7 7 Z"

block:
  let pathStr = """
    M 1 2
    L 3 4
    H 5
    V 6
    C 0 0 0 0 0 0
    Q 1 1 1 1
    T 2 2
    A 7 7 7 7 7 7 7
    z
  """
  let path = parsePath(pathStr)
  doAssert $path == "M1 2 L3 4 H5 V6 C0 0 0 0 0 0 Q1 1 1 1 T2 2 A7 7 7 7 7 7 7 Z"

block:
  let pathStr = "M 0.1E-10 0.1e10 L2+2 L3-3 L0.1E+10-1"
  discard parsePath(pathStr)

block:
  let
    image = newImage(100, 100)
    pathStr = "M 10 10 L 90 90"
    color = rgba(255, 0, 0, 255)
  image.strokePath(pathStr, color, strokeWidth = 10)
  image.xray("tests/paths/pathStroke1.png")

block:
  let
    image = newImage(100, 100)
    pathStr = "M 10 10 L 50 60 90 90"
    color = rgba(255, 0, 0, 255)
  image.strokePath(pathStr, color, strokeWidth = 10)
  image.xray("tests/paths/pathStroke2.png")

block:
  let image = newImage(100, 100)
  image.strokePath(
    "M 15 10 L 30 90 60 30 90 90",
    rgba(255, 255, 0, 255),
    strokeWidth = 10
  )
  image.xray("tests/paths/pathStroke3.png")

block:
  let
    image = newImage(100, 100)
    pathStr = "M 10 10 H 90 V 90 H 10 L 10 10"
    color = rgba(0, 0, 0, 255)
  image.fillPath(pathStr, color)
  image.xray("tests/paths/pathBlackRectangle.png")

block:
  let
    image = newImage(100, 100)
    pathStr = "M 10 10 H 90 V 90 H 10 Z"
    color = rgba(0, 0, 0, 255)
  image.fillPath(parsePath(pathStr), color)
  image.xray("tests/paths/pathBlackRectangleZ.png")

block:
  let image = newImage(100, 100)
  image.fillPath(
    "M 10 10 H 90 V 90 H 10 L 10 10",
    rgba(255, 255, 0, 255)
  )
  image.xray("tests/paths/pathYellowRectangle.png")

block:
  let path = newPath()
  path.moveTo(10, 10)
  path.lineTo(10, 90)
  path.lineTo(90, 90)
  path.lineTo(90, 10)
  path.lineTo(10, 10)

  let image = newImage(100, 100)
  image.fillPath(path, rgba(255, 0, 0, 255))
  image.xray("tests/paths/pathRedRectangle.png")

block:
  let image = newImage(100, 100)
  image.fillPath(
    "M30 60 A 20 20 0 0 0 90 60 L 30 60",
    parseHtmlColor("#FC427B").rgba
  )
  image.xray("tests/paths/pathBottomArc.png")

block:
  let image = newImage(100, 100)
  image.fillPath(
    """
      M 10,30
      A 20,20 0,0,1 50,30
      A 20,20 0,0,1 90,30
      Q 90,60 50,90
      Q 10,60 10,30 z
    """,
    parseHtmlColor("#FC427B").rgba
  )
  image.xray("tests/paths/pathHeart.png")

block:
  let image = newImage(100, 100)
  image.fillPath(
    "M 20 50 A 20 10 45 1 1 80 50 L 20 50",
    parseHtmlColor("#FC427B").rgba
  )
  image.xray("tests/paths/pathRotatedArc.png")

block:
  let image = newImage(100, 100)
  image.fillPath(
    "M 0 50 A 50 50 0 0 0 50 0 L 50 50 L 0 50",
    parseHtmlColor("#FC427B").rgba
  )
  image.xray("tests/paths/pathInvertedCornerArc.png")

block:
  let image = newImage(100, 100)
  image.fillPath(
    "M 0 50 A 50 50 0 0 1 50 0 L 50 50 L 0 50",
    parseHtmlColor("#FC427B").rgba
  )
  image.xray("tests/paths/pathCornerArc.png")

# block:
#   let
#     image = newImage(100, 100)
#     r = 10.0
#     x = 10.0
#     y = 10.0
#     h = 80.0
#     w = 80.0
#   let path = newPath()
#   path.moveTo(x + r, y)
#   path.arcTo(x + w, y, x + w, y + h, r)
#   path.arcTo(x + w, y + h, x, y + h, r)
#   path.arcTo(x, y + h, x, y, r)
#   path.arcTo(x, y, x + w, y, r)
#   image.fillPath(path, rgba(255, 0, 0, 255))
#   image.xray("tests/paths/pathRoundRect.png")

block:
  let image = newImage(200, 200)
  image.fill(rgba(255, 255, 255, 255))

  var p = parsePath("M1 0.5C1 0.776142 0.776142 1 0.5 1C0.223858 1 0 0.776142 0 0.5C0 0.223858 0.223858 0 0.5 0C0.776142 0 1 0.223858 1 0.5Z")
  image.fillPath(p, rgba(255, 0, 0, 255), scale(vec2(200, 200)))

  image.strokePath(p, rgba(0, 255, 0, 255), scale(vec2(200, 200)),
      strokeWidth = 0.01)

  image.xray("tests/paths/pixelScale.png")

block:
  let
    image = newImage(60, 60)
    path = parsePath("M 3 3 L 20 3 L 20 20 L 3 20 Z")
  image.fill(rgba(255, 255, 255, 255))
  image.strokePath(
    path, rgba(0, 0, 0, 255), translate(vec2(10, 10)), 10, RoundCap, RoundJoin
  )

  image.xray("tests/paths/boxRound.png")

block:
  let
    image = newImage(60, 60)
    path = parsePath("M 3 3 L 20 3 L 20 20 L 3 20 Z")
  image.fill(rgba(255, 255, 255, 255))
  image.strokePath(
    path, rgba(0, 0, 0, 255), translate(vec2(10, 10)), 10, RoundCap, BevelJoin
  )

  image.xray("tests/paths/boxBevel.png")

block:
  let
    image = newImage(60, 60)
    path = parsePath("M 3 3 L 20 3 L 20 20 L 3 20 Z")
  image.fill(rgba(255, 255, 255, 255))
  image.strokePath(
    path, rgba(0, 0, 0, 255), translate(vec2(10, 10)), 10, RoundCap, MiterJoin
  )

  image.xray("tests/paths/boxMiter.png")

block:
  let
    image = newImage(60, 60)
    path = parsePath("M 3 3 L 20 3 L 20 20 L 3 20")
  image.fill(rgba(255, 255, 255, 255))
  image.strokePath(
    path, rgba(0, 0, 0, 255), translate(vec2(10, 10)), 10, ButtCap, BevelJoin
  )

  image.xray("tests/paths/ButtCap.png")

block:
  let
    image = newImage(60, 60)
    path = parsePath("M 3 3 L 20 3 L 20 20 L 3 20")
  image.fill(rgba(255, 255, 255, 255))
  image.strokePath(
    path, rgba(0, 0, 0, 255), translate(vec2(10, 10)), 10, RoundCap, BevelJoin
  )

  image.xray("tests/paths/RoundCap.png")

block:
  let
    image = newImage(60, 60)
    path = parsePath("M 3 3 L 20 3 L 20 20 L 3 20")
  image.fill(rgba(255, 255, 255, 255))
  image.strokePath(
    path, rgba(0, 0, 0, 255), translate(vec2(10, 10)), 10, SquareCap, BevelJoin
  )

  image.xray("tests/paths/SquareCap.png")

block:
  let
    image = newImage(60, 120)
    path = parsePath("M 0 0 L 50 0")
  image.fill(rgba(255, 255, 255, 255))

  image.strokePath(
    path, rgba(0, 0, 0, 255), translate(vec2(5, 5)), 10, ButtCap, BevelJoin,
  )

  image.strokePath(
    path, rgba(0, 0, 0, 255), translate(vec2(5, 25)), 10, ButtCap, BevelJoin,
    dashes = @[2.float32, 2]
  )

  image.strokePath(
    path, rgba(0, 0, 0, 255), translate(vec2(5, 45)), 10, ButtCap, BevelJoin,
    dashes = @[4.float32, 4]
  )

  image.strokePath(
    path, rgba(0, 0, 0, 255), translate(vec2(5, 65)), 10, ButtCap, BevelJoin,
    dashes = @[2.float32, 4, 6, 2]
  )

  image.strokePath(
    path, rgba(0, 0, 0, 255), translate(vec2(5, 85)), 10, ButtCap, BevelJoin,
    dashes = @[1.float32]
  )

  image.strokePath(
    path, rgba(0, 0, 0, 255), translate(vec2(5, 105)), 10, ButtCap, BevelJoin,
    dashes = @[1.float32, 2, 3, 4, 5, 6, 7, 8, 9]
  )

  image.xray("tests/paths/dashes.png")

block:
  proc miterTest(angle, limit: float32) =
    let
      image = newImage(60, 60)
    image.fill(rgba(255, 255, 255, 255))
    let path = newPath()
    path.moveTo(-20, 0)
    path.lineTo(0, 0)
    let th = angle.float32.degToRad() + PI/2
    path.lineTo(sin(th)*20, cos(th)*20)

    image.strokePath(
      path, rgba(0, 0, 0, 255), translate(vec2(30, 30)), 8, ButtCap, MiterJoin,
      miterLimit = limit
    )
    image.xray(&"tests/paths/miterLimit_{angle.int}deg_{limit:0.2f}num.png")

  miterTest(10, 2)
  miterTest(145, 2)
  miterTest(155, 2)
  miterTest(165, 2)
  miterTest(165, 10)
  miterTest(145, 3.32)
  miterTest(145, 3.33)

block:
  # Test self closing subpaths on fill
  let
    image = newImage(60, 60)
    path = parsePath("M0 0 L0 0 L60 0 L60 60 L0 60")
  image.fill(rgba(255, 255, 255, 255))
  image.fillPath(path, rgba(127, 127, 127, 255))
  image.xray("tests/paths/selfclosing.png")

# Potential error cases, ensure they do not crash

block:
  let
    image = newImage(60, 60)
    path = parsePath("M 3 3 L 3 3 L 3 3")
  image.fill(rgba(255, 255, 255, 255))
  image.strokePath(
    path, rgba(0, 0, 0, 255), translate(vec2(10, 10)), 10, SquareCap, MiterJoin
  )

block:
  let
    image = newImage(60, 60)
    path = parsePath("L 0 0 L 0 0")
  image.fill(rgba(255, 255, 255, 255))
  image.strokePath(
    path, rgba(0, 0, 0, 255), translate(vec2(10, 10)), 10, SquareCap, MiterJoin
  )

block:
  let
    image = newImage(60, 60)
    path = parsePath("L 1 1")
  image.fill(rgba(255, 255, 255, 255))
  image.strokePath(
    path, rgba(0, 0, 0, 255), translate(vec2(10, 10)), 10, SquareCap, MiterJoin
  )

block:
  let
    image = newImage(60, 60)
    path = parsePath("L 0 0")
  image.fill(rgba(255, 255, 255, 255))
  image.strokePath(
    path, rgba(0, 0, 0, 255), translate(vec2(10, 10)), 10, SquareCap, MiterJoin
  )

block:
  let image = newImage(100, 100)
  image.fillPath(
    "M 10 10 H 60 V 60 H 10 z",
    rgbx(255, 0, 0, 255)
  )

  let paint = newPaint(SolidPaint)
  paint.color = color(0, 1, 0, 1)
  paint.blendMode = ExcludeMaskBlend

  image.fillPath(
    "M 30 30 H 80 V 80 H 30 z",
    paint
  )
  image.xray("tests/paths/rectExcludeMask.png")

block:
  let image = newImage(100, 100)
  image.fillPath(
    "M 10.1 10.1 H 60.1 V 60.1 H 10.1 z",
    rgbx(255, 0, 0, 255)
  )

  let paint = newPaint(SolidPaint)
  paint.color = color(0, 1, 0, 1)
  paint.blendMode = ExcludeMaskBlend

  image.fillPath(
    "M 30.1 30.1 H 80.1 V 80.1 H 30.1 z",
    paint
  )
  image.xray("tests/paths/rectExcludeMaskAA.png")

block:
  let image = newImage(100, 100)
  image.fillPath(
    "M 10 10 H 60 V 60 H 10 z",
    rgbx(255, 0, 0, 255)
  )

  let paint = newPaint(SolidPaint)
  paint.color = color(0, 1, 0, 1)
  paint.blendMode = MaskBlend

  image.fillPath(
    "M 30 30 H 80 V 80 H 30 z",
    paint
  )
  image.xray("tests/paths/rectMask.png")

block:
  let image = newImage(100, 100)
  image.fillPath(
    "M 10.1 10.1 H 60.1 V 60.1 H 10.1 z",
    rgbx(255, 0, 0, 255)
  )

  let paint = newPaint(SolidPaint)
  paint.color = color(0, 1, 0, 1)
  paint.blendMode = MaskBlend

  image.fillPath(
    "M 30.1 30.1 H 80.1 V 80.1 H 30.1 z",
    paint
  )
  image.xray("tests/paths/rectMaskAA.png")

block:
  let image = newImage(100, 100)
  image.fillPath(
    "M 10 10 H 60 V 60 H 10 z",
    rgbx(255, 0, 0, 255)
  )

  let paint = newPaint(SolidPaint)
  paint.color = color(0, 1, 0, 1)
  paint.blendMode = MaskBlend

  image.strokePath(
    "M 30 30 H 50 V 50 H 30 z",
    paint,
    strokeWidth = 10
  )
  image.xray("tests/paths/rectMaskStroke.png")

block:
  var
    surface = newImage(256, 256)
    ctx = newContext(surface)

  surface.fill(rgba(255, 255, 255, 255))

  # Draw shapes
  for i in 0 .. 3:
    for j in 0 .. 2:
      ctx.beginPath()
      let x = 25f + j.float32 * 50f # x coordinate
      let y = 25f + i.float32 * 50f # y coordinate
      let radius = 20f # Arc radius
      let startAngle = 0f # Starting point on circle
      let endAngle = PI + (PI * j.float32) / 2           # End point on circle
      let counterclockwise = i mod 2 == 1 # Draw counterclockwise

      ctx.arc(x, y, radius, startAngle, endAngle, counterclockwise)

      if i > 1:
        ctx.fill()
      else:
        ctx.stroke()

  surface.xray("tests/paths/arc.png")

block:
  var
    surface = newImage(256, 256)
    ctx = newContext(surface)
  surface.fill(rgba(255, 255, 255, 255))

  let
    p0 = vec2(230, 20)
    p1 = vec2(90, 130)
    p2 = vec2(20, 20)

  ctx.beginPath()
  ctx.moveTo(p0.x, p0.y)
  ctx.arcTo(p1.x, p1.y, p2.x, p2.y, 50)
  ctx.lineTo(p2.x, p2.y)
  ctx.stroke()

  surface.xray("tests/paths/arcTo1.png")

block:
  var
    surface = newImage(256, 256)
    ctx = newContext(surface)
  surface.fill(rgba(255, 255, 255, 255))
  # Tangential lines
  ctx.beginPath()
  ctx.strokeStyle = "gray"
  ctx.moveTo(200, 20)
  ctx.lineTo(200, 130)
  ctx.lineTo(50, 20)
  ctx.stroke()

  # Arc
  ctx.beginPath()
  ctx.strokeStyle = "black"
  ctx.lineWidth = 5
  ctx.moveTo(200, 20)
  ctx.arcTo(200, 130, 50, 20, 40)
  ctx.stroke()

  # Start point
  ctx.beginPath()
  ctx.fillStyle = "blue"
  ctx.arc(200, 20, 5, 0, 2 * PI)
  ctx.fill()

  # Control points
  ctx.beginPath()
  ctx.fillStyle = "red"
  ctx.arc(200, 130, 5, 0, 2 * PI) # Control point one
  ctx.arc(50, 20, 5, 0, 2 * PI) # Control point two
  ctx.fill()

  surface.xray("tests/paths/arcTo2.png")

block:
  var
    surface = newImage(256, 256)
    ctx = newContext(surface)
  surface.fill(rgba(255, 255, 255, 255))

  ctx.beginPath()
  ctx.moveTo(180, 90)
  ctx.arcTo(180, 130, 110, 130, 130)
  ctx.lineTo(110, 130)
  ctx.stroke()

  surface.xray("tests/paths/arcTo3.png")

block:
  let path = newPath()
  path.rect(0, 0, 10, 10)

  doAssert path.fillOverlaps(vec2(5, 5))
  doAssert path.fillOverlaps(vec2(0, 0))
  doAssert path.fillOverlaps(vec2(9, 0))
  doAssert path.fillOverlaps(vec2(0, 9))
  doAssert not path.fillOverlaps(vec2(10, 10))

block:
  let path = newPath()
  path.ellipse(20, 20, 20, 10)

  doAssert not path.fillOverlaps(vec2(0, 0))
  doAssert path.fillOverlaps(vec2(20, 20))
  doAssert path.fillOverlaps(vec2(10, 20))
  doAssert path.fillOverlaps(vec2(30, 20))

block:
  let path = newPath()
  path.rect(10, 10, 10, 10)

  doAssert path.strokeOverlaps(vec2(10, 10))
  doAssert path.strokeOverlaps(vec2(20.1, 20.1))
  doAssert not path.strokeOverlaps(vec2(5, 5))

block:
  let path = newPath()
  path.ellipse(20, 20, 20, 10)

  doAssert not path.strokeOverlaps(vec2(0, 0))
  doAssert not path.strokeOverlaps(vec2(20, 20))
  doAssert path.strokeOverlaps(vec2(0, 20))
  doAssert path.strokeOverlaps(vec2(39.9, 19.9))
  doAssert path.strokeOverlaps(vec2(19.8, 30.2))
  doAssert not path.strokeOverlaps(vec2(19.4, 30.6))

block:
  let path = newPath()
  path.circle(50, 50, 30)

  let paint = newPaint(SolidPaint)
  paint.color = color(1, 0, 1, 1)
  paint.opacity = 0.5

  let image = newImage(100, 100)
  image.fillPath(path, paint)

  image.xray("tests/paths/opacityFill.png")

block:
  let path = newPath()
  path.circle(50, 50, 30)

  let paint = newPaint(SolidPaint)
  paint.color = color(1, 0, 1, 1)
  paint.opacity = 0.5

  let image = newImage(100, 100)
  image.strokePath(path, paint, strokeWidth = 10)

  image.xray("tests/paths/opacityStroke.png")

block:
  let
    image = newImage(100, 100)
    pathStr = "M0 0 L200 200"
    color = rgba(255, 0, 0, 255)
  image.strokePath(pathStr, color, strokeWidth = 10)
  image.xray("tests/paths/pathStroke1Big.png")

block:
  let
    image = newImage(100, 100)
    pathStr = "M99 99 L999 99 L999 100 L99 100 Z"
    color = rgba(255, 0, 0, 255)
  image.fillPath(pathStr, color)
  image.xray("tests/paths/path1pxCover.png")

block:
  let
    image = newImage(100, 100)
    pathStr = "M100 100 L999 100 L999 101 L100 101 Z"
    color = rgba(255, 0, 0, 255)
  image.fillPath(pathStr, color)
  image.xray("tests/paths/path0pxCover.png")

block:
  let image = newImage(200, 200)
  image.fill(rgba(255, 255, 255, 255))

  let ctx = newContext(image)
  ctx.setLineDash(@[2.0.float32])

  doAssertRaises PixieError:
    ctx.strokePolygon(vec2(0.0, 0.0), 0.0, 0)

block:
  # Test zero width image fill.
  let
    image = newImage(100, 100)
    pathStr = "M0 0 L0 1 L0 0 Z"
    color = rgba(255, 0, 0, 255)
  image.fillPath(pathStr, color)

block:
  # Test different polygons.
  for i in 3 .. 8:
    let path = newPath()
    path.polygon(vec2(50, 50), 30, i)
    let image = newImage(100, 100)
    image.fillPath(path, color(1, 1, 1, 1))
    image.xray(&"tests/paths/polygon{i}.png")

block:
  let image = newImage(200, 200)
  image.fill(rgba(255, 255, 255, 255))

  let pathStr = """
  L -16370.0 -18156.0
  A 4100 4100 0 1 0 -19670 -14134
  Z
  """

  let path = parsePath(pathStr)

  let paint = newPaint(SolidPaint)
  paint.color = color(255, 255, 255, 255)

  doAssertRaises PixieError:
    image.strokePath(
      path,
      paint
    )

block:
  let image = newImage(200, 200)
  image.fill(rgba(255, 255, 255, 255))

  let pathStr = """
  L 3473901.0 1136732.75
  A 31888.0 31888.0 0 0 1 3493390.25 1076022.375
  L 32563.0 -2081.0"""

  let paint = newPaint(SolidPaint)
  paint.color = color(255, 255, 255, 255)

  let path = parsePath(pathStr)

  doAssertRaises PixieError:
    image.fillPath(
      path,
      paint,
      mat3(),
      NonZero
    )

block:
  let
    image = newImage(100, 100)
    pathStr = """
      M 40 40 L 40 80 L 80 80 L 80 40 C 80 -20 40 100 40 40
    """
    color = rgba(0, 0, 0, 255)
  image.fill(rgba(255, 255, 255, 255))
  image.fillPath(pathStr, color)
  image.xray("tests/paths/pathSwish.png")

# https://www.w3.org/TR/SVG2/coords.html#BoundingBoxes
# block:
#   let pathStr = """
#     M 100 0
#   """
#   let path = parsePath(pathStr)
#   doAssert path.computeBounds() == rect(100, 0, 0, 0)

# block:
#   let pathStr = """
#     M 0 100
#   """
#   let path = parsePath(pathStr)
#   doAssert path.computeBounds() == rect(100, 0, 0, 0)

# block:
#   let pathStr = """
#     M 100 0 M 200 0
#   """
#   let path = parsePath(pathStr)
#   doAssert path.computeBounds() == rect(100, 0, 100, 0)

# block:
#   let pathStr = """
#     M 0 100 M 0 200
#   """
#   let path = parsePath(pathStr)
#   doAssert path.computeBounds() == rect(0, 100, 0, 100)

# block:
#   let pathStr = """
#     M 0 0 L 10 0 L 10 10 L 0 10 M 1000 1000
#   """
#   let path = parsePath(pathStr)
#   doAssert path.computeBounds() == rect(0, 0, 1000, 1000)

block:
  let pathStr = """
    M 0 0
    L 100 0
  """
  let path = parsePath(pathStr)
  doAssert path.computeBounds() == rect(0, 0, 100, 0)

block:
  let pathStr = """
    M 0 0
    L 0 100
  """
  let path = parsePath(pathStr)
  doAssert path.computeBounds() == rect(0, 0, 0, 100)



================================================
FILE: tests/test_png.nim
================================================
import pixie, pixie/fileformats/png, pngsuite, strformat

for file in pngSuiteFiles:
  let
    original = readFile(&"tests/fileformats/png/pngsuite/{file}.png")
    decoded = decodePng(original)
    encoded = encodePng(decoded)

block:
  for channels in 1 .. 4:
    var data: seq[uint8]
    for x in 0 ..< 16:
      for y in 0 ..< 16:
        var components = newSeq[uint8](channels)
        for i in 0 ..< channels:
          components[i] = (x * 16).uint8
        data.add(components)
    let encoded = encodePng(16, 16, channels, data[0].addr, data.len)

  for file in pngSuiteCorruptedFiles:
    try:
      discard decodePng(readFile(&"tests/fileformats/png/pngsuite/{file}.png"))
      doAssert false
    except PixieError:
      discard

block:
  discard readImage("tests/fileformats/png/trailing_data.png")

block:
  let dimensions =
    decodeImageDimensions(readFile("tests/fileformats/png/mandrill.png"))
  doAssert dimensions.width == 512
  doAssert dimensions.height == 512



================================================
FILE: tests/test_ppm.nim
================================================
import pixie/fileformats/ppm

block:
  for format in @["p3", "p6"]:
    let
      path = "tests/fileformats/ppm/feep." & $format & ".master.ppm"
      image = decodePpm(readFile(path))
      dimensions = decodePpmDimensions(readFile(path))
    writeFile("tests/fileformats/ppm/feep." & $format & ".ppm", encodePpm(image))
    doAssert image.width == dimensions.width
    doAssert image.height == dimensions.height

block:
  let
    path = "tests/fileformats/ppm/feep.p3.hidepth.master.ppm"
    image = decodePpm(readFile(path))
    dimensions = decodePpmDimensions(readFile(path))
  writeFile("tests/fileformats/ppm/feep.p3.hidepth.ppm", encodePpm(image))
  doAssert image.width == dimensions.width
  doAssert image.height == dimensions.height

  # produced output should be identical to P6 master
  let p6Master = readFile("tests/fileformats/ppm/feep.p6.master.ppm")
  for image in @["p3", "p6", "p3.hidepth"]:
    doAssert readFile("tests/fileformats/ppm/feep." & $image & ".ppm") == p6Master



================================================
FILE: tests/test_qoi.nim
================================================
import pixie, pixie/fileformats/qoi

const tests = ["testcard", "testcard_rgba"]

for name in tests:
  let
    path = "tests/fileformats/qoi/" & name & ".qoi"
    input = readImage(path)
    control = readImage("tests/fileformats/qoi/" & name & ".png")
    dimensions = decodeQoiDimensions(readFile(path))
  doAssert input.data == control.data, "input mismatch of " & name
  doAssert input.width == dimensions.width
  doAssert input.height == dimensions.height
  discard encodeQoi(control)

for name in tests:
  let
    path = "tests/fileformats/qoi/" & name & ".qoi"
    input = decodeQoi(readFile(path))
    output = decodeQoi(encodeQoi(input))
  doAssert output.data.len == input.data.len
  doAssert output.data == input.data



================================================
FILE: tests/test_svg.nim
================================================
import pixie, pixie/fileformats/svg, strformat, xrays, xmlparser, xmltree

const files = [
  "line01",
  "polyline01",
  "polygon01",
  "rect01",
  "rect02",
  "circle01",
  "ellipse01",
  "triangle01",
  "quad01",
  "Ghostscript_Tiger",
  "scale",
  "miterlimit",
  "dashes",
  "dragon2"
]

for file in files:
  let image = readImage(&"tests/fileformats/svg/{file}.svg")
  image.xray(&"tests/fileformats/svg/masters/{file}.png")

block:
  let
    svg = parseSvg(
      readFile("tests/fileformats/svg/accessibility-outline.svg"),
      512, 512
    )
    image = newImage(svg)
  image.xray(&"tests/fileformats/svg/masters/accessibility-outline.png")

block:
  # Test using XML node by itself, see: https://github.com/treeform/pixie/pull/533
  let
    xmlNode = parseXml(readFile("tests/fileformats/svg/accessibility-outline.svg"))
    svg = parseSvg(
      xmlNode,
      512, 512
    )



================================================
FILE: tests/test_tiff.nim
================================================
import pixie, pixie/fileformats/tiff

let
  t = decodeTiff(readFile("tests/fileformats/tiff/pc260001.tif"))
  image = newImage(t)
# image.writeFile("tests/fileformats/tiff/pc260001.png")



================================================
FILE: tests/validate_fonts.nim
================================================
import pixie, stb_truetype, unicode

let fontFiles = [
  # "tests/fonts/Roboto-Regular_1.ttf"
    # "tests/fonts/Aclonica-Regular_1.ttf"
    # "tests/fonts/Ubuntu-Regular_1.ttf"
    # "tests/fonts/IBMPlexSans-Regular_2.ttf"
    # "tests/fonts/NotoSans-Regular_4.ttf"
  "tests/fonts/Pacifico-Regular_4.ttf"
]

for fontFile in fontFiles:
  let stbtt = initFont(readFile(fontFile))
  var font = readFont(fontFile)

  var ascent, descent, lineGap: cint
  stbtt.getFontVMetrics(ascent, descent, lineGap)

  doAssert font.typeface.ascent == ascent.float32
  doAssert font.typeface.descent == descent.float32
  doAssert font.typeface.lineGap == lineGap.float32

  for i in 32 .. 126:
    var advanceWidth, leftSideBearing: cint
    stbtt.getCodepointHMetrics(Rune(i), advanceWidth, leftSideBearing)

    doAssert font.typeface.getAdvance(Rune(i)) == advanceWidth.float32

  for i in 32 .. 126:
    for j in 32 .. 126:
      # echo i, ": ", $Rune(i), "  ", j, ": ", $Rune(j)
      let
        a = stbtt.getCodepointKernAdvance(Rune(i), Rune(j)).float32
        b = font.typeface.getKerningAdjustment(Rune(i), Rune(j))
      if a != b:
        # echo fontFile
        echo i, ": ", $Rune(i), "  ", j, ": ", $Rune(j)
        echo "DISAGREE: ", a, " != ", b, " <<<<<<<<<<<<<<<<<<<<<<<<<<<"
        # quit()

      # echo stbtt.getCodepointKernAdvance(Rune('r'), Rune('s')).float32
      # echo font.typeface.getKerningAdjustment(Rune('r'), Rune('s'))



================================================
FILE: tests/validate_jpeg.nim
================================================
import jpegsuite, os, pixie, strformat, strutils

createDir("tests/fileformats/jpeg/generated")
createDir("tests/fileformats/jpeg/diffs")

for file in jpegSuiteFiles:
  let img = readImage(file)

  let genFile = file.replace("masters", "generated").replace(".jpg", ".png")
  img.writeFile(genFile)

  if execShellCmd(&"magick {file} -auto-orient {genFile}") != 0:
    echo "fail"

  var img2 = readImage(genFile)
  let (score, diff) = img2.diff(img)

  let diffFile = file.replace("master", "diff").replace(".jpg", ".png")
  diff.writeFile(diffFile)

  if score > 1:
    echo "!!!!!!!!!!!!!! FAIL !!!!!!!!!!!!!"
  echo &"{score:2.3f}% ... {file}"



================================================
FILE: tests/validate_png.nim
================================================
import chroma, pixie/fileformats/png, pngsuite, stb_image/read as stbi, strformat

for file in pngSuiteFiles:
  let
    data = readFile(&"tests/fileformats/png/pngsuite/{file}.png")
    pixieLoaded = decodePng(data)

  var
    width, height, channels: int
    stbiLoadedData = loadFromMemory(
      cast[seq[byte]](data),
      width,
      height,
      channels,
      stbi.RGBA
    )
    stbiLoadedRGBA: seq[ColorRGBA]

  var i: int
  while i < stbiLoadedData.len:
    stbiLoadedRGBA.add(ColorRGBA(
      r: stbiLoadedData[i + 0],
      g: stbiLoadedData[i + 1],
      b: stbiLoadedData[i + 2],
      a: stbiLoadedData[i + 3]
    ))
    i += 4

  doAssert pixieLoaded.width == width
  doAssert pixieLoaded.height == height
  doAssert pixieLoaded.data.len == stbiLoadedRGBA.len
  doAssert pixieLoaded.data == stbiLoadedRGBA



================================================
FILE: tests/xrays.nim
================================================
import os, pixie, strformat, strutils

proc xray*(image: Image, masterPath: string) =
  let
    generatedPath = "tmp/generated/" & masterPath
    xrayPath = "tmp/xray/" & masterPath
  createDir(generatedPath.splitPath.head)
  createDir(xrayPath.splitPath.head)
  image.writeFile(generatedPath)
  let
    master = readImage(masterPath)
    (score, xRay) = diff(image, master)
  xRay.writeFile(xrayPath)
  echo &"xray {masterPath} -> {score:0.6f}"



================================================
FILE: tools/gen_readme.nim
================================================
import os, osproc, strutils

proc cutBetween(str, a, b: string): string =
  let
    cutA = str.find(a)
    cutB = str.find(b)
  if cutA == -1 or cutB == -1:
    return ""
  return str[cutA + a.len..<cutB]

var md: seq[string]

var exampleFiles = [
  "examples/text.nim",
  "examples/text_spans.nim",
  "examples/square.nim",
  "examples/line.nim",
  "examples/rounded_rectangle.nim",
  "examples/heart.nim",
  "examples/masking.nim",
  "examples/gradient.nim",
  "examples/image_tiled.nim",
  "examples/shadow.nim",
  "examples/blur.nim",
  "examples/tiger.nim"
]

for path in exampleFiles:
  discard execCmd("nim c -r " & path)
  let code = readFile(path)
  let innerCode = code.cutBetween("image.fill(rgba(255, 255, 255, 255))", "image.writeFile")
  if innerCode != "":
    let path = path.replace("\\", "/")
    md.add "### " & path.splitFile().name.replace("_", " ").capitalizeAscii()
    md.add "nim c -r [" & path & "](" & path & ")"
    md.add "```nim"
    md.add innerCode.strip()
    md.add "```"
    md.add "![example output](" & path.replace(".nim", ".png").replace("\\",
        "/") & ")"
    md.add ""

var readme = readFile("README.md")

let at = readme.find("## Examples")
if at != -1:
  readme = readme[0 .. at]
readme.add("# Examples\n\n")
readme.add("`git clone https://github.com/treeform/pixie` to run examples.\n\n")
readme.add(md.join("\n"))

writeFile("README.md", readme)


