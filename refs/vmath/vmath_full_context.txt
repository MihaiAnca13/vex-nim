Directory structure:
└── treeform-vmath/
    ├── README.md
    ├── vmath.nimble
    ├── src/
    │   ├── vmath.nim
    │   └── vmath/
    │       └── macroswizzle.nim
    ├── tests/
    │   ├── bench.nim
    │   ├── bench_isNan.nim
    │   ├── bench_raytracer.nim
    │   ├── bench_raytracer_glm.nim
    │   ├── bench_rep.nim
    │   ├── bench_swizzle.nim
    │   ├── config.nims
    │   └── test.nim
    └── tools/
        └── genswizzle.nim

================================================
FILE: README.md
================================================
<img src="docs/banner.png">

# VMath - 2D and 3D vector math.

`nimble install vmath`

![Github Actions](https://github.com/treeform/vmath/workflows/Github%20Actions/badge.svg)

[API reference](https://treeform.github.io/vmath)

This library has no dependencies other than the Nim standard library.

Supports c, cpp and js backend.

## About

Your one stop shop for vector math routines for 2D and 3D graphics.

* Pure Nim with no dependencies.
* Very similar to GLSL Shader Language with extra stuff.
* Extensively [benchmarked](tests/bench_raytracer.nim).

## Has vector functions for GLSL types:

Type  | Constructor | Description
------|-------------| ---------------------------------------------------
BVec# | bvec#       | a vector of booleans
IVec# | ivec#       | a vector of signed integers
UVec# | uvec#       | a vector of unsigned integers
Vec#  | vec#        | a vector of single-precision floating-point numbers
DVec# | dvec#       | a vector of double-precision floating-point numbers

You can use these constructors to make them:

NIM     | GLSL   | 2     | 3     | 4     | 9     | 16    | 4     |
--------|--------|-------|-------|-------|-------|-------|-------|
bool    | bool   | BVec2 | BVec3 | BVec4 |       |       |       |
int32   | int    | IVec2 | IVec3 | IVec4 |       |       |       |
uint32  | uint   | UVec2 | UVec3 | UVec4 |       |       |       |
float32 | float  | Vec2  | Vec3  | Vec4  | Mat3  | Mat4  | Quat  |
float64 | double | DVec2 | DVec3 | DVec4 | DMat3 | DMat4 | DQuat |

## 2D & 3D matrix math

You can combine and create 2D and 3D matrices by passing 2D or 3D vectors to matrix functions:

```nim
let mat2d = translate(vec2(10, 20)) * rotate(45.toRadians) * scale(vec2(2))
let mat3d = translate(vec3(10, 20, 0)) * rotateZ(45.toRadians) * scale(vec3(2))
```

## Almost equal operator

Easily check if floating point numbers are close, very useful for tests:
```nim
1.0 ~= 1.0
vec2(1.0, 2.0) ~= vec2(1.0, 2.0)
dvec2(1) ~= dvec2(1)
quat(1.0, 2.0, 3.0, 4.0) ~= quat(1.0, 2.0, 3.0, 4.0)
```

## Number functions

* `between` - Returns true if value is between min and max or equal to them.
* `sign` - Returns the sign of a number, -1 or 1.
* `quantize` - Makes v be a multiple of n. Rounding to integer quantizes by 1.0.
* `lerp` - Interpolates value between a and b.

## Angle functions

* `fixAngle` - Makes angle be from -PI to PI radians.
* `angleBetween` - Finds the angle between angle a and angle b.
* `turnAngle` - Moves from angle a to angle b with step of v.

## Vector and matrix representation and benchmarks.

C compilers seem to optimize different representations differently. This is very surprising for us and vmath has 3 different implementations:

* `-d:vmathObjBased` - A vector is an object of 3 floats.
* `-d:vmathArrayBased` - A vector is an array of 3 floats.
* `-d:vmathObjArrayBased` (default) - A vector is an object that has an array of 3 floats.

```
name ............................... min time      avg time    std dv   runs
vmathObjBased ..................... 74.061 ms     74.297 ms    ±0.347   x100
vmathArrayBased ................... 89.498 ms     89.911 ms    ±1.019   x100
vmathObjArrayBased ................ 73.968 ms     74.292 ms    ±0.631   x100
```

* [3d Ray Trace Benchmark](tests/bench_raytracer.nim)
* [2d SVG Render Benchmark](https://github.com/treeform/pixie/blob/master/tests/bench_svg.nim)

## Zmod - GLSL mod

GLSL uses a different type of float point mod. Because mod is a Nim keyword, please use `zmod` when you need GLSL `mod` behavior.

## Coordinate System

Right-hand Z-forward coordinate system

This is the same system used in the GLTF file format.

> glTF uses a right-handed coordinate system.
> glTF defines +Y as up, +Z as forward, and -X as right;
> the front of a glTF asset faces +Z.

[glTF Spec 2.0](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#coordinate-system-and-units)

## OpenGL matrix column-major notation.

> [9.005](https://www.opengl.org/archives/resources/faq/technical/transformations.htm) For programming purposes, OpenGL matrices are 16-value arrays with base vectors laid out contiguously in memory. The translation components occupy the 13th, 14th, and 15th elements of the 16-element matrix, where indices are numbered from 1 to 16 as described in section 2.11.2 of the [OpenGL 2.1 Specification](https://registry.khronos.org/OpenGL/specs/gl/glspec21.pdf).
>
> Sadly, the use of column-major format in the spec and blue book has resulted in endless confusion in the OpenGL programming community. Column-major notation suggests that matrices are not laid out in memory as a programmer would expect.

OpenGL/GLSL/vmath vs Math/Specification notation:
```
        mat4([
          a, b, c, 0,              | a d g x |
          d, e, f, 0,              | b e h y |
          g, h, i, 0,              | c f i z |
          x, y, z, 1               | 0 0 0 1 |
        ])
```

# 1.x.x to 2.0.0 vmath breaking changes:
* New right-hand-Z-forward coordinate system and functions that care about
coordinate system were moved there.
* Deprecated `lookAt()`, please use `toAngles()`/`fromAngles()` instead.
* Deprecated `fractional()`, use `frac()` instead.

# 0.x.x to 1.0.0 vmath breaking changes:

* `vec3(v)` no longer works, please use `vec3(v.x, v.y, 0)` instead.
* `vec3(v, 0)` no longer works, please use `vec3(v.x, v.y, 0)` instead.
* `2 * v` no longer works due to more vec types, please use `v * 2` instead.
* `m[15]` no longer works because matrices are now m[x, y].
* Concept of 3x3 rotation 3D matrix was removed.
* `angleBetween` got renamed to `angle(a, b)`
* `scaleMat` got renamed to `scale(v)`
* `rotationMat3` got renamed to `rotate(x)`



================================================
FILE: vmath.nimble
================================================
version       = "2.0.1"
author        = "Andre von Houck"
description   = "Your single stop for vector math routines for 2d and 3d graphics."
license       = "MIT"

srcDir        = "src"

requires "nim >= 1.4.0"



================================================
FILE: src/vmath.nim
================================================
##[

Your one stop shop for vector math routines for 2d and 3d graphics.

* Pure Nim with no dependencies.
* Very similar to GLSL Shader Language with extra stuff.
* Extensively benchmarked.

====== =========== =================================================
Type   Constructor Description
====== =========== =================================================
BVec#  bvec#       vector of booleans
IVec#  ivec#       vector of signed integers
UVec#  uvec#       vector of unsigned integers
Vec#   vec#        vector of single-precision floating-point numbers
DVec#  dvec#       vector of double-precision floating-point numbers
====== =========== =================================================

You can use these constructors to make them:

======= ====== ===== ===== ===== ===== ===== =====
NIM     GLSL   2     3     4     9     16    4
======= ====== ===== ===== ===== ===== ===== =====
bool    bool   BVec2 BVec3 BVec4
int32   int    IVec2 IVec3 IVec4
uint32  uint   UVec2 UVec3 UVec4
float32 float  Vec2  Vec3  Vec4  Mat3  Mat4  Quat
float64 double DVec2 DVec3 DVec4 DMat3 DMat4 DQuat
======= ====== ===== ===== ===== ===== ===== =====

]##

import
  std/[macros, math, strutils]
export math except isNan

{.push inline.}
when defined(release):
  {.push noinit, checks: off.}

when defined(vmathArrayBased):
  type
    GVec2*[T] = array[2, T]
    GVec3*[T] = array[3, T]
    GVec4*[T] = array[4, T]
    GVec34[T] = GVec3[T] | GVec4[T]
    GVec234[T] = GVec2[T] | GVec3[T] | GVec4[T]

  template gvec2*[T](x, y: T): GVec2[T] = [T(x), T(y)]
  template gvec3*[T](x, y, z: T): GVec3[T] = [T(x), T(y), T(z)]
  template gvec4*[T](x, y, z, w: T): GVec4[T] = [T(x), T(y), T(z), T(w)]

  template x*[T](a: GVec2[T]): T = a[0]
  template x*[T](a: GVec3[T]): T = a[0]
  template x*[T](a: GVec4[T]): T = a[0]

  template y*[T](a: GVec2[T]): T = a[1]
  template y*[T](a: GVec3[T]): T = a[1]
  template y*[T](a: GVec4[T]): T = a[1]

  template z*[T](a: GVec2[T]): T = {.error: "using .z on a Vec2".}
  template z*[T](a: GVec3[T]): T = a[2]
  template z*[T](a: GVec4[T]): T = a[2]

  template w*[T](a: GVec2[T]): T = {.error: "using .w on a Vec2".}
  template w*[T](a: GVec3[T]): T = {.error: "using .w on a Vec3".}
  template w*[T](a: GVec4[T]): T = a[3]

  template x*[T](a: var GVec2[T]): var T = a[0]
  template x*[T](a: var GVec3[T]): var T = a[0]
  template x*[T](a: var GVec4[T]): var T = a[0]
  template y*[T](a: var GVec2[T]): var T = a[1]
  template y*[T](a: var GVec3[T]): var T = a[1]
  template y*[T](a: var GVec4[T]): var T = a[1]
  template z*[T](a: var GVec3[T]): var T = a[2]
  template z*[T](a: var GVec4[T]): var T = a[2]
  template w*[T](a: var GVec4[T]): var T = a[3]

  template `x=`*[T](a: var GVec234[T], value: T) = a[0] = value
  template `y=`*[T](a: var GVec234[T], value: T) = a[1] = value
  template `z=`*[T](a: var GVec34[T], value: T) = a[2] = value
  template `w=`*[T](a: var GVec4[T], value: T) = a[3] = value

  type
    GMat2*[T] {.bycopy.} = array[2, GVec2[T]]
    GMat3*[T] {.bycopy.} = array[3, GVec3[T]]
    GMat4*[T] {.bycopy.} = array[4, GVec4[T]]

    GMat234[T] = GMat2[T] | GMat3[T] | GMat4[T]

  proc gmat2*[T](
    m00, m01,
    m10, m11: T
  ): GMat2[T] =
    [
      [m00, m01],
      [m10, m11]
    ]

  proc gmat3*[T](
    m00, m01, m02,
    m10, m11, m12,
    m20, m21, m22: T
  ): GMat3[T] =
    [
      [m00, m01, m02],
      [m10, m11, m12],
      [m20, m21, m22]
    ]

  proc gmat4*[T](
    m00, m01, m02, m03,
    m10, m11, m12, m13,
    m20, m21, m22, m23,
    m30, m31, m32, m33: T
  ): GMat4[T] =
    [
      [m00, m01, m02, m03],
      [m10, m11, m12, m13],
      [m20, m21, m22, m23],
      [m30, m31, m32, m33]
    ]

  template `[]`*[T](a: GMat234[T], i, j: int): T = a[i][j]

  template `[]=`*[T](a: var GMat2[T], i, j: int, v: T) =
    cast[ptr T](cast[ByteAddress](a.addr) + (i * 2 + j) * sizeof(T))[] = v

  template `[]=`*[T](a: var GMat3[T], i, j: int, v: T) =
    cast[ptr T](cast[ByteAddress](a.addr) + (i * 3 + j) * sizeof(T))[] = v

  template `[]=`*[T](a: var GMat4[T], i, j: int, v: T) =
    cast[ptr T](cast[ByteAddress](a.addr) + (i * 4 + j) * sizeof(T))[] = v

elif defined(vmathObjBased):
  type
    GVec2*[T] = object
      x*, y*: T
    GVec3*[T] = object
      x*, y*, z*: T
    GVec4*[T] = object
      x*, y*, z*, w*: T
    GVec34[T] = GVec3[T] | GVec4[T]
    GVec234[T] = GVec2[T] | GVec3[T] | GVec4[T]

  template gvec2*[T](mx, my: T): GVec2[T] =
    GVec2[T](x: mx, y: my)

  template gvec3*[T](mx, my, mz: T): GVec3[T] =
    GVec3[T](x: mx, y: my, z: mz)

  template gvec4*[T](mx, my, mz, mw: T): GVec4[T] =
    GVec4[T](x: mx, y: my, z: mz, w: mw)

  template `[]`*[T](a: GVec2[T], i: int): T = cast[array[2, T]](a)[i]
  template `[]`*[T](a: GVec3[T], i: int): T = cast[array[3, T]](a)[i]
  template `[]`*[T](a: GVec4[T], i: int): T = cast[array[4, T]](a)[i]

  template `[]=`*[T](a: var GVec2[T], i: int, v: T) =
    cast[ptr T](cast[ByteAddress](a.addr) + i * sizeof(T))[] = v

  template `[]=`*[T](a: var GVec3[T], i: int, v: T) =
    cast[ptr T](cast[ByteAddress](a.addr) + i * sizeof(T))[] = v

  template `[]=`*[T](a: var GVec4[T], i: int, v: T) =
    cast[ptr T](cast[ByteAddress](a.addr) + i * sizeof(T))[] = v

  type
    GMat2*[T] {.bycopy.} = object
      m00*, m01*: T
      m10*, m11*: T
    GMat3*[T] {.bycopy.} = object
      m00*, m01*, m02*: T
      m10*, m11*, m12*: T
      m20*, m21*, m22*: T
    GMat4*[T] {.bycopy.} = object
      m00*, m01*, m02*, m03*: T
      m10*, m11*, m12*, m13*: T
      m20*, m21*, m22*, m23*: T
      m30*, m31*, m32*, m33*: T

  proc gmat2*[T](
    m00, m01,
    m10, m11: T
  ): GMat2[T] =
    result.m00 = m00; result.m01 = m01
    result.m10 = m10; result.m11 = m11

  proc gmat3*[T](
    m00, m01, m02,
    m10, m11, m12,
    m20, m21, m22: T
  ): GMat3[T] =
    result.m00 = m00; result.m01 = m01; result.m02 = m02
    result.m10 = m10; result.m11 = m11; result.m12 = m12
    result.m20 = m20; result.m21 = m21; result.m22 = m22

  proc gmat4*[T](
    m00, m01, m02, m03,
    m10, m11, m12, m13,
    m20, m21, m22, m23,
    m30, m31, m32, m33: T
  ): GMat4[T] =
    result.m00 = m00; result.m01 = m01; result.m02 = m02; result.m03 = m03
    result.m10 = m10; result.m11 = m11; result.m12 = m12; result.m13 = m13
    result.m20 = m20; result.m21 = m21; result.m22 = m22; result.m23 = m23
    result.m30 = m30; result.m31 = m31; result.m32 = m32; result.m33 = m33

  template `[]`*[T](a: GMat2[T], i, j: int): T =
    cast[array[4, T]](a)[i * 2 + j]

  template `[]`*[T](a: GMat3[T], i, j: int): T =
    cast[array[9, T]](a)[i * 3 + j]

  template `[]`*[T](a: GMat4[T], i, j: int): T =
    cast[array[16, T]](a)[i * 4 + j]

  template `[]=`*[T](a: var GMat2[T], i, j: int, v: T) =
    cast[ptr T](cast[ByteAddress](a.addr) + (i * 2 + j) * sizeof(T))[] = v

  template `[]=`*[T](a: var GMat3[T], i, j: int, v: T) =
    cast[ptr T](cast[ByteAddress](a.addr) + (i * 3 + j) * sizeof(T))[] = v

  template `[]=`*[T](a: var GMat4[T], i, j: int, v: T) =
    cast[ptr T](cast[ByteAddress](a.addr) + (i * 4 + j) * sizeof(T))[] = v

  template `[]`*[T](a: GMat2[T], i: int): GVec2[T] =
    gvec2[T](
      a[i, 0],
      a[i, 1]
    )

  template `[]`*[T](a: GMat3[T], i: int): GVec3[T] =
    gvec3[T](
      a[i, 0],
      a[i, 1],
      a[i, 2]
    )

  template `[]`*[T](a: GMat4[T], i: int): GVec4[T] =
    gvec4[T](
      a[i, 0],
      a[i, 1],
      a[i, 2],
      a[i, 3]
    )

elif true or defined(vmathObjArrayBased):
  type
    GVec2*[T] = object
      arr: array[2, T]
    GVec3*[T] = object
      arr: array[3, T]
    GVec4*[T] = object
      arr: array[4, T]
    GVec34[T] = GVec3[T] | GVec4[T]
    GVec234[T] = GVec2[T] | GVec3[T] | GVec4[T]

  template gvec2*[T](x, y: T): GVec2[T] =
    GVec2[T](arr: [T(x), T(y)])

  template gvec3*[T](x, y, z: T): GVec3[T] =
    GVec3[T](arr: [T(x), T(y), T(z)])

  template gvec4*[T](x, y, z, w: T): GVec4[T] =
    GVec4[T](arr: [T(x), T(y), T(z), T(w)])

  template x*[T](a: var GVec2[T]): var T = a.arr[0]
  template y*[T](a: var GVec2[T]): var T = a.arr[1]

  template x*[T](a: var GVec3[T]): var T = a.arr[0]
  template y*[T](a: var GVec3[T]): var T = a.arr[1]
  template z*[T](a: var GVec3[T]): var T = a.arr[2]

  template x*[T](a: var GVec4[T]): var T = a.arr[0]
  template y*[T](a: var GVec4[T]): var T = a.arr[1]
  template z*[T](a: var GVec4[T]): var T = a.arr[2]
  template w*[T](a: var GVec4[T]): var T = a.arr[3]

  template x*[T](a: GVec2[T]): T = a.arr[0]
  template x*[T](a: GVec3[T]): T = a.arr[0]
  template x*[T](a: GVec4[T]): T = a.arr[0]

  template y*[T](a: GVec2[T]): T = a.arr[1]
  template y*[T](a: GVec3[T]): T = a.arr[1]
  template y*[T](a: GVec4[T]): T = a.arr[1]

  template z*[T](a: GVec3[T]): T = a.arr[2]
  template z*[T](a: GVec4[T]): T = a.arr[2]
  template w*[T](a: GVec4[T]): T = a.arr[3]

  template `x=`*[T](a: var GVec234[T], value: T) = a.arr[0] = value
  template `y=`*[T](a: var GVec234[T], value: T) = a.arr[1] = value
  template `z=`*[T](a: var GVec34[T], value: T) = a.arr[2] = value
  template `w=`*[T](a: var GVec4[T], value: T) = a.arr[3] = value

  template `[]`*[T](a: GVec234[T], i: int): T = a.arr[i]
  template `[]=`*[T](a: var GVec234[T], i: int, v: T) = a.arr[i] = v

  type
    GMat2*[T] {.bycopy.} = object
      arr: array[4, T]
    GMat3*[T] {.bycopy.} = object
      arr: array[9, T]
    GMat4*[T] {.bycopy.} = object
      arr: array[16, T]

  proc gmat2*[T](
    m00, m01,
    m10, m11: T
  ): GMat2[T] =
    GMat2[T](arr: [
      m00, m01,
      m10, m11
    ])

  proc gmat3*[T](
    m00, m01, m02,
    m10, m11, m12,
    m20, m21, m22: T
  ): GMat3[T] =
    GMat3[T](arr: [
      m00, m01, m02,
      m10, m11, m12,
      m20, m21, m22
    ])

  proc gmat4*[T](
    m00, m01, m02, m03,
    m10, m11, m12, m13,
    m20, m21, m22, m23,
    m30, m31, m32, m33: T
  ): GMat4[T] =
    GMat4[T](arr: [
      m00, m01, m02, m03,
      m10, m11, m12, m13,
      m20, m21, m22, m23,
      m30, m31, m32, m33
    ])

  template `[]`*[T](a: GMat2[T], i, j: int): T = a.arr[i * 2 + j]
  template `[]`*[T](a: GMat3[T], i, j: int): T = a.arr[i * 3 + j]
  template `[]`*[T](a: GMat4[T], i, j: int): T = a.arr[i * 4 + j]

  template `[]=`*[T](a: var GMat2[T], i, j: int, v: T) = a.arr[i * 2 + j] = v
  template `[]=`*[T](a: var GMat3[T], i, j: int, v: T) = a.arr[i * 3 + j] = v
  template `[]=`*[T](a: var GMat4[T], i, j: int, v: T) = a.arr[i * 4 + j] = v

  template `[]`*[T](a: GMat2[T], i: int): GVec2[T] =
    gvec2[T](
      a[i, 0],
      a[i, 1]
    )

  template `[]`*[T](a: GMat3[T], i: int): GVec3[T] =
    gvec3[T](
      a[i, 0],
      a[i, 1],
      a[i, 2]
    )

  template `[]`*[T](a: GMat4[T], i: int): GVec4[T] =
    gvec4[T](
      a[i, 0],
      a[i, 1],
      a[i, 2],
      a[i, 3]
    )

type
  BVec2* = GVec2[bool]
  BVec3* = GVec3[bool]
  BVec4* = GVec4[bool]

  IVec2* = GVec2[int32]
  IVec3* = GVec3[int32]
  IVec4* = GVec4[int32]

  UVec2* = GVec2[uint32]
  UVec3* = GVec3[uint32]
  UVec4* = GVec4[uint32]

  Vec2* = GVec2[float32]
  Vec3* = GVec3[float32]
  Vec4* = GVec4[float32]

  DVec2* = GVec2[float64]
  DVec3* = GVec3[float64]
  DVec4* = GVec4[float64]

proc `~=`*[T: SomeFloat](a, b: T): bool =
  ## Almost equal.
  const Epsilon = 0.000001
  abs(a - b) <= Epsilon

proc between*[T](value, min, max: T): bool =
  ## Returns true if value is between min and max or equal to them.
  (value >= min) and (value <= max)

proc sign*[T](v: T): T =
  ## Returns the sign of a number, -1 or 1.
  if v >= 0: 1 else: -1

proc quantize*[T: SomeFloat](v, n: T): T =
  ## Makes v be multiple of n. Rounding to integer quantize by 1.0.
  trunc(v / n) * n

proc fract*[T: SomeFloat](v: T): T =
  ## Returns fractional part of a number.
  ## 3.14 -> 0.14
  ## -3.14 -> 0.14
  result = abs(v)
  result = result - trunc(result)

proc fractional*[T: SomeFloat](v: T): T {.deprecated: "Use fract() instead"} =
  ## Returns fractional part of a number.
  fract(v)

proc inversesqrt*[T: float32|float64](v: T): T =
  ## Returns inverse square root.
  1/sqrt(v)

proc mix*[T: SomeFloat](a, b, v: T): T =
  ## Interpolates value between a and b.
  ## * 0 -> a
  ## * 1 -> b
  ## * 0.5 -> between a and b
  v * (b - a) + a

proc fixAngle*[T: SomeFloat](angle: T): T =
  ## Normalize the angle to be from -PI to PI radians.
  result = angle
  while result > PI:
    result -= PI * 2
  while result <= -PI:
    result += PI * 2

proc angleBetween*[T: SomeFloat](a, b: T): T =
  ## Angle between angle a and angle b.
  ## All angles assume radians.
  fixAngle(b - a)

proc turnAngle*[T: SomeFloat](a, b, speed: T): T =
  ## Move from angle a to angle b with step of v.
  ## All angles assume radians.
  var
    turn = fixAngle(b - a)
  if abs(turn) < speed:
    return b
  elif turn > speed:
    turn = speed
  elif turn < -speed:
    turn = -speed
  a + turn

proc toRadians*[T: SomeFloat](deg: T): T =
  ## Convert degrees to radians.
  PI * deg / 180.0

proc toDegrees*[T: SomeFloat](rad: T): T =
  ## Convert radians to degrees.
  180.0 * rad / PI

proc toRadians*(deg: SomeInteger): float32 =
  ## Convert degrees to radians.
  deg.float32.toRadians

proc toDegrees*(deg: SomeInteger): float32 =
  ## Convert degrees to radians.
  deg.float32.toDegrees

proc isNan*(x: SomeFloat): bool =
  ## Returns true if number is a NaN.
  x != 0.0 and (x != x or x * 0.5 == x)

proc `zmod`*(a, b: float32): float32 =
  ## Float point mod.
  return a - b * floor(a/b)

template lowerType(a: typed): string =
  ($type(a)).toLowerAscii()

template genVecConstructor*(lower, upper, typ: untyped) =
  ## Generate vector constructor for your own type.

  proc `lower 2`*(): `upper 2` = gvec2[typ](typ(0), typ(0))
  proc `lower 3`*(): `upper 3` = gvec3[typ](typ(0), typ(0), typ(0))
  proc `lower 4`*(): `upper 4` = gvec4[typ](typ(0), typ(0), typ(0), typ(0))

  proc `lower 2`*(x, y: typ): `upper 2` = gvec2[typ](x, y)
  proc `lower 3`*(x, y, z: typ): `upper 3` = gvec3[typ](x, y, z)
  proc `lower 4`*(x, y, z, w: typ): `upper 4` = gvec4[typ](x, y, z, w)

  proc `lower 2`*(x: typ): `upper 2` = gvec2[typ](x, x)
  proc `lower 3`*(x: typ): `upper 3` = gvec3[typ](x, x, x)
  proc `lower 4`*(x: typ): `upper 4` = gvec4[typ](x, x, x, x)

  proc `lower 2`*[T](x: GVec2[T]): `upper 2` =
    gvec2[typ](typ(x[0]), typ(x[1]))
  proc `lower 3`*[T](x: GVec3[T]): `upper 3` =
    gvec3[typ](typ(x[0]), typ(x[1]), typ(x[2]))
  proc `lower 4`*[T](x: GVec4[T]): `upper 4` =
    gvec4[typ](typ(x[0]), typ(x[1]), typ(x[2]), typ(x[3]))

  proc `lower 3`*[T](x: GVec2[T], z: T = 0): `upper 3` =
    gvec3[typ](typ(x[0]), typ(x[1]), z)
  proc `lower 4`*[T](x: GVec3[T], w: T = 0): `upper 4` =
    gvec4[typ](typ(x[0]), typ(x[1]), typ(x[2]), w)

  proc `lower 4`*[T](a, b: GVec2[T]): `upper 4` =
    gvec4[typ](typ(a[0]), typ(a[1]), typ(b[0]), typ(b[1]))

  proc `$`*(a: `upper 2`): string =
    lowerType(a) & "(" & $a.x & ", " & $a.y & ")"
  proc `$`*(a: `upper 3`): string =
    lowerType(a) & "(" & $a.x & ", " & $a.y & ", " & $a.z & ")"
  proc `$`*(a: `upper 4`): string =
    lowerType(a) & "(" & $a.x & ", " & $a.y & ", " & $a.z & ", " & $a.w & ")"

genVecConstructor(bvec, BVec, bool)
genVecConstructor(ivec, IVec, int32)
genVecConstructor(uvec, UVec, uint32)
genVecConstructor(vec, Vec, float32)
genVecConstructor(dvec, DVec, float64)

proc vec2*(ivec2: Ivec2): Vec2 =
  vec2(ivec2.x.float32, ivec2.y.float32)

proc vec2*(uvec2: Uvec2): Vec2 =
  vec2(uvec2.x.float32, uvec2.y.float32)

proc ivec2*(uvec2: Uvec2): Ivec2 =
  ivec2(uvec2.x.int32, uvec2.y.int32)

proc uvec2*(ivec2: Ivec2): Uvec2 =
  uvec2(ivec2.x.uint32, ivec2.y.uint32)

proc vec3*(ivec3: Ivec3): Vec3 =
  vec3(ivec3.x.float32, ivec3.y.float32, ivec3.z.float32)

proc vec3*(uvec3: Uvec3): Vec3 =
  vec3(uvec3.x.float32, uvec3.y.float32, uvec3.z.float32)

proc ivec3*(uvec3: Uvec3): Ivec3 =
  ivec3(uvec3.x.int32, uvec3.y.int32, uvec3.z.int32)

proc uvec3*(ivec3: Ivec3): Uvec3 =
  uvec3(ivec3.x.uint32, ivec3.y.uint32, ivec3.z.uint32)

proc vec4*(ivec4: Ivec4): Vec4 =
  vec4(ivec4.x.float32, ivec4.y.float32, ivec4.z.float32, ivec4.w.float32)

proc vec4*(uvec4: Uvec4): Vec4 =
  vec4(uvec4.x.float32, uvec4.y.float32, uvec4.z.float32, uvec4.w.float32)

proc ivec4*(uvec4: Uvec4): Ivec4 =
  ivec4(uvec4.x.int32, uvec4.y.int32, uvec4.z.int32, uvec4.w.int32)

proc uvec4*(ivec4: Ivec4): Uvec4 =
  uvec4(ivec4.x.uint32, ivec4.y.uint32, ivec4.z.uint32, ivec4.w.uint32)

when not defined(nimdoc) or not isMainModule:
  # TODO when https://github.com/nim-lang/Nim/issues/13063 is fixed use macros.
  include vmath/swizzle

proc `==`*[T](a, b: GVec2[T]): bool =
  a.x == b.x and a.y == b.y

proc `==`*[T](a, b: GVec3[T]): bool =
  a.x == b.x and a.y == b.y and a.z == b.z

proc `==`*[T](a, b: GVec4[T]): bool =
  a.x == b.x and a.y == b.y and a.z == b.z and a.w == b.w

proc `!=`*[T](a, b: GVec2[T]): bool =
  a.x != b.x or a.y != b.y

proc `!=`*[T](a, b: GVec3[T]): bool =
  a.x != b.x or a.y != b.y or a.z != b.z

proc `!=`*[T](a, b: GVec4[T]): bool =
  a.x != b.x or a.y != b.y or a.z != b.z or a.w != b.w

template genOp(op: untyped) =
  proc op*[T](a, b: GVec2[T]): GVec2[T] =
    gvec2[T](
      op(a[0], b[0]),
      op(a[1], b[1])
    )

  proc op*[T](a, b: GVec3[T]): GVec3[T] =
    gvec3[T](
      op(a[0], b[0]),
      op(a[1], b[1]),
      op(a[2], b[2])
    )

  proc op*[T](a, b: GVec4[T]): GVec4[T] =
    gvec4[T](
      op(a[0], b[0]),
      op(a[1], b[1]),
      op(a[2], b[2]),
      op(a[3], b[3])
    )

  proc op*[T](a: GVec2[T], b: T): GVec2[T] =
    gvec2[T](
      op(a[0], b),
      op(a[1], b)
    )

  proc op*[T](a: GVec3[T], b: T): GVec3[T] =
    gvec3[T](
      op(a[0], b),
      op(a[1], b),
      op(a[2], b)
    )

  proc op*[T](a: GVec4[T], b: T): GVec4[T] =
    gvec4[T](
      op(a[0], b),
      op(a[1], b),
      op(a[2], b),
      op(a[3], b)
    )

  proc op*[T](a: T, b: GVec2[T]): GVec2[T] =
    gvec2[T](
      op(a, b[0]),
      op(a, b[1])
    )

  proc op*[T](a: T, b: GVec3[T]): GVec3[T] =
    gvec3[T](
      op(a, b[0]),
      op(a, b[1]),
      op(a, b[2])
    )

  proc op*[T](a: T, b: GVec4[T]): GVec4[T] =
    gvec4[T](
      op(a, b[0]),
      op(a, b[1]),
      op(a, b[2]),
      op(a, b[3])
    )

genOp(`+`)
genOp(`-`)
genOp(`*`)
genOp(`/`)
genOp(`mod`)
genOp(`div`)
genOp(`zmod`)

template genEqOp(op: untyped) =
  proc op*[T](a: var GVec2[T], b: GVec2[T]) =
    op(a.x, b.x)
    op(a.y, b.y)

  proc op*[T](a: var GVec3[T], b: GVec3[T]) =
    op(a.x, b.x)
    op(a.y, b.y)
    op(a.z, b.z)

  proc op*[T](a: var GVec4[T], b: GVec4[T]) =
    op(a.x, b.x)
    op(a.y, b.y)
    op(a.z, b.z)
    op(a.w, b.w)

  proc op*[T](a: var GVec2[T], b: T) =
    op(a.x, b)
    op(a.y, b)

  proc op*[T](a: var GVec3[T], b: T) =
    op(a.x, b)
    op(a.y, b)
    op(a.z, b)

  proc op*[T](a: var GVec4[T], b: T) =
    op(a.x, b)
    op(a.y, b)
    op(a.z, b)
    op(a.w, b)

genEqOp(`+=`)
genEqOp(`-=`)
genEqOp(`*=`)
genEqOp(`/=`)

template genMathFn(fn: untyped) =
  proc fn*[T](v: GVec2[T]): GVec2[T] =
    gvec2[T](
      fn(v[0]),
      fn(v[1])
    )

  proc fn*[T](v: GVec3[T]): GVec3[T] =
    gvec3[T](
      fn(v[0]),
      fn(v[1]),
      fn(v[2])
    )

  proc fn*[T](v: GVec4[T]): GVec4[T] =
    gvec4[T](
      fn(v[0]),
      fn(v[1]),
      fn(v[2]),
      fn(v[3])
    )

genMathFn(`-`)
genMathFn(sin)
genMathFn(cos)
genMathFn(tan)
genMathFn(arcsin)
genMathFn(arccos)
genMathFn(arctan)
genMathFn(sinh)
genMathFn(cosh)
genMathFn(tanh)
genMathFn(exp2)
genMathFn(inversesqrt)
genMathFn(exp)
genMathFn(ln)
genMathFn(log2)
genMathFn(sqrt)
genMathFn(floor)
genMathFn(ceil)
genMathFn(abs)
genMathFn(trunc)
genMathFn(fract)
genMathFn(quantize)
genMathFn(toRadians)
genMathFn(toDegrees)

template genBoolFn(fn, op: untyped) =
  proc fn*[T](a, b: GVec2[T]): BVec2 =
    result[0] = op(a[0], b[0])
    result[1] = op(a[1], b[1])

  proc fn*[T](a, b: GVec3[T]): BVec3 =
    result[0] = op(a[0], b[0])
    result[1] = op(a[1], b[1])
    result[2] = op(a[2], b[2])

  proc fn*[T](a, b: GVec4[T]): BVec4 =
    result[0] = op(a[0], b[0])
    result[1] = op(a[1], b[1])
    result[2] = op(a[2], b[2])
    result[3] = op(a[3], b[3])

genBoolFn(lessThan, `<`)
genBoolFn(lessThanEqual, `<=`)
genBoolFn(greaterThan, `>`)
genBoolFn(greaterThanEqual, `>=`)
genBoolFn(equal, `==`)
genBoolFn(notEqual, `!=`)

proc `~=`*[T](a, b: GVec2[T]): bool =
  ## Almost equal.
  a.x ~= b.x and a.y ~= b.y

proc `~=`*[T](a, b: GVec3[T]): bool =
  ## Almost equal.
  a.x ~= b.x and a.y ~= b.y and a.z ~= b.z

proc `~=`*[T](a, b: GVec4[T]): bool =
  ## Almost equal.
  a.x ~= b.x and a.y ~= b.y and a.z ~= b.z and a.w ~= b.w

proc length*[T](a: GVec2[T]): T =
  sqrt(a.x*a.x + a.y*a.y)

proc length*[T](a: GVec3[T]): T =
  sqrt(a.x*a.x + a.y*a.y + a.z*a.z)

proc length*[T](a: GVec4[T]): T =
  sqrt(a.x*a.x + a.y*a.y + a.z*a.z + a.w*a.w)

proc lengthSq*[T](a: GVec2[T]): T =
  a.x*a.x + a.y*a.y

proc lengthSq*[T](a: GVec3[T]): T =
  a.x*a.x + a.y*a.y + a.z*a.z

proc lengthSq*[T](a: GVec4[T]): T =
  a.x*a.x + a.y*a.y + a.z*a.z + a.w*a.w

proc normalize*[T](a: GVec234[T]): type(a) =
  a / a.length

proc mix*[T: SomeFloat](a, b: GVec234[T], v: T): type(a) =
  a * (1.0 - v) + b * v

proc lerp*[V, T](a, b: V, v: T): type(a) {.deprecated: "use mix instead".} =
  mix(a, b, v)

proc dot*[T](a, b: GVec2[T]): T =
  a.x * b.x + a.y * b.y

proc dot*[T](a, b: GVec3[T]): T =
  a.x * b.x + a.y * b.y + a.z * b.z

proc dot*[T](a, b: GVec4[T]): T =
  a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w

proc mix*[T: SomeFloat](a, b, v: GVec2[T]): type(a) =
  result.x = a.x * (1.0 - v.x) + b.x * v.x
  result.y = a.y * (1.0 - v.y) + b.y * v.y

proc mix*[T: SomeFloat](a, b, v: GVec3[T]): type(a) =
  result.x = a.x * (1.0 - v.x) + b.x * v.x
  result.y = a.y * (1.0 - v.y) + b.y * v.y
  result.z = a.z * (1.0 - v.z) + b.z * v.z

proc mix*[T: SomeFloat](a, b, v: GVec4[T]): type(a) =
  result.x = a.x * (1.0 - v.x) + b.x * v.x
  result.y = a.y * (1.0 - v.y) + b.y * v.y
  result.z = a.z * (1.0 - v.z) + b.z * v.z
  result.w = a.w * (1.0 - v.w) + b.w * v.w

proc cross*[T](a, b: GVec3[T]): GVec3[T] =
  gvec3(
    a.y * b.z - a.z * b.y,
    a.z * b.x - a.x * b.z,
    a.x * b.y - a.y * b.x
  )

proc dist*[T](at, to: GVec234[T]): T =
  (at - to).length

proc distSq*[T](at, to: GVec234[T]): T =
  (at - to).lengthSq

proc dir*[T](at, to: GVec234[T]): type(to) =
  (at - to).normalize

proc dir*[T](angle: T): GVec2[T] =
  gvec2(
    cos(angle),
    sin(angle),
  )

proc min*(a, b: Vec2): Vec2 =
  vec2(min(a.x, b.x), min(a.y, b.y))

proc min*(a, b: Vec3): Vec3 =
  vec3(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z))

proc min*(a, b: Vec4): Vec4 =
  vec4(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z), min(a.w, b.w))

proc min*(a: Vec2, b: float32): Vec2 =
  vec2(min(a.x, b), min(a.y, b))

proc min*(a: Vec3, b: float32): Vec3 =
  vec3(min(a.x, b), min(a.y, b), min(a.z, b))

proc min*(a: Vec4, b: float32): Vec4 =
  vec4(min(a.x, b), min(a.y, b), min(a.z, b), min(a.w, b))

proc max*(a, b: Vec2): Vec2 =
  vec2(max(a.x, b.x), max(a.y, b.y))

proc max*(a, b: Vec3): Vec3 =
  vec3(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z))

proc max*(a, b: Vec4): Vec4 =
  vec4(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z), max(a.w, b.w))

proc max*(a: Vec2, b: float32): Vec2 =
  vec2(max(a.x, b), max(a.y, b))

proc max*(a: Vec3, b: float32): Vec3 =
  vec3(max(a.x, b), max(a.y, b), max(a.z, b))

proc max*(a: Vec4, b: float32): Vec4 =
  vec4(max(a.x, b), max(a.y, b), max(a.z, b), max(a.w, b))

proc clamp*(v, min, max: Vec2): Vec2 =
  vec2(clamp(v.x, min.x, max.x), clamp(v.y, min.y, max.y))

proc clamp*(v, min, max: Vec3): Vec3 =
  vec3(clamp(v.x, min.x, max.x), clamp(v.y, min.y, max.y), clamp(v.z, min.z, max.z))

proc clamp*(v, min, max: Vec4): Vec4 =
  vec4(clamp(v.x, min.x, max.x), clamp(v.y, min.y, max.y), clamp(v.z, min.z, max.z), clamp(v.w, min.w, max.w))

proc clamp*(v: Vec2, min, max: float32): Vec2 =
  vec2(clamp(v.x, min, max), clamp(v.y, min, max))

proc clamp*(v: Vec3, min, max: float32): Vec3 =
  vec3(clamp(v.x, min, max), clamp(v.y, min, max), clamp(v.z, min, max))

proc clamp*(v: Vec4, min, max: float32): Vec4 =
  vec4(clamp(v.x, min, max), clamp(v.y, min, max), clamp(v.z, min, max), clamp(v.w, min, max))

type
  Mat2* = GMat2[float32]
  Mat3* = GMat3[float32]
  Mat4* = GMat4[float32]

  DMat2* = GMat2[float64]
  DMat3* = GMat3[float64]
  DMat4* = GMat4[float64]

proc matToString[T](a: T, n: int): string =
  result = ($type(a)).toLowerAscii()
  result.add "(\n"
  for x in 0 ..< n:
    result.add "  "
    for y in 0 ..< n:
      result.add $a[x, y] & ", "
    result.setLen(result.len - 1)
    result.add "\n"
  result.setLen(result.len - 2)
  result.add "\n)"

template genMatConstructor*(lower, upper, T: untyped) =
  ## Generate matrix constructor for your own type.
  proc `lower 2`*(
    m00, m01,
    m10, m11: T
  ): `upper 2` =
    result[0, 0] = m00; result[0, 1] = m01
    result[1, 0] = m10; result[1, 1] = m11

  proc `lower 3`*(
    m00, m01, m02,
    m10, m11, m12,
    m20, m21, m22: T
  ): `upper 3` =
    result[0, 0] = m00; result[0, 1] = m01; result[0, 2] = m02
    result[1, 0] = m10; result[1, 1] = m11; result[1, 2] = m12
    result[2, 0] = m20; result[2, 1] = m21; result[2, 2] = m22

  proc `lower 4`*(
    m00, m01, m02, m03,
    m10, m11, m12, m13,
    m20, m21, m22, m23,
    m30, m31, m32, m33: T
  ): `upper 4` =
    result[0, 0] = m00; result[0, 1] = m01
    result[0, 2] = m02; result[0, 3] = m03

    result[1, 0] = m10; result[1, 1] = m11
    result[1, 2] = m12; result[1, 3] = m13

    result[2, 0] = m20; result[2, 1] = m21
    result[2, 2] = m22; result[2, 3] = m23

    result[3, 0] = m30; result[3, 1] = m31
    result[3, 2] = m32; result[3, 3] = m33

  proc `lower 2`*(a, b: GVec2[T]): `upper 2` =
    gmat2[T](
      a.x, a.y,
      b.x, b.y
    )
  proc `lower 3`*(a, b, c: GVec3[T]): `upper 3` =
    gmat3[T](
      a.x, a.y, a.z,
      b.x, b.y, b.z,
      c.x, c.y, c.z,
    )
  proc `lower 4`*(a, b, c, d: GVec4[T]): `upper 4` =
    gmat4[T](
      a.x, a.y, a.z, a.w,
      b.x, b.y, b.z, b.w,
      c.x, c.y, c.z, c.w,
      d.x, d.y, d.z, d.w,
    )

  proc `lower 2`*(): `upper 2` =
    gmat2[T](
      1.T, 0.T,
      0.T, 1.T
    )
  proc `lower 3`*(): `upper 3` =
    gmat3[T](
      1.T, 0.T, 0.T,
      0.T, 1.T, 0.T,
      0.T, 0.T, 1.T
    )
  proc `lower 4`*(): `upper 4` =
    gmat4[T](
      1.T, 0.T, 0.T, 0.T,
      0.T, 1.T, 0.T, 0.T,
      0.T, 0.T, 1.T, 0.T,
      0.T, 0.T, 0.T, 1.T
    )

  proc `$`*(a: `upper 2`): string = matToString(a, 2)
  proc `$`*(a: `upper 3`): string = matToString(a, 3)
  proc `$`*(a: `upper 4`): string = matToString(a, 4)

genMatConstructor(mat, Mat, float32)
genMatConstructor(dmat, DMat, float64)

proc `~=`*[T](a, b: GMat2[T]): bool =
  a[0] ~= b[0] and a[1] ~= b[1]

proc `~=`*[T](a, b: GMat3[T]): bool =
  a[0] ~= b[0] and a[1] ~= b[1] and a[2] ~= b[2]

proc `~=`*[T](a, b: GMat4[T]): bool =
  a[0] ~= b[0] and a[1] ~= b[1] and a[2] ~= b[2] and a[3] ~= b[3]

proc pos*[T](a: GMat3[T]): GVec2[T] =
  gvec2[T](a[2].x, a[2].y)

proc `pos=`*[T](a: var GMat3[T], pos: GVec2[T]) =
  a[2, 0] = pos.x
  a[2, 1] = pos.y

proc forward*[T](a: GMat4[T]): GVec3[T] {.inline.} =
  ## Vector facing +Z.
  result.x = a[2, 0]
  result.y = a[2, 1]
  result.z = a[2, 2]

proc back*[T](a: GMat4[T]): GVec3[T] {.inline.} =
  ## Vector facing -Z.
  -a.forward()

proc left*[T](a: GMat4[T]): GVec3[T] {.inline.} =
  ## Vector facing +X.
  result.x = a[0, 0]
  result.y = a[0, 1]
  result.z = a[0, 2]

proc right*[T](a: GMat4[T]): GVec3[T] {.inline.} =
  ## Vector facing -X.
  -a.left()

proc up*[T](a: GMat4[T]): GVec3[T] {.inline.} =
  ## Vector facing +Y.
  result.x = a[1, 0]
  result.y = a[1, 1]
  result.z = a[1, 2]

proc down*[T](a: GMat4[T]): GVec3[T] {.inline.} =
  ## Vector facing -X.
  -a.up()

proc pos*[T](a: GMat4[T]): GVec3[T] =
  ## Position of the matrix.
  gvec3[T](a[3].x, a[3].y, a[3].z)

proc `pos=`*[T](a: var GMat4[T], pos: GVec3[T]) =
  ## See the position of the matrix.
  a[3, 0] = pos.x
  a[3, 1] = pos.y
  a[3, 2] = pos.z

proc `*`*[T](a, b: GMat3[T]): GMat3[T] =
  result[0, 0] = b[0, 0] * a[0, 0] + b[0, 1] * a[1, 0] + b[0, 2] * a[2, 0]
  result[0, 1] = b[0, 0] * a[0, 1] + b[0, 1] * a[1, 1] + b[0, 2] * a[2, 1]
  result[0, 2] = b[0, 0] * a[0, 2] + b[0, 1] * a[1, 2] + b[0, 2] * a[2, 2]

  result[1, 0] = b[1, 0] * a[0, 0] + b[1, 1] * a[1, 0] + b[1, 2] * a[2, 0]
  result[1, 1] = b[1, 0] * a[0, 1] + b[1, 1] * a[1, 1] + b[1, 2] * a[2, 1]
  result[1, 2] = b[1, 0] * a[0, 2] + b[1, 1] * a[1, 2] + b[1, 2] * a[2, 2]

  result[2, 0] = b[2, 0] * a[0, 0] + b[2, 1] * a[1, 0] + b[2, 2] * a[2, 0]
  result[2, 1] = b[2, 0] * a[0, 1] + b[2, 1] * a[1, 1] + b[2, 2] * a[2, 1]
  result[2, 2] = b[2, 0] * a[0, 2] + b[2, 1] * a[1, 2] + b[2, 2] * a[2, 2]

proc `*`*[T](a: GMat2[T], b: GVec2[T]): GVec2[T] =
  gvec2[T](
    a[0, 0] * b.x + a[1, 0] * b.y,
    a[0, 1] * b.x + a[1, 1] * b.y
  )

proc `*`*[T](a: GMat3[T], b: GVec2[T]): GVec2[T] =
  gvec2[T](
    a[0, 0] * b.x + a[1, 0] * b.y + a[2, 0],
    a[0, 1] * b.x + a[1, 1] * b.y + a[2, 1]
  )

proc `*`*[T](a: GMat3[T], b: GVec3[T]): GVec3[T] =
  gvec3[T](
    a[0, 0] * b.x + a[1, 0] * b.y + a[2, 0] * b.z,
    a[0, 1] * b.x + a[1, 1] * b.y + a[2, 1] * b.z,
    a[0, 2] * b.x + a[1, 2] * b.y + a[2, 2] * b.z,
  )

proc `*`*[T](a, b: GMat4[T]): GMat4[T] =
  let
    a00 = a[0, 0]
    a01 = a[0, 1]
    a02 = a[0, 2]
    a03 = a[0, 3]
    a10 = a[1, 0]
    a11 = a[1, 1]
    a12 = a[1, 2]
    a13 = a[1, 3]
    a20 = a[2, 0]
    a21 = a[2, 1]
    a22 = a[2, 2]
    a23 = a[2, 3]
    a30 = a[3, 0]
    a31 = a[3, 1]
    a32 = a[3, 2]
    a33 = a[3, 3]

  let
    b00 = b[0, 0]
    b01 = b[0, 1]
    b02 = b[0, 2]
    b03 = b[0, 3]
    b10 = b[1, 0]
    b11 = b[1, 1]
    b12 = b[1, 2]
    b13 = b[1, 3]
    b20 = b[2, 0]
    b21 = b[2, 1]
    b22 = b[2, 2]
    b23 = b[2, 3]
    b30 = b[3, 0]
    b31 = b[3, 1]
    b32 = b[3, 2]
    b33 = b[3, 3]

  result[0, 0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30
  result[0, 1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31
  result[0, 2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32
  result[0, 3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33

  result[1, 0] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30
  result[1, 1] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31
  result[1, 2] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32
  result[1, 3] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33

  result[2, 0] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30
  result[2, 1] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31
  result[2, 2] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32
  result[2, 3] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33

  result[3, 0] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30
  result[3, 1] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31
  result[3, 2] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32
  result[3, 3] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33

proc `*`*[T](a: GMat4[T], b: GVec3[T]): GVec3[T] =
  gvec3[T](
    a[0, 0] * b.x + a[1, 0] * b.y + a[2, 0] * b.z + a[3, 0],
    a[0, 1] * b.x + a[1, 1] * b.y + a[2, 1] * b.z + a[3, 1],
    a[0, 2] * b.x + a[1, 2] * b.y + a[2, 2] * b.z + a[3, 2]
  )

proc `*`*[T](a: GMat4[T], b: GVec4[T]): GVec4[T] =
  gvec4[T](
    a[0, 0] * b.x + a[1, 0] * b.y + a[2, 0] * b.z + a[3, 0] * b.w,
    a[0, 1] * b.x + a[1, 1] * b.y + a[2, 1] * b.z + a[3, 1] * b.w,
    a[0, 2] * b.x + a[1, 2] * b.y + a[2, 2] * b.z + a[3, 2] * b.w,
    a[0, 3] * b.x + a[1, 3] * b.y + a[2, 3] * b.z + a[3, 3] * b.w
  )

proc transpose*[T](a: GMat3[T]): GMat3[T] =
  ## Return an transpose of the matrix.
  gmat3[T](
    a[0, 0], a[1, 0], a[2, 0],
    a[0, 1], a[1, 1], a[2, 1],
    a[0, 2], a[1, 2], a[2, 2]
  )

proc transpose*[T](a: GMat4[T]): GMat4[T] =
  ## Return an transpose of the matrix.
  gmat4[T](
    a[0, 0], a[1, 0], a[2, 0], a[3, 0],
    a[0, 1], a[1, 1], a[2, 1], a[3, 1],
    a[0, 2], a[1, 2], a[2, 2], a[3, 2],
    a[0, 3], a[1, 3], a[2, 3], a[3, 3]
  )

proc determinant*[T](a: GMat3[T]): T =
  ## Compute a determinant of the matrix.
  (
    a[0, 0] * (a[1, 1] * a[2, 2] - a[2, 1] * a[1, 2]) -
    a[0, 1] * (a[1, 0] * a[2, 2] - a[1, 2] * a[2, 0]) +
    a[0, 2] * (a[1, 0] * a[2, 1] - a[1, 1] * a[2, 0])
  )

proc determinant*[T](a: GMat4[T]): T =
  ## Compute a determinant of the matrix.
  let
    a00 = a[0, 0]
    a01 = a[0, 1]
    a02 = a[0, 2]
    a03 = a[0, 3]
    a10 = a[1, 0]
    a11 = a[1, 1]
    a12 = a[1, 2]
    a13 = a[1, 3]
    a20 = a[2, 0]
    a21 = a[2, 1]
    a22 = a[2, 2]
    a23 = a[2, 3]
    a30 = a[3, 0]
    a31 = a[3, 1]
    a32 = a[3, 2]
    a33 = a[3, 3]
  (
    a30*a21*a12*a03 - a20*a31*a12*a03 - a30*a11*a22*a03 + a10*a31*a22*a03 +
    a20*a11*a32*a03 - a10*a21*a32*a03 - a30*a21*a02*a13 + a20*a31*a02*a13 +
    a30*a01*a22*a13 - a00*a31*a22*a13 - a20*a01*a32*a13 + a00*a21*a32*a13 +
    a30*a11*a02*a23 - a10*a31*a02*a23 - a30*a01*a12*a23 + a00*a31*a12*a23 +
    a10*a01*a32*a23 - a00*a11*a32*a23 - a20*a11*a02*a33 + a10*a21*a02*a33 +
    a20*a01*a12*a33 - a00*a21*a12*a33 - a10*a01*a22*a33 + a00*a11*a22*a33
  )

proc inverse*[T](a: GMat3[T]): GMat3[T] =
  ## Return an inverse of the matrix.
  let
    invDet = 1 / a.determinant

  result[0, 0] = +(a[1, 1] * a[2, 2] - a[2, 1] * a[1, 2]) * invDet
  result[0, 1] = -(a[0, 1] * a[2, 2] - a[0, 2] * a[2, 1]) * invDet
  result[0, 2] = +(a[0, 1] * a[1, 2] - a[0, 2] * a[1, 1]) * invDet

  result[1, 0] = -(a[1, 0] * a[2, 2] - a[1, 2] * a[2, 0]) * invDet
  result[1, 1] = +(a[0, 0] * a[2, 2] - a[0, 2] * a[2, 0]) * invDet
  result[1, 2] = -(a[0, 0] * a[1, 2] - a[1, 0] * a[0, 2]) * invDet

  result[2, 0] = +(a[1, 0] * a[2, 1] - a[2, 0] * a[1, 1]) * invDet
  result[2, 1] = -(a[0, 0] * a[2, 1] - a[2, 0] * a[0, 1]) * invDet
  result[2, 2] = +(a[0, 0] * a[1, 1] - a[1, 0] * a[0, 1]) * invDet

proc inverse*[T](a: GMat4[T]): GMat4[T] =
  ## Return an inverse of the matrix.
  let
    a00 = a[0, 0]
    a01 = a[0, 1]
    a02 = a[0, 2]
    a03 = a[0, 3]
    a10 = a[1, 0]
    a11 = a[1, 1]
    a12 = a[1, 2]
    a13 = a[1, 3]
    a20 = a[2, 0]
    a21 = a[2, 1]
    a22 = a[2, 2]
    a23 = a[2, 3]
    a30 = a[3, 0]
    a31 = a[3, 1]
    a32 = a[3, 2]
    a33 = a[3, 3]

  let
    b00 = a00 * a11 - a01 * a10
    b01 = a00 * a12 - a02 * a10
    b02 = a00 * a13 - a03 * a10
    b03 = a01 * a12 - a02 * a11
    b04 = a01 * a13 - a03 * a11
    b05 = a02 * a13 - a03 * a12
    b06 = a20 * a31 - a21 * a30
    b07 = a20 * a32 - a22 * a30
    b08 = a20 * a33 - a23 * a30
    b09 = a21 * a32 - a22 * a31
    b10 = a21 * a33 - a23 * a31
    b11 = a22 * a33 - a23 * a32

  # Calculate the inverse determinant.
  let invDet = 1 / a.determinant

  result[0, 0] = (+a11 * b11 - a12 * b10 + a13 * b09) * invDet
  result[0, 1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet
  result[0, 2] = (+a31 * b05 - a32 * b04 + a33 * b03) * invDet
  result[0, 3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet

  result[1, 0] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet
  result[1, 1] = (+a00 * b11 - a02 * b08 + a03 * b07) * invDet
  result[1, 2] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet
  result[1, 3] = (+a20 * b05 - a22 * b02 + a23 * b01) * invDet

  result[2, 0] = (+a10 * b10 - a11 * b08 + a13 * b06) * invDet
  result[2, 1] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet
  result[2, 2] = (+a30 * b04 - a31 * b02 + a33 * b00) * invDet
  result[2, 3] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet

  result[3, 0] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet
  result[3, 1] = (+a00 * b09 - a01 * b07 + a02 * b06) * invDet
  result[3, 2] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet
  result[3, 3] = (+a20 * b03 - a21 * b01 + a22 * b00) * invDet

proc scale*[T](v: GVec2[T]): GMat3[T] =
  ## Create scale matrix.
  gmat3[T](
    v.x, 0, 0,
    0, v.y, 0,
    0, 0, 1
  )

proc scale*[T](v: GVec3[T]): GMat4[T] =
  ## Create scale matrix.
  gmat4[T](
    v.x, 0, 0, 0,
    0, v.y, 0, 0,
    0, 0, v.z, 0,
    0, 0, 0, 1
  )

proc translate*[T](v: GVec2[T]): GMat3[T] =
  ## Create translation matrix.
  gmat3[T](
    1, 0, 0,
    0, 1, 0,
    v.x, v.y, 1
  )

proc translate*[T](v: GVec3[T]): GMat4[T] =
  ## Create translation matrix.
  gmat4[T](
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    v.x, v.y, v.z, 1
  )

proc rotate*[T](angle: T): GMat3[T] =
  ## Create a 2D rotation matrix by an angle.
  ## All angles assume radians.
  let
    sin = sin(angle)
    cos = cos(angle)
  gmat3[T](
    cos, -sin, 0,
    sin, cos, 0,
    0, 0, 1
  )

proc rotationOnly*[T](a: GMat4[T]): GMat4[T] {.inline.} =
  ## Clears the positional component and returns rotation only.
  ## Assumes matrix has not been scaled.
  result = a
  result.pos = gvec3(0, 0, 0)

proc rotateX*[T](angle: T): GMat4[T] =
  ## Return a rotation matrix around X with angle.
  ## All angles assume radians.
  result[0, 0] = 1
  result[0, 1] = 0
  result[0, 2] = 0
  result[0, 3] = 0

  result[1, 0] = 0
  result[1, 1] = cos(angle)
  result[1, 2] = -sin(angle)
  result[1, 3] = 0

  result[2, 0] = 0
  result[2, 1] = sin(angle)
  result[2, 2] = cos(angle)
  result[2, 3] = 0

  result[3, 0] = 0
  result[3, 1] = 0
  result[3, 2] = 0
  result[3, 3] = 1

proc rotateY*[T](angle: T): GMat4[T] =
  ## Return a rotation matrix around Y with angle.
  ## All angles assume radians.
  result[0, 0] = cos(angle)
  result[0, 1] = 0
  result[0, 2] = sin(angle)
  result[0, 3] = 0

  result[1, 0] = 0
  result[1, 1] = 1
  result[1, 2] = 0
  result[1, 3] = 0

  result[2, 0] = -sin(angle)
  result[2, 1] = 0
  result[2, 2] = cos(angle)
  result[2, 3] = 0

  result[3, 0] = 0
  result[3, 1] = 0
  result[3, 2] = 0
  result[3, 3] = 1

proc rotateZ*[T](angle: T): GMat4[T] =
  ## Return a rotation matrix around Z with angle.
  ## All angles assume radians.
  result[0, 0] = cos(angle)
  result[0, 1] = -sin(angle)
  result[0, 2] = 0
  result[0, 3] = 0

  result[1, 0] = sin(angle)
  result[1, 1] = cos(angle)
  result[1, 2] = 0
  result[1, 3] = 0

  result[2, 0] = 0
  result[2, 1] = 0
  result[2, 2] = 1
  result[2, 3] = 0

  result[3, 0] = 0
  result[3, 1] = 0
  result[3, 2] = 0
  result[3, 3] = 1

proc toAngles*[T](a: GVec3[T]): GVec3[T] =
  ## Given a 3d vector, computes Euler angles: pitch and yaw
  ##   pitch (x rotation)
  ##   yaw (y rotation)
  ##   roll (z rotation) - always 0 in vector case
  ## All angles assume radians.
  if a == gvec3[T](T(0), T(0), T(0)):
    return
  let
    yaw = -arctan2(a.x, a.z)
    pitch = -arctan2(sqrt(a.x*a.x + a.z*a.z), a.y) + T(PI/2)
  result.x = pitch.fixAngle
  result.y = yaw.fixAngle

proc toAngles*[T](origin, target: GVec3[T]): GVec3[T] =
  ## Gives Euler angles from origin to target
  ##   pitch (x rotation)
  ##   yaw (y rotation)
  ##   roll (z rotation) - always 0 in vector case
  ## All angles assume radians.
  toAngles(target - origin)

proc toAngles*[T](m: GMat4[T]): GVec3[T] =
  ## Decomposes the matrix into Euler angles:
  ##   pitch (x rotation)
  ##   yaw (y rotation)
  ##   roll (z rotation)
  ## Assumes matrix has not been scaled.
  ## All angles assume radians.
  result.x = arcsin(m[2,1])
  if result.x > PI/2:
    # Degenerate case over north pole.
    result.y = arctan2(m[0, 2], m[0, 0])
  elif result.x < -PI/2:
    # Degenerate case over south pole.
    result.y = arctan2(m[0, 2], m[0, 0])
  else:
    # Normal case.
    result.y = -arctan2(m[2, 0], m[2, 2])
    result.z = -arctan2(m[0, 1], m[1, 1])

proc fromAngles*[T](a: GVec3[T]): GMat4[T] =
  ## Takes a vector containing Euler angles and returns a matrix.
  ## All angles assume radians.
  rotateY(a.y) * rotateX(a.x) * rotateZ(a.z)

proc frustum*[T](left, right, bottom, top, near, far: T): GMat4[T] =
  ## Create a frustum matrix.
  let
    rl = (right - left)
    tb = (top - bottom)
    fn = (far - near)

  result[0, 0] = (near * 2) / rl
  result[0, 1] = 0
  result[0, 2] = 0
  result[0, 3] = 0

  result[1, 0] = 0
  result[1, 1] = (near * 2) / tb
  result[1, 2] = 0
  result[1, 3] = 0

  result[2, 0] = (right + left) / rl
  result[2, 1] = (top + bottom) / tb
  result[2, 2] = -(far + near) / fn
  result[2, 3] = -1

  result[3, 0] = 0
  result[3, 1] = 0
  result[3, 2] = -(far * near * 2) / fn
  result[3, 3] = 0

proc perspective*[T](fovy, aspect, near, far: T): GMat4[T] =
  ## Create a perspective matrix.
  let
    top: T = near * tan(fovy * PI.float32 / 360.0)
    right: T = top * aspect
  frustum(-right, right, -top, top, near, far)

proc ortho*[T](left, right, bottom, top, near, far: T): GMat4[T] =
  ## Create an orthographic matrix.
  let
    rl: T = (right - left)
    tb: T = (top - bottom)
    fn: T = (far - near)

  result[0, 0] = T(2 / rl)
  result[0, 1] = 0
  result[0, 2] = 0
  result[0, 3] = 0

  result[1, 0] = 0
  result[1, 1] = T(2 / tb)
  result[1, 2] = 0
  result[1, 3] = 0

  result[2, 0] = 0
  result[2, 1] = 0
  result[2, 2] = T(-2 / fn)
  result[2, 3] = 0

  result[3, 0] = T(-(left + right) / rl)
  result[3, 1] = T(-(top + bottom) / tb)
  result[3, 2] = T(-(far + near) / fn)
  result[3, 3] = 1

proc lookAt*[T](eye, center, up: GVec3[T]): GMat4[T]
  {.deprecated: "Wrong coordinate system. " &
    "Use toAngles(eye, center).fromAngles() instead to get " &
    "right-handed-z-forward coordinate system".} =
  ## Create a matrix that would convert eye pos to looking at center.
  let
    eyex = eye[0]
    eyey = eye[1]
    eyez = eye[2]
    upx = up[0]
    upy = up[1]
    upz = up[2]
    centerx = center[0]
    centery = center[1]
    centerz = center[2]

  if eyex == centerx and eyey == centery and eyez == centerz:
    return

  var
    # vec3.direction(eye, center, z)
    z0 = eyex - center[0]
    z1 = eyey - center[1]
    z2 = eyez - center[2]

  # normalize (no check needed for 0 because of early return)
  var len = 1 / sqrt(z0 * z0 + z1 * z1 + z2 * z2)
  z0 *= len
  z1 *= len
  z2 *= len

  var
    # vec3.normalize(vec3.cross(up, z, x))
    x0 = upy * z2 - upz * z1
    x1 = upz * z0 - upx * z2
    x2 = upx * z1 - upy * z0
  len = sqrt(x0 * x0 + x1 * x1 + x2 * x2)
  if len == 0:
    x0 = 0
    x1 = 0
    x2 = 0
  else:
    len = 1 / len
    x0 *= len
    x1 *= len
    x2 *= len

  var
    # vec3.normalize(vec3.cross(z, x, y))
    y0 = z1 * x2 - z2 * x1
    y1 = z2 * x0 - z0 * x2
    y2 = z0 * x1 - z1 * x0

  len = sqrt(y0 * y0 + y1 * y1 + y2 * y2)
  if len == 0:
    y0 = 0
    y1 = 0
    y2 = 0
  else:
    len = 1/len
    y0 *= len
    y1 *= len
    y2 *= len

  result[0, 0] = x0
  result[0, 1] = y0
  result[0, 2] = z0
  result[0, 3] = 0

  result[1, 0] = x1
  result[1, 1] = y1
  result[1, 2] = z1
  result[1, 3] = 0

  result[2, 0] = x2
  result[2, 1] = y2
  result[2, 2] = z2
  result[2, 3] = 0

  result[3, 0] = -(x0 * eyex + x1 * eyey + x2 * eyez)
  result[3, 1] = -(y0 * eyex + y1 * eyey + y2 * eyez)
  result[3, 2] = -(z0 * eyex + z1 * eyey + z2 * eyez)
  result[3, 3] = 1

proc lookAt*[T](eye, center: GVec3[T]): GMat4[T]
  {.deprecated: "Wrong coordinate system. " &
    "Use toAngles(eye, center).fromAngles() instead to get " &
    "right-handed-z-forward coordinate system".} =
  ## Look center from eye with default UP vector.
  lookAt(eye, center, gvec3(T(0), 0, 1))

proc angle*[T](a: GVec2[T]): T =
  ## Angle of a Vec2.
  arctan2(a.y, a.x)

proc angle*[T; S: GVec2[T]|GVec3[T]](a, b: S): T =
  ## Angle between 2 Vec2 or Vec3.
  var dot = dot(a, b)
  dot = dot / (a.length * b.length)
  # The cases of angle((1, 1), (-1, -1)) and its 3d counterpart
  # angle((1, 1, 1), (-1, -1, -1)) result in NaN due to a domain defect going
  # into the arcos proc: abs(x) > 1.0.
  # Therefore, we must `clamp` here.
  arccos(dot.clamp(-1.0, 1.0))

type
  Quat* = GVec4[float32]
  DQuat* = GVec4[float64]

template genQuatConstructor*(lower, upper, typ: untyped) =
  ## Generate quaternion constructor for your own type.
  proc `lower`*(): `upper` = gvec4[typ](0, 0, 0, 1)
  proc `lower`*(x, y, z, w: typ): `upper` = gvec4[typ](x, y, z, w)
  proc `lower`*(x: typ): `upper` = gvec4[typ](x, x, x, x)
  proc `lower`*[T](x: GVec4[T]): `upper` =
    gvec4[typ](typ(x[0]), typ(x[1]), typ(x[2]), typ(x[3]))

genQuatConstructor(quat, Quat, float32)
genQuatConstructor(dquat, DQuat, float64)

proc fromAxisAngle*[T](axis: GVec3[T], angle: T): GVec4[T] =
  ## Create a quaternion from axis and angle.
  let
    a = axis.normalize()
    s = sin(angle / 2)
  gvec4[T](
    a.x * s,
    a.y * s,
    a.z * s,
    cos(angle / 2)
  )

proc toAxisAngle*[T](q: GVec4[T]): (GVec3[T], T) =
  ## Convert a quaternion to axis and angle.
  let cosAngle = q.w
  let angle = arccos(cosAngle) * 2.0
  var
    sinAngle = sqrt(1.0 - cosAngle * cosAngle)
    axis: GVec4[T]

  if abs(sinAngle) < 0.0005:
    sinAngle = 1.0

  axis.x = [
    q.x / sinAngle,
    q.y / sinAngle,
    q.z / sinAngle
  ]
  return (axis, angle)

proc orthogonal*[T](v: GVec3[T]): GVec3[T] =
  ## Returns orthogonal vector to given vector.
  let
    v = abs(v)
    other: type(v) =
      if v.x < v.y:
        if v.x < v.z:
          gvec3(T(1), 0, 0) # X_AXIS
        else:
          gvec3(T(0), 0, 1) # Z_AXIS
      elif v.y < v.z:
        gvec3(T(0), 1, 0)   # Y_AXIS
      else:
        gvec3(T(0), 0, 1)   # Z_AXIS
  return cross(v, other)

proc fromTwoVectors*[T](a, b: GVec3[T]): GVec4[T] =
  ## Return a quat that would take a and rotate it into b.

  # It is important that the inputs are of equal length when
  # calculating the half-way vector.
  let
    u = b.normalize()
    v = a.normalize()

  # Unfortunately, we have to check for when u == -v, as u + v
  # in this case will be (0, 0, 0), which cannot be normalized.
  if (u == -v):
    # 180 degree rotation around any orthogonal vector
    let q = normalize(orthogonal(u))
    return gvec4(q.x, q.y, q.z, 0)

  let
    half = normalize(u + v)
    q = cross(u, half)
    w = dot(u, half)
  return gvec4(q.x, q.y, q.z, w)

proc nlerp*(a: Quat, b: Quat, v: float32): Quat =
  if dot(a, b) < 0:
    (-a * (1.0 - v) + b * v).normalize()
  else:
    (a * (1.0 - v) + b * v).normalize()

proc quat*[T](m: GMat4[T]): GVec4[T] =
  ## Create a quaternion from matrix.
  let
    m00 = m[0, 0]
    m01 = m[1, 0]
    m02 = m[2, 0]

    m10 = m[0, 1]
    m11 = m[1, 1]
    m12 = m[2, 1]

    m20 = m[0, 2]
    m21 = m[1, 2]
    m22 = m[2, 2]

  var
    q: GVec4[T]
    t: T

  if m22 < 0:
    if m00 > m11:
      t = 1 + m00 - m11 - m22
      q = gvec4(t, m01 + m10, m20 + m02, m12 - m21)
    else:
      t = 1 - m00 + m11 - m22
      q = gvec4(m01 + m10, t, m12 + m21, m20 - m02)
  else:
    if m00 < - m11:
      t = 1 - m00 - m11 + m22
      q = gvec4(m20 + m02, m12 + m21, t, m01 - m10)
    else:
      t = 1 + m00 + m11 + m22
      q = gvec4(m12 - m21, m20 - m02, m01 - m10, t)
  q = q * (0.5 / sqrt(t))

  if abs(q.length - 1.0) > 0.001:
    return gvec4(T(0), 0, 0, 1)

  return q

proc mat4*[T](q: GVec4[T]): GMat4[T] =
  let
    xx = q.x * q.x
    xy = q.x * q.y
    xz = q.x * q.z
    xw = q.x * q.w

    yy = q.y * q.y
    yz = q.y * q.z
    yw = q.y * q.w

    zz = q.z * q.z
    zw = q.z * q.w

  result[0, 0] = 1 - 2 * (yy + zz)
  result[1, 0] = 0 + 2 * (xy - zw)
  result[2, 0] = 0 + 2 * (xz + yw)
  result[3, 0] = 0

  result[0, 1] = 0 + 2 * (xy + zw)
  result[1, 1] = 1 - 2 * (xx + zz)
  result[2, 1] = 0 + 2 * (yz - xw)
  result[3, 1] = 0
  
  result[0, 2] = 0 + 2 * (xz - yw)
  result[1, 2] = 0 + 2 * (yz + xw)
  result[2, 2] = 1 - 2 * (xx + yy)
  result[3, 2] = 0

  result[0, 3] = 0
  result[1, 3] = 0
  result[2, 3] = 0
  result[3, 3] = 1.0


proc mat4*(m: DMat4): Mat4 {.inline.} =
  ## Convert a double precision matrix to a single precision matrix.
  result[0, 0] = float32(m[0, 0])
  result[0, 1] = float32(m[0, 1])
  result[0, 2] = float32(m[0, 2])
  result[0, 3] = float32(m[0, 3])
  result[1, 0] = float32(m[1, 0])
  result[1, 1] = float32(m[1, 1])
  result[1, 2] = float32(m[1, 2])
  result[1, 3] = float32(m[1, 3])
  result[2, 0] = float32(m[2, 0])
  result[2, 1] = float32(m[2, 1])
  result[2, 2] = float32(m[2, 2])
  result[2, 3] = float32(m[2, 3])
  result[3, 0] = float32(m[3, 0])
  result[3, 1] = float32(m[3, 1])
  result[3, 2] = float32(m[3, 2])
  result[3, 3] = float32(m[3, 3])

proc mat4*(m: Mat4): Mat4 {.inline.} =
  ## Convert a double precision matrix to a single precision matrix.
  return m

proc dmat4*(m: Mat4): DMat4 {.inline.} =
  ## Convert a single precision matrix to a double precision matrix.
  result[0, 0] = float64(m[0, 0])
  result[0, 1] = float64(m[0, 1])
  result[0, 2] = float64(m[0, 2])
  result[0, 3] = float64(m[0, 3])
  result[1, 0] = float64(m[1, 0])
  result[1, 1] = float64(m[1, 1])
  result[1, 2] = float64(m[1, 2])
  result[1, 3] = float64(m[1, 3])
  result[2, 0] = float64(m[2, 0])
  result[2, 1] = float64(m[2, 1])
  result[2, 2] = float64(m[2, 2])
  result[2, 3] = float64(m[2, 3])
  result[3, 0] = float64(m[3, 0])
  result[3, 1] = float64(m[3, 1])
  result[3, 2] = float64(m[3, 2])
  result[3, 3] = float64(m[3, 3])

proc dmat4*(m: DMat4): DMat4 {.inline.} =
  ## Convert a double precision matrix to a double precision matrix.
  return m

proc rotate*[T](angle: T, axis: GVec3[T]): GMat4[T] =
  ## Return a rotation matrix with axis and angle.
  fromAxisAngle(axis, angle).mat4()

proc quatRotateX*[T](angle: T): GVec4[T] =
  ## Return a quaternion that would rotate around the X axis.
  fromAxisAngle(gvec3[T](1, 0, 0), angle)

proc quatRotateY*[T](angle: T): GVec4[T] =
  ## Return a quaternion that would rotate around the Y axis.
  fromAxisAngle(gvec3[T](0, 1, 0), angle)

proc quatRotateZ*[T](angle: T): GVec4[T] =
  ## Return a quaternion that would rotate around the Z axis.
  fromAxisAngle(gvec3[T](0, 0, 1), angle)

proc quatMultiply*[T](a: GVec4[T], b: GVec4[T]): GVec4[T] =
  ## Return the product of two quaternions.
  gvec4[T](
    a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y,
    a.w * b.y + a.y * b.w + a.z * b.x - a.x * b.z,
    a.w * b.z + a.z * b.w + a.x * b.y - a.y * b.x,
    a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z
  )

proc toAngles*[T](m: GVec4[T]): GVec3[T] =
  ## Convert a quaternion to Euler angles.
  let
    x = m.x
    y = m.y
    z = m.z
    w = m.w

  result.x = arctan2(2 * (w * x + y * z), 1 - 2 * (x * x + y * y))
  result.y = arcsin(2 * (w * y - z * x))
  result.z = arctan2(2 * (w * z + x * y), 1 - 2 * (y * y + z * z))

when defined(release):
  {.pop.}
{.pop.}



================================================
FILE: src/vmath/macroswizzle.nim
================================================

import 
  std/[macros]

{.experimental: "dotOperators".}
proc num(letter: char, fields: NimNode): int =
  ## Given a swizzle character gives back the location number.
  case letter:
  of 'x', 'r', 's': 0
  of 'y', 'g', 't': 1
  of 'z', 'b', 'p': 2
  of 'w', 'a', 'q': 3
  else:
    error "invalid swizzle character: " & letter, fields
    quit()

proc typePrefix(node: NimNode): string =
  ## Given a node of type GVec234 gives its prefix type.
  ## IVec2 -> "i", DVec4 -> "d", Vec3 -> ""
  let typeName =
    when defined(vmathArrayBased):
      node.getType()[2].repr
    elif defined(vmathObjBased):
      node.getType()[2][0].getType().repr
    elif true or defined(vmathObjArrayBased):
      node.getType()[2][0].getType()[2].repr
  case typeName:
  of "bool": "b"
  of "int32": "i"
  of "uint32": "u"
  of "float32": ""
  of "float", "float64": "d"
  else:
    error "invalid vector type: " & typeName, node
    quit()

macro `.`*(v: GVec234, fields: untyped): untyped =
  ## Adds support for swizzle getter.
  ##  x y z w
  ##  r g b a
  ##  s t p q
  ## v.xyz, v.xxx, v.zyx ...
  ## v.rgb, v.rrr, v.bgr ...
  ## v.stp, v.sss, v.pts ...
  let swizzle = fields.repr
  let vec = ident(typePrefix(v) & "vec" & $swizzle.len)
  if swizzle.len == 1:
    let a = num(swizzle[0], fields)
    result = quote do:
      `v`[`a`]
  elif swizzle.len == 2:
    let
      a = num(swizzle[0], fields)
      b = num(swizzle[1], fields)
    result = quote do:
      `vec`(`v`[`a`], `v`[`b`])
  elif swizzle.len == 3:
    let
      a = num(swizzle[0], fields)
      b = num(swizzle[1], fields)
      c = num(swizzle[2], fields)
    result = quote do:
      `vec`(`v`[`a`], `v`[`b`], `v`[`c`])
  elif swizzle.len == 4:
    let
      a = num(swizzle[0], fields)
      b = num(swizzle[1], fields)
      c = num(swizzle[2], fields)
      d = num(swizzle[3], fields)
    result = quote do:
      `vec`(`v`[`a`], `v`[`b`], `v`[`c`], `v`[`d`])
  else:
    error "invalid number of swizzle characters: " & swizzle, fields

macro `.=`*(v: GVec234, fields: untyped, e: untyped): untyped =
  ## Adds support for swizzle setter.
  ##  x y z w
  ##  r g b a
  ##  s t p q
  ## v.xyz, v.xxx, v.zyx ...
  ## v.rgb, v.rrr, v.bgr ...
  ## v.stp, v.sss, v.pts ...
  let swizzle = fields.repr
  if swizzle.len == 1:
    let a = num(swizzle[0], fields)
    result = quote do:
      `v`[`a`] = `e`
  elif swizzle.len == 2:
    let
      a = num(swizzle[0], fields)
      b = num(swizzle[1], fields)
    result = quote do:
      block:
        let tmp = `e`
        `v`[`a`] = tmp[0]
        `v`[`b`] = tmp[1]
  elif swizzle.len == 3:
    let
      a = num(swizzle[0], fields)
      b = num(swizzle[1], fields)
      c = num(swizzle[2], fields)
    result = quote do:
      block:
        let tmp = `e`
        `v`[`a`] = tmp[0]
        `v`[`b`] = tmp[1]
        `v`[`c`] = tmp[2]
  elif swizzle.len == 4:
    let
      a = num(swizzle[0], fields)
      b = num(swizzle[1], fields)
      c = num(swizzle[2], fields)
      d = num(swizzle[3], fields)
    result = quote do:
      block:
        let tmp = `e`
        `v`[`a`] = tmp[0]
        `v`[`b`] = tmp[1]
        `v`[`c`] = tmp[2]
        `v`[`d`] = tmp[3]
  else:
    error "invalid number of swizzle characters: " & swizzle, fields



================================================
FILE: tests/bench.nim
================================================
import 
  benchy,
  vmath

# TODO: I don't trust these simple benchmarks, make a better test.
# echo "new vmath"
# var v = vec3(1, 2, 3)
# timeIt "+":
#   for i in 0 ..< 1_000_000:
#     v += vec3(4, 5, 6)

# timeIt "-":
#   for i in 0 ..< 1_000_000:
#     v -= vec3(4, 5, 6)

# timeIt "*":
#   for i in 0 ..< 1_000_000:
#     v *= PI

# timeIt "/":
#   for i in 0 ..< 1_000_000:
#     v /= PI

# timeIt "int +":
#   var v = ivec3(1, 2, 3)
#   for i in 0 ..< 1_000_000:
#     keep v + ivec3(4, 5, 6)

# timeIt "int -":
#   var v = ivec3(1, 2, 3)
#   for i in 0 ..< 1_000_000:
#     keep v - ivec3(4, 5, 6)

timeIt "matrix mat4":
  var m = mat4()
  for i in 0 ..< 10_000:
    m = m *
      rotate(0.2.float32, vec3(1, 0, 0)) *
      scale(vec3(0.3)) *
      translate(vec3(1))
  keep m

timeIt "matrix mat3":
  var m = mat3()
  for i in 0 ..< 10_000:
    m = m * rotate(0.2.float32) * scale(vec2(0.3)) * translate(vec2(1))
  keep m

timeIt "matrix quat":
  var m = rotate(0.2.float32, vec3(1, 0, 0)) * scale(vec3(0.3)) * translate(vec3(1))
  for i in 0 ..< 100_000:
    keep m.quat().mat4()



================================================
FILE: tests/bench_isNan.nim
================================================
import 
  benchy,
  vmath

proc isNaNSlow(f: SomeFloat): bool =
  ## Returns true if number is a NaN.
  f.classify notin {fcNormal, fcZero, fcSubnormal}

proc isNaNRyan(x: SomeFloat): bool =
  if x == 0.0:
    return false
  x != x or x * 0.5 == x

proc isNaN3*(x: SomeFloat): bool =
  ## Returns true if number is a NaN.
  x != 0.0 and (x != x or x * 0.5 == x)

assert isNaNSlow(0.3) == false
assert isNaNSlow(0.0) == false
assert isNaNSlow(0.3/0.0) == true
assert isNaNSlow(-0.3/0.0) == true
assert isNaNSlow(5.0e-324) == false

assert isNaNRyan(0.3) == false
assert isNaNRyan(0.0) == false
assert isNaNRyan(0.3/0.0) == true
assert isNaNRyan(-0.3/0.0) == true
assert isNaNRyan(5.0e-324) == false

assert isNan(float32(0.3)) == false
assert isNan(float32(0.0)) == false
assert isNan(float32(0.3/0.0)) == true
assert isNan(float32(-0.3/0.0)) == true
assert isNan(float32(5.0e-324)) == false

assert isNan(float64(0.3)) == false
assert isNan(float64(0.0)) == false
assert isNan(float64(0.3/0.0)) == true
assert isNan(float64(-0.3/0.0)) == true
assert isNan(float64(5.0e-324)) == false

assert isNan3(float32(0.3)) == false
assert isNan3(float32(0.0)) == false
assert isNan3(float32(0.3/0.0)) == true
assert isNan3(float32(-0.3/0.0)) == true
assert isNan3(float32(5.0e-324)) == false

assert isNan3(float64(0.3)) == false
assert isNan3(float64(0.0)) == false
assert isNan3(float64(0.3/0.0)) == true
assert isNan3(float64(-0.3/0.0)) == true
assert isNan3(float64(5.0e-324)) == false

const num = 1_00_000

timeIt "isNaNSlow float32":
  var x: float32
  var n = 0
  for i in 0 .. num:
    if x.isNaNSlow:
      n += 1
    x = float32(i) / float32(i)
  keep n

timeIt "isNaNSlow float64":
  var x: float64
  var n = 0
  for i in 0 .. num:
    if x.isNaNSlow:
      n += 1
    x = float64(i) / float64(i)
  keep n

timeIt "isNaNRyan float32":
  var x: float32
  var n = 0
  for i in 0 .. num:
    if x.isNaNRyan:
      n += 1
    x = float32(i) / float32(i)
  keep n

timeIt "isNaNRyan float64":
  var x: float64
  var n = 0
  for i in 0 .. num:
    if x.isNaNRyan:
      n += 1
    x = float64(i) / float64(i)
  keep n

timeIt "isNan float32":
  var x: float32
  var n = 0
  for i in 0 .. num:
    if x.isNan:
      n += 1
    x = float32(i) / float32(i)
  keep n

timeIt "isNan float64":
  var x: float64
  var n = 0
  for i in 0 .. num:
    if x.isNan:
      n += 1
    x = float64(i) / float64(i)
  keep n

timeIt "isNan3 float32":
  var x: float32
  var n = 0
  for i in 0 .. num:
    if x.isNan3:
      n += 1
    x = float32(i) / float32(i)
  keep n

timeIt "isNan3 float64":
  var x: float64
  var n = 0
  for i in 0 .. num:
    if x.isNan3:
      n += 1
    x = float64(i) / float64(i)
  keep n



================================================
FILE: tests/bench_raytracer.nim
================================================
## Based on the work of https://github.com/edin/raytracer
## MIT License
## Copyright (c) 2021 Edin Omeragic

import 
  std/math,
  benchy, chroma, pixie, vmath

{.push inline, noinit, checks: off.}

type
  SurfaceType = enum
    ShinySurface, CheckerBoardSurface

  ObjectType = enum
    Sphere, Plane

  Camera = object
    forward, right, up, pos: Vec3

  Ray = object
    start, dir: Vec3

  Thing = ref object
    surfaceType: SurfaceType
    case objectType: ObjectType
    of Sphere:
      center: Vec3
      radius2: float32
    of Plane:
      normal: Vec3
      offset: float32

  Intersection = object
    thing: Thing
    ray: Ray
    dist: float32

  Light = object
    pos: Vec3
    color: Color

  Scene = ref object
    maxDepth: int
    things: seq[Thing]
    lights: seq[Light]
    camera: Camera

  SurfaceProperties = object
    diffuse, specular: Color
    reflect, roughness: float32

const
  farAway: float32 = 1000000.0
  white = color(1.0, 1.0, 1.0)
  grey = color(0.5, 0.5, 0.5)
  black = color(0.0, 0.0, 0.0)
  background = color(0.0, 0.0, 0.0)
  defaultColor = color(0.0, 0.0, 0.0)

proc `*`(c: Color, k: float32): Color = color(k * c.r, k * c.g, k * c.b)
proc `*`(a: Color, b: Color): Color = color(a.r * b.r, a.g * b.g, a.b * b.b)
proc `+`(a: Color, b: Color): Color = color(a.r + b.r, a.g + b.g, a.b + b.b)

proc newCamera(pos: Vec3, lookAt: Vec3): Camera =
  var
    down = vec3(0.0, -1.0, 0.0)
    forward = lookAt - pos
  result.pos = pos
  result.forward = forward.normalize()
  result.right = result.forward.cross(down)
  result.up = result.forward.cross(result.right)
  let
    rightNorm = result.right.normalize()
    upNorm = result.up.normalize()
  result.right = rightNorm * 1.5
  result.up = upNorm * 1.5

proc getNormal(obj: Thing, pos: Vec3): Vec3 =
  case obj.objectType:
    of Sphere:
      return (pos - obj.center).normalize()
    of Plane:
      return obj.normal

proc objectIntersect(obj: Thing, ray: Ray): Intersection =
  case obj.objectType:
    of Sphere:
      let
        eo = obj.center - ray.start
        v = eo.dot(ray.dir)
      if v >= 0:
        var dist = 0.0
        let disc = obj.radius2 - (eo.dot(eo) - (v * v))
        if disc >= 0:
          dist = v - sqrt(disc)
        if dist != 0.0:
          result.thing = obj
          result.ray = ray
          result.dist = dist
    of Plane:
      let denom = obj.normal.dot(ray.dir)
      if denom <= 0:
        result.dist = (obj.normal.dot(ray.start) + obj.offset) / (-denom)
        result.thing = obj
        result.ray = ray

proc newSphere(center: Vec3, radius: float32, surfaceType: SurfaceType): Thing =
  Thing(surfaceType: surfaceType, objectType: Sphere, center: center,
    radius2: radius * radius)

proc newPlane(normal: Vec3, offset: float32, surfaceType: SurfaceType): Thing =
  Thing(surfaceType: surfaceType, objectType: Plane, normal: normal,
    offset: offset)

proc getSurfaceProperties(obj: Thing, pos: Vec3): SurfaceProperties =
  case obj.surfaceType:
    of ShinySurface:
      result.diffuse = white
      result.specular = grey
      result.reflect = 0.7
      result.roughness = 250.0
    of CheckerBoardSurface:
      let val = int(floor(pos.z) + floor(pos.x))
      if val mod 2 != 0:
        result.reflect = 0.1
        result.diffuse = white
      else:
        result.reflect = 0.7
        result.diffuse = black
      result.specular = white
      result.roughness = 150.0

proc newScene(): Scene =
  result = Scene()
  result.maxDepth = 5
  result.things = @[
    newPlane(vec3(0.0, 1.0, 0.0), 0.0, CheckerBoardSurface),
    newSphere(vec3(0.0, 1.0, -0.25), 1.0, ShinySurface),
    newSphere(vec3(-1.0, 0.5, 1.5), 0.5, ShinySurface)
  ]
  result.lights = @[
    Light(pos: vec3(-2.0, 2.5, 0.0), color: color(0.49, 0.07, 0.07)),
    Light(pos: vec3(1.5, 2.5, 1.5), color: color(0.07, 0.07, 0.49)),
    Light(pos: vec3(1.5, 2.5, -1.5), color: color(0.07, 0.49, 0.071)),
    Light(pos: vec3(0.0, 3.5, 0.0), color: color(0.21, 0.21, 0.35))
  ]
  result.camera = newCamera(vec3(3.0, 2.0, 4.0), vec3(-1.0, 0.5, 0.0))

proc intersections(scene: Scene, ray: Ray): Intersection =
  var closest: float32 = farAway
  result.thing = nil
  for thing in scene.things:
    let intersect = objectIntersect(thing, ray)
    if (not isNil(intersect.thing)) and (intersect.dist < closest):
      result = intersect
      closest = intersect.dist

proc testRay(scene: Scene, ray: Ray): float32 =
  let intersection = scene.intersections(ray)
  if not isNil(intersection.thing):
    return intersection.dist
  return NaN

proc shade(scene: Scene, intersection: Intersection, depth: int): Color

proc traceRay(scene: Scene, ray: Ray, depth: int): Color =
  let intersection = intersections(scene, ray)
  if not isNil(intersection.thing):
    return scene.shade(intersection, depth)
  return background

proc getReflectionColor(
  scene: Scene, thing: Thing, pos: Vec3, normal: Vec3, reflectDir: Vec3,
  depth: int
): Color =
  var
    ray: Ray = Ray(start: pos, dir: reflectDir)
    color = scene.traceRay(ray, depth + 1)
    properties = getSurfaceProperties(thing, pos)
  return color * properties.reflect

proc getNaturalColor(scene: Scene, thing: Thing, pos, norm,
  reflectDir: Vec3
): Color =
  result = black
  var
    reflectDirNorm = reflectDir.normalize()
    sp = getSurfaceProperties(thing, pos)
  for light in scene.lights:
    let
      lightDist = light.pos - pos
      lightVec = lightDist.normalize()
      lightDistLen = lightDist.length()
      ray = Ray(start: pos, dir: lightVec)
      neatIntersection = scene.testRay(ray)
      isInShadow = neatIntersection.classify != fcNan and
        neatIntersection <= lightDistLen

    if not isInShadow:
      let
        illumination = lightVec.dot(norm)
        specular = lightVec.dot(reflectDirNorm)
      var
        lightColor =
          if illumination > 0: light.color * illumination
          else: defaultColor
        specularColor =
          if specular > 0: light.color * pow(specular, sp.roughness)
          else: defaultColor
      lightColor = lightColor * sp.diffuse
      specularColor = specularColor * sp.specular
      result = result + lightColor + specularColor

proc shade(scene: Scene, intersection: Intersection, depth: int): Color =
  var
    dir = intersection.ray.dir
    scaled = dir * intersection.dist
    pos = scaled + intersection.ray.start
    normal = intersection.thing.getNormal(pos)
    reflectDir = dir - (normal * normal.dot(dir) * 2)
    naturalColor = background + getNaturalColor(scene, intersection.thing,
      pos, normal, reflectDir)
    reflectedColor: Color
  if depth >= scene.maxDepth:
    reflectedColor = grey
  else:
    reflectedColor = getReflectionColor(scene, intersection.thing, pos, normal,
      reflectDir, depth)
  return naturalColor + reflectedColor

proc getPoint(x, y: int, camera: Camera, screenWidth, screenHeight: int): Vec3 =
  var
    sw = float32(screenWidth)
    sh = float32(screenHeight)
    xf = float32(x)
    yf = float32(y)
    recenterX = (xf - (sw / 2.0)) / 2.0 / sw
    recenterY = -(yf - (sh / 2.0)) / 2.0 / sh
    vx = camera.right * recenterX
    vy = camera.up * recenterY
    v = vx + vy
    z = camera.forward + v
  return z.normalize()

proc renderScene(scene: Scene, sceneImage: Image) =
  var ray: Ray
  let
    h = sceneImage.height
    w = sceneImage.width
  ray.start = scene.camera.pos
  for y in 0 ..< h:
    var pos = y * w
    for x in 0 ..< w:
      ray.dir = getPoint(x, y, scene.camera, h, w)
      sceneImage.unsafe[x, y] = scene.traceRay(ray, 0).asRgbx()
      pos = pos + 1

proc render(): Image =
  var
    scene = newScene()
  result = newImage(500, 500)
  renderScene(scene, result)

render().writeFile("tests/raytracer.png")

timeIt "raytracer", 100:
  discard render()



================================================
FILE: tests/bench_raytracer_glm.nim
================================================
## Based on the work of https://github.com/edin/raytracer
## MIT License
## Copyright (c) 2021 Edin Omeragic

import 
  std/math,
  benchy, chroma, glm
from pixie import Image, newImage, writeFile, dataIndex

type Vec3 = glm.Vec3[float32]

{.push inline, noinit, checks: off.}

type
  SurfaceType = enum
    ShinySurface, CheckerBoardSurface

  ObjectType = enum
    Sphere, Plane

  Camera = object
    forward, right, up, pos: Vec3

  Ray = object
    start, dir: Vec3

  Thing = ref object
    surfaceType: SurfaceType
    case objectType: ObjectType
    of Sphere:
      center: Vec3
      radius2: float32
    of Plane:
      normal: Vec3
      offset: float32

  Intersection = object
    thing: Thing
    ray: Ray
    dist: float32

  Light = object
    pos: Vec3
    color: Color

  Scene = ref object
    maxDepth: int
    things: seq[Thing]
    lights: seq[Light]
    camera: Camera

  SurfaceProperties = object
    diffuse, specular: Color
    reflect, roughness: float32

const
  farAway: float32 = 1000000.0
  white = color(1.0, 1.0, 1.0)
  grey = color(0.5, 0.5, 0.5)
  black = color(0.0, 0.0, 0.0)
  background = color(0.0, 0.0, 0.0)
  defaultColor = color(0.0, 0.0, 0.0)

proc `*`(c: Color, k: float32): Color = color(k * c.r, k * c.g, k * c.b)
proc `*`(a: Color, b: Color): Color = color(a.r * b.r, a.g * b.g, a.b * b.b)
proc `+`(a: Color, b: Color): Color = color(a.r + b.r, a.g + b.g, a.b + b.b)

proc newCamera(pos: Vec3, lookAt: Vec3): Camera =
  var
    down = vec3(0.0f, -1.0f, 0.0f)
    forward = lookAt - pos
  result.pos = pos
  result.forward = forward.normalize()
  result.right = result.forward.cross(down)
  result.up = result.forward.cross(result.right)
  let
    rightNorm = result.right.normalize()
    upNorm = result.up.normalize()
  result.right = rightNorm * 1.5
  result.up = upNorm * 1.5

proc getNormal(obj: Thing, pos: Vec3): Vec3 =
  case obj.objectType:
    of Sphere:
      return (pos - obj.center).normalize()
    of Plane:
      return obj.normal

proc objectIntersect(obj: Thing, ray: Ray): Intersection =
  case obj.objectType:
    of Sphere:
      let
        eo = obj.center - ray.start
        v = eo.dot(ray.dir)
      if v >= 0:
        var dist = 0.0
        let disc = obj.radius2 - (eo.dot(eo) - (v * v))
        if disc >= 0:
          dist = v - sqrt(disc)
        if dist != 0.0:
          result.thing = obj
          result.ray = ray
          result.dist = dist
    of Plane:
      let denom = obj.normal.dot(ray.dir)
      if denom <= 0:
        result.dist = (obj.normal.dot(ray.start) + obj.offset) / (-denom)
        result.thing = obj
        result.ray = ray

proc newSphere(center: Vec3, radius: float32, surfaceType: SurfaceType): Thing =
  Thing(surfaceType: surfaceType, objectType: Sphere, center: center,
    radius2: radius * radius)

proc newPlane(normal: Vec3, offset: float32, surfaceType: SurfaceType): Thing =
  Thing(surfaceType: surfaceType, objectType: Plane, normal: normal,
    offset: offset)

proc getSurfaceProperties(obj: Thing, pos: Vec3): SurfaceProperties =
  case obj.surfaceType:
    of ShinySurface:
      result.diffuse = white
      result.specular = grey
      result.reflect = 0.7
      result.roughness = 250.0
    of CheckerBoardSurface:
      let val = int(floor(pos.z) + floor(pos.x))
      if val mod 2 != 0:
        result.reflect = 0.1
        result.diffuse = white
      else:
        result.reflect = 0.7
        result.diffuse = black
      result.specular = white
      result.roughness = 150.0

proc newScene(): Scene =
  result = Scene()
  result.maxDepth = 5
  result.things = @[
    newPlane(vec3(0.0f, 1.0f, 0.0f), 0.0, CheckerBoardSurface),
    newSphere(vec3(0.0f, 1.0f, -0.25f), 1.0, ShinySurface),
    newSphere(vec3(-1.0f, 0.5f, 1.5f), 0.5, ShinySurface)
  ]
  result.lights = @[
    Light(pos: vec3(-2.0f, 2.5f, 0.0f), color: color(0.49, 0.07, 0.07)),
    Light(pos: vec3(1.5f, 2.5f, 1.5f), color: color(0.07, 0.07, 0.49)),
    Light(pos: vec3(1.5f, 2.5f, -1.5f), color: color(0.07, 0.49, 0.071)),
    Light(pos: vec3(0.0f, 3.5f, 0.0f), color: color(0.21, 0.21, 0.35))
  ]
  result.camera = newCamera(vec3(3.0f, 2.0f, 4.0f), vec3(-1.0f, 0.5f, 0.0f))

proc intersections(scene: Scene, ray: Ray): Intersection =
  var closest: float32 = farAway
  result.thing = nil
  for thing in scene.things:
    let intersect = objectIntersect(thing, ray)
    if (not isNil(intersect.thing)) and (intersect.dist < closest):
      result = intersect
      closest = intersect.dist

proc testRay(scene: Scene, ray: Ray): float32 =
  let intersection = scene.intersections(ray)
  if not isNil(intersection.thing):
    return intersection.dist
  return NaN

proc shade(scene: Scene, intersection: Intersection, depth: int): Color

proc traceRay(scene: Scene, ray: Ray, depth: int): Color =
  let intersection = intersections(scene, ray)
  if not isNil(intersection.thing):
    return scene.shade(intersection, depth)
  return background

proc getReflectionColor(
  scene: Scene, thing: Thing, pos: Vec3, normal: Vec3, reflectDir: Vec3,
  depth: int
): Color =
  var
    ray: Ray = Ray(start: pos, dir: reflectDir)
    color = scene.traceRay(ray, depth + 1)
    properties = getSurfaceProperties(thing, pos)
  return color * properties.reflect

proc getNaturalColor(scene: Scene, thing: Thing, pos, norm,
  reflectDir: Vec3
): Color =
  result = black
  var
    reflectDirNorm = reflectDir.normalize()
    sp = getSurfaceProperties(thing, pos)
  for light in scene.lights:
    let
      lightDist = light.pos - pos
      lightVec = lightDist.normalize()
      lightDistLen = lightDist.length()
      ray = Ray(start: pos, dir: lightVec)
      neatIntersection = scene.testRay(ray)
      isInShadow = neatIntersection.classify != fcNan and
        neatIntersection <= lightDistLen

    if not isInShadow:
      let
        illumination = lightVec.dot(norm)
        specular = lightVec.dot(reflectDirNorm)
      var
        lightColor =
          if illumination > 0: light.color * illumination
          else: defaultColor
        specularColor =
          if specular > 0: light.color * pow(specular, sp.roughness)
          else: defaultColor
      lightColor = lightColor * sp.diffuse
      specularColor = specularColor * sp.specular
      result = result + lightColor + specularColor

proc shade(scene: Scene, intersection: Intersection, depth: int): Color =
  var
    dir = intersection.ray.dir
    scaled = dir * intersection.dist
    pos = scaled + intersection.ray.start
    normal = intersection.thing.getNormal(pos)
    reflectDir = dir - (normal * normal.dot(dir) * 2)
    naturalColor = background + getNaturalColor(scene, intersection.thing,
      pos, normal, reflectDir)
    reflectedColor: Color
  if depth >= scene.maxDepth:
    reflectedColor = grey
  else:
    reflectedColor = getReflectionColor(scene, intersection.thing, pos, normal,
      reflectDir, depth)
  return naturalColor + reflectedColor

proc getPoint(x, y: int, camera: Camera, screenWidth, screenHeight: int): Vec3 =
  var
    sw = float32(screenWidth)
    sh = float32(screenHeight)
    xf = float32(x)
    yf = float32(y)
    recenterX = (xf - (sw / 2.0)) / 2.0 / sw
    recenterY = -(yf - (sh / 2.0)) / 2.0 / sh
    vx = camera.right * recenterX
    vy = camera.up * recenterY
    v = vx + vy
    z = camera.forward + v
  return z.normalize()

proc renderScene(scene: Scene, sceneImage: Image) =
  var ray: Ray
  let
    h = sceneImage.height
    w = sceneImage.width
  ray.start = scene.camera.pos
  for y in 0 ..< h:
    var pos = y * w
    for x in 0 ..< w:
      ray.dir = getPoint(x, y, scene.camera, h, w)
      sceneImage.data[sceneImage.dataIndex(x, y)] = scene.traceRay(ray, 0).asRgbx()
      pos = pos + 1

proc render(): Image =
  var
    scene = newScene()
  result = newImage(500, 500)
  renderScene(scene, result)

render().writeFile("tests/raytracer.png")

timeIt "raytracer", 100:
  discard render()



================================================
FILE: tests/bench_rep.nim
================================================
import 
  benchy

type
  Vec3Obj = object
    x, y, z: float32

  Vec3Arr = array[3, float32]

  Vec3ObjArr = object
    arr: array[3, float32]

  Vec3Tuple = tuple[x: float32, y: float32, z: float32]

proc vec3Obj(x, y, z: float32): Vec3Obj {.inline.} =
  Vec3Obj(x: x, y: y, z: z)

proc vec3Arr(x, y, z: float32): Vec3Arr {.inline.} =
  [x, y, z]

proc vec3ObjArr(x, y, z: float32): Vec3ObjArr {.inline.} =
  Vec3ObjArr(arr: [x, y, z])

proc vec3Tuple(x, y, z: float32): Vec3Tuple {.inline.} =
  (x, y, z)

timeIt "create vec3Obj", 1000:
  var s = newSeq[Vec3Obj](100000)
  for i in 0 ..< 100000:
    s[i] = vec3Obj(i.float32, 0, 0)
  keep s

timeIt "create vec3Arr", 1000:
  var s = newSeq[Vec3Arr](100000)
  for i in 0 ..< 100000:
    s[i] = vec3Arr(i.float32, 0, 0)
  keep s

timeIt "create vec3ObjArr", 1000:
  var s = newSeq[Vec3ObjArr](100000)
  for i in 0 ..< 100000:
    s[i] = vec3ObjArr(i.float32, 0, 0)
  keep s

timeIt "create vec3Tuple", 1000:
  var s = newSeq[Vec3Tuple](100000)
  for i in 0 ..< 100000:
    s[i] = vec3Tuple(i.float32, 0, 0)
  keep s

echo "..."

proc `[]`(a: Vec3Arr, i: int): float32 {.inline.} =
  cast[array[3, float32]](a)[i]

proc `[]`(a: Vec3Obj, i: int): float32 {.inline.} =
  cast[array[3, float32]](a)[i]

proc `[]`(a: Vec3ObjArr, i: int): float32 {.inline.} =
  a.arr[i]

proc get(a: Vec3Tuple, i: int): float32 {.inline.} =
  cast[array[3, float32]](a)[i]

timeIt "vec3Obj[static]", 1000:
  var v = vec3Obj(1, 2, 3)
  for i in 0 .. 1000000:
    keep v[0]
    keep v[1]
    keep v[2]

timeIt "vec3Arr[static]", 1000:
  var v = vec3Arr(1, 2, 3)
  for i in 0 .. 1000000:
    keep v[0]
    keep v[1]
    keep v[2]

timeIt "vec3ObjArr[static]", 1000:
  var v = vec3ObjArr(1, 2, 3)
  for i in 0 .. 1000000:
    keep v[0]
    keep v[1]
    keep v[2]

timeIt "vec3Tuple[static]", 1000:
  var v = vec3Tuple(1, 2, 3)
  for i in 0 .. 1000000:
    keep v[0]
    keep v[1]
    keep v[2]

echo "..."

timeIt "vec3Obj[]", 1000:
  var v = vec3Obj(1, 2, 3)
  for i in 0 .. 1000000:
    keep v[i mod 3]

timeIt "vec3Arr[]", 1000:
  var v = vec3Arr(1, 2, 3)
  for i in 0 .. 1000000:
    keep v[i mod 3]

timeIt "vec3ObjArr[]", 1000:
  var v = vec3ObjArr(1, 2, 3)
  for i in 0 .. 1000000:
    keep v[i mod 3]

timeIt "vec3Tuple[]", 1000:
  var v = vec3Tuple(1, 2, 3)
  for i in 0 .. 1000000:
    keep v.get(i mod 3)

echo "..."

proc `x`(a: Vec3Arr): float32 {.inline.} = a[0]
proc `y`(a: Vec3Arr): float32 {.inline.} = a[1]
proc `z`(a: Vec3Arr): float32 {.inline.} = a[2]

proc `x`(a: Vec3ObjArr): float32 {.inline.} = a.arr[0]
proc `y`(a: Vec3ObjArr): float32 {.inline.} = a.arr[1]
proc `z`(a: Vec3ObjArr): float32 {.inline.} = a.arr[2]

timeIt "vec3Obj.xyz", 1000:
  var v = vec3Obj(1, 2, 3)
  for i in 0 .. 1000000:
    keep v.x
    keep v.y
    keep v.z

timeIt "vec3Arr.xyz", 1000:
  var v = vec3Arr(1, 2, 3)
  for i in 0 .. 1000000:
    keep v.x
    keep v.y
    keep v.z

timeIt "vec3ObjArr.xyz", 1000:
  var v = vec3ObjArr(1, 2, 3)
  for i in 0 .. 1000000:
    keep v.x
    keep v.y
    keep v.z

timeIt "vec3Tuple.xyz", 1000:
  var v = vec3Tuple(1, 2, 3)
  for i in 0 .. 1000000:
    keep v.x
    keep v.y
    keep v.z

echo "..."

proc `[]=`(a: var Vec3Obj, i: int, v: float32) {.inline.} =
  cast[ptr float32](cast[uint64](a.addr) + i.uint64 * sizeof(float32).uint64)[] = v

proc `[]=`(a: var Vec3ObjArr, i: int, v: float32) {.inline.} =
  a.arr[i] = v

proc set(a: var Vec3Tuple, i: int, v: float32) {.inline.} =
  cast[ptr float32](cast[uint64](a.addr) + i.uint64 * sizeof(float32).uint64)[] = v

timeIt "vec3Obj[static]=", 1000:
  var v = vec3Obj(1, 2, 3)
  for i in 0 .. 1000000:
    v[0] = i.float32
    v[1] = i.float32
    v[2] = i.float32
    keep v

timeIt "vec3Arr[static]=", 1000:
  var v = vec3Arr(1, 2, 3)
  for i in 0 .. 1000000:
    v[0] = i.float32
    v[1] = i.float32
    v[2] = i.float32
    keep v

timeIt "vec3ObjArr[static]=", 1000:
  var v = vec3ObjArr(1, 2, 3)
  for i in 0 .. 1000000:
    v[0] = i.float32
    v[1] = i.float32
    v[2] = i.float32
    keep v

timeIt "vec3Tuple[static]=", 1000:
  var v = vec3Tuple(1, 2, 3)
  for i in 0 .. 1000000:
    v[0] = i.float32
    v[1] = i.float32
    v[2] = i.float32
    keep v

echo "..."

proc `x=`(a: var Vec3Arr, v: float32) {.inline.} = a[0] = v
proc `y=`(a: var Vec3Arr, v: float32) {.inline.} = a[1] = v
proc `z=`(a: var Vec3Arr, v: float32) {.inline.} = a[2] = v

proc `x=`(a: var Vec3ObjArr, v: float32) {.inline.} = a.arr[0] = v
proc `y=`(a: var Vec3ObjArr, v: float32) {.inline.} = a.arr[1] = v
proc `z=`(a: var Vec3ObjArr, v: float32) {.inline.} = a.arr[2] = v

timeIt "vec3Obj.xyz=", 1000:
  var v = vec3Obj(1, 2, 3)
  for i in 0 .. 1000000:
    v.x = i.float32
    v.y = i.float32
    v.z = i.float32
    keep v

timeIt "vec3Arr.xyz=", 1000:
  var v = vec3Arr(1, 2, 3)
  for i in 0 .. 1000000:
    v.x = i.float32
    v.y = i.float32
    v.z = i.float32
    keep v

timeIt "vec3ObjArr.xyz=", 1000:
  var v = vec3ObjArr(1, 2, 3)
  for i in 0 .. 1000000:
    v.x = i.float32
    v.y = i.float32
    v.z = i.float32
    keep v

timeIt "vec3Tuple.xyz=", 1000:
  var v = vec3Tuple(1, 2, 3)
  for i in 0 .. 1000000:
    v.x = i.float32
    v.y = i.float32
    v.z = i.float32
    keep v

echo "..."

timeIt "vec3Obj[]=", 1000:
  var v = vec3Obj(1, 2, 3)
  for i in 0 .. 1000000:
    v[i mod 3] = i.float32
    keep v

timeIt "vec3Arr[]=", 1000:
  var v = vec3Arr(1, 2, 3)
  for i in 0 .. 1000000:
    v[i mod 3] = i.float32
    keep v

timeIt "vec3ObjArr[]=", 1000:
  var v = vec3ObjArr(1, 2, 3)
  for i in 0 .. 1000000:
    v[i mod 3] = i.float32
    keep v

timeIt "vec3Tuple[]=", 1000:
  var v = vec3Tuple(1, 2, 3)
  for i in 0 .. 1000000:
    v.set(i mod 3, i.float32)
    keep v



================================================
FILE: tests/bench_swizzle.nim
================================================
import 
  benchy,
  vmath

block:
  var
    a = vec2(1, 10)
    b = vec2(2, 20)
    c = vec2(3, 30)
  timeIt "xy":
    for i in 0 ..< 1_000_000:
      c.yx = a.xy + b.rg + c.xy
  echo c.xy

block:
  var
    a = vec3(1, 10, 100)
    b = vec3(2, 20, 200)
    c = vec3(3, 30, 300)
  timeIt "xyz":
    for i in 0 ..< 1_000_000:
      c.zyx = a.xyz + b.rgb + c.xyz
  echo c.xyz

block:
  var
    a = vec4(1, 10, 100, -1)
    b = vec4(2, 20, 200, -1)
    c = vec4(3, 30, 300, -1)
  timeIt "xyzw":
    for i in 0 ..< 1_000_000:
      c.wzyx = a.xyzw + b.rgba + c.xyzw
  echo c.xyzw



================================================
FILE: tests/config.nims
================================================
--path:"../src"



================================================
FILE: tests/test.nim
================================================
import 
  std/random,
  vmath

randomize(1234)

block:
  # Test ~=.
  doAssert 1.0 ~= 1.0
  doAssert 0.0 ~= 0.0
  doAssert -1.0 ~= -1.0
  doAssert not(0.1 ~= 0.2)
  doAssert not(0.01 ~= 0.02)
  doAssert not(0.001 ~= 0.002)
  doAssert not(0.0001 ~= 0.0002)
  doAssert not(0.00001 ~= 0.00002)

  # Diff < epsilon.
  doAssert 0.000001 ~= 0.000002
  doAssert -0.000001 ~= -0.000002

  doAssert vec2(1.0, 2.0) ~= vec2(1.0, 2.0)
  doAssert vec3(1.0, 2.0, 3.0) ~= vec3(1.0, 2.0, 3.0)
  doAssert vec4(1.0, 2.0, 3.0, 4.0) ~= vec4(1.0, 2.0, 3.0, 4.0)
  doAssert quat(1.0, 2.0, 3.0, 4.0) ~= quat(1.0, 2.0, 3.0, 4.0)

  doAssert dvec2(1) ~= dvec2(1)
  doAssert dvec4(1, 2, 3, 4).xy ~= dvec2(1, 2)

  when compiles(1 ~= 1):
    doAssert false

block:
  # Test simple functions.
  doAssert between(0.5, 0, 1)
  doAssert not between(1.5, 0, 1)

  doAssert sign(-1.0) == -1.0
  doAssert sign(0.0) == 1.0
  doAssert sign(1.0) == 1.0

  block:
    proc quantize2(v, n: float32): float32 =
      ## Makes v be multiple of n. Rounding to integer quantize by 1.0.
      sign(v) * trunc(abs(v) / n) * n

    let n = 1.float32 / 10

    for _ in 0 ..< 10_000:
      let f = rand(-100.float32 .. 100.float32)
      doAssert quantize(f, n) == quantize2(f, n)

  doAssert quantize(1.23456789, 1.0) ~= 1
  doAssert quantize(1.23456789, 0.1) ~= 1.2
  doAssert quantize(1.23456789, 0.01) ~= 1.23
  doAssert quantize(-1.23456789, 0.01) ~= -1.23

  doAssert fract(0.0) ~= 0.0
  doAssert fract(3.14) ~= 0.14
  doAssert fract(-3.14) ~= 0.14
  doAssert fract(1.23456789) ~= 0.23456789
  doAssert fract(-1.23456789) ~= 0.23456789

  doAssert mix(0.0, 1.0, 0.5) ~= 0.5
  doAssert mix(0.0, 10.0, 0.5) ~= 5.0
  doAssert mix(0.0, 100.0, 0.5) ~= 50.0
  doAssert mix(-1.0, 1.0, 0.25) ~= -0.5
  doAssert mix(-10.0, 10.0, 0.25) ~= -5.0
  doAssert mix(-100.0, 100.0, 0.25) ~= -50.0

  doAssert mix(0.0, 1.0, 0.5) ~= 0.5
  doAssert mix(0.0, 10.0, 0.5) ~= 5.0
  doAssert mix(0.0, 100.0, 0.5) ~= 50.0
  doAssert mix(-1.0, 1.0, 0.25) ~= -0.5
  doAssert mix(-10.0, 10.0, 0.25) ~= -5.0
  doAssert mix(-100.0, 100.0, 0.25) ~= -50.0

  doAssert fixAngle(0.1) ~= 0.1
  doAssert fixAngle(1.1) ~= 1.1
  doAssert fixAngle(2.1) ~= 2.1
  doAssert fixAngle(3.1) ~= 3.1
  doAssert fixAngle(4.1) ~= -2.183185577392578
  doAssert fixAngle(-0.1) ~= -0.1
  doAssert fixAngle(-1.1) ~= -1.1
  doAssert fixAngle(-2.1) ~= -2.1
  doAssert fixAngle(-3.1) ~= -3.1
  doAssert fixAngle(-4.1) ~= 2.183185577392578

  doAssert angleBetween(0.0, 1.0) ~= 1.0
  doAssert angleBetween(0.0, PI) ~= PI
  doAssert angleBetween(0.0, PI + 0.2) ~= (-PI + 0.2)
  doAssert angleBetween(0.1, 0.2) ~= 0.1
  doAssert angleBetween(0.1, 0.2 + PI*2) ~= 0.1
  doAssert angleBetween(0.1, 0.2 - PI*2) ~= 0.1
  doAssert angleBetween(0.1 + PI*2, 0.2) ~= 0.1
  doAssert angleBetween(0.1 - PI*2, 0.2) ~= 0.1
  doAssert angleBetween(0.2, 0.1) ~= -0.1
  doAssert angleBetween(0.2, 0.1 - PI*2) ~= -0.1
  doAssert angleBetween(0.2, 0.1 + PI*2) ~= -0.1
  doAssert angleBetween(0.2 + PI*2, 0.1) ~= -0.1
  doAssert angleBetween(0.2 - PI*2, 0.1) ~= -0.1

  doAssert turnAngle(0.0, PI, 0.5) ~= 0.5
  doAssert turnAngle(0.5, PI, 3.5) ~= PI

  proc isNaNSlow(f: SomeFloat): bool =
    ## Returns true if number is a NaN.
    f.classify notin {fcNormal, fcZero, fcSubnormal}

  doAssert isNaNSlow(0.3) == false
  doAssert isNaNSlow(0.0) == false
  doAssert isNaNSlow(0.3/0.0) == true
  doAssert isNaNSlow(-0.3/0.0) == true
  doAssert isNaNSlow(5.0e-324) == false

  doAssert isNan(float32(0.3)) == false
  doAssert isNan(float32(0.0)) == false
  doAssert isNan(float32(0.3/0.0)) == true
  doAssert isNan(float32(-0.3/0.0)) == true
  doAssert isNan(float32(5.0e-324)) == false

  doAssert isNan(float64(0.3)) == false
  doAssert isNan(float64(0.0)) == false
  doAssert isNan(float64(0.3/0.0)) == true
  doAssert isNan(float64(-0.3/0.0)) == true
  doAssert isNan(float64(5.0e-324)) == false

block:
  when not defined(js):
    # Test vec2 cast.
    var v = vec2(1.0, 2.0)
    var a = cast[array[2, float32]](v)
    doAssert a[0] ~= 1.0
    doAssert a[1] ~= 2.0

block:
  # Test position assignment
  var
    v2 = vec2(0)
    v3 = vec3(0)
    v4 = vec4(0)
  v2[0] = 1.0
  v2[1] = 2.0
  doAssert v2 ~= vec2(1, 2)
  v3[0] = 1.0
  v3[1] = 2.0
  v3[2] = 3.0
  doAssert v3 ~= vec3(1, 2, 3)
  v4[0] = 1.0
  v4[1] = 2.0
  v4[2] = 3.0
  v4[3] = 4.0
  doAssert v4 ~= vec4(1, 2, 3, 4)

block:
  # Test vec2 constructor.
  doAssert vec2(PI, PI) ~= vec2(PI)

block:
  # Test basic vector vec2.
  var a = vec2(1, 2)
  var b = vec2(7, 6)
  var n = 13.7
  doAssert a + b ~= vec2(8.0, 8.0)
  doAssert a - b ~= vec2(-6.0, -4.0)
  doAssert a * n ~= vec2(13.7, 27.4)
  doAssert a / n ~= vec2(0.0729927, 0.1459854)
  a += b
  doAssert a ~= vec2(8.0, 8.0)
  a -= b
  doAssert a ~= vec2(1.0, 2.0)
  a *= n
  doAssert a ~= vec2(13.7, 27.4)
  a /= n
  doAssert a ~= vec2(1.0, 2.0)

block:
  # Test basic vector vec3.
  var a = vec3(1, 2, 3)
  var b = vec3(7, 6, 5)
  var n = 13.7
  doAssert a + b ~= vec3(8.0, 8.0, 8.0)
  doAssert a - b ~= vec3(-6.0, -4.0, -2.0)
  doAssert a * n ~= vec3(13.69999981, 27.39999962, 41.09999847)
  doAssert a / n ~= vec3(0.07299270, 0.14598541, 0.21897811)
  a += b
  doAssert a ~= vec3(8.0, 8.0, 8.0)
  a -= b
  doAssert a ~= vec3(1.0, 2.0, 3.0)
  a *= n
  doAssert a ~= vec3(13.69999981, 27.39999962, 41.09999847)
  a /= n
  doAssert a ~= vec3(1.0, 2.0, 3.0)

block:
  # Test basic vector vec4.
  var a = vec4(1, 2, 3, 4)
  var b = vec4(7, 6, 5, 4)
  var n = 13.7
  doAssert a + b ~= vec4(8.0, 8.0, 8.0, 8.0)
  doAssert a - b ~= vec4(-6.0, -4.0, -2.0, 0.0)
  doAssert a * n ~= vec4(13.69999981, 27.39999962, 41.09999847, 54.79999924)
  doAssert a / n ~= vec4(0.07299270, 0.14598541, 0.21897811, 0.29197082)
  a += b
  doAssert a ~= vec4(8.0, 8.0, 8.0, 8.0)
  a -= b
  doAssert a ~= vec4(1.0, 2.0, 3.0, 4.0)
  a *= n
  doAssert a ~= vec4(13.69999981, 27.39999962, 41.09999847, 54.79999924)
  a /= n
  doAssert a ~= vec4(1.0, 2.0, 3.0, 4.0)

block:
  # Test all type constructors compile
  let
    _ = bvec2(true, false)
    _ = bvec3(true, false, true)
    _ = bvec4(true, false, true, false)

    _ = ivec2(-1, 2)
    _ = ivec3(-1, 2, 3)
    _ = ivec4(-1, 2, 3, 4)

    _ = uvec2(1, 2)
    _ = uvec3(1, 2, 3)
    _ = uvec4(1, 2, 3, 4)

    _ = vec2(1.0, 2.0)
    _ = vec3(1.0, 2.0, 3.0)
    _ = vec4(1.0, 2.0, 3.0, 4.0)

    _ = dvec2(1.0, 2.0)
    _ = dvec3(1.0, 2.0, 3.0)
    _ = dvec4(1.0, 2.0, 3.0, 4.0)

    _ = bvec2(true)
    _ = bvec3(true)
    _ = bvec4(true)

    _ = ivec2(-1)
    _ = ivec3(-1)
    _ = ivec4(-1)

    _ = uvec2(1)
    _ = uvec3(1)
    _ = uvec4(1)

    _ = vec2(1.0)
    _ = vec3(1.0)
    _ = vec4(1.0)

    _ = dvec2(1.0)
    _ = dvec3(1.0)
    _ = dvec4(1.0)

    _ = bvec2()
    _ = bvec3()
    _ = bvec4()

    _ = ivec2()
    _ = ivec3()
    _ = ivec4()

    _ = uvec2()
    _ = uvec3()
    _ = uvec4()

    _ = vec2()
    _ = vec3()
    _ = vec4()

    _ = dvec2()
    _ = dvec3()
    _ = dvec4()

  var a = vec3(vec2(1, 2), 3)
  doAssert a == vec3(1, 2, 3)

  var b = vec4(vec3(1, 2, 3), 4)
  doAssert b == vec4(1, 2, 3, 4)

  var c = vec4(vec2(1, 2), vec2(3, 4))
  doAssert c == vec4(1, 2, 3, 4)

block:
  # test $ string functions
  doAssert $bvec2(true, false) == "bvec2(true, false)"
  doAssert $bvec3(true, false, true) == "bvec3(true, false, true)"
  doAssert $bvec4(true, false, true, false) == "bvec4(true, false, true, false)"

  doAssert $ivec2(1, 2) == "ivec2(1, 2)"
  doAssert $ivec3(1, 2, 3) == "ivec3(1, 2, 3)"
  doAssert $ivec4(1, 2, 3, 4) == "ivec4(1, 2, 3, 4)"

  doAssert $uvec2(1, 2) == "uvec2(1, 2)"
  doAssert $uvec3(1, 2, 3) == "uvec3(1, 2, 3)"
  doAssert $uvec4(1, 2, 3, 4) == "uvec4(1, 2, 3, 4)"

  doAssert $vec2(1.0, 2.0) == "vec2(1.0, 2.0)"
  doAssert $vec3(1.0, 2.0, 3.0) == "vec3(1.0, 2.0, 3.0)"
  doAssert $vec4(1.0, 2.0, 3.0, 4.0) == "vec4(1.0, 2.0, 3.0, 4.0)"

  doAssert $dvec2(1.0, 2.0) == "dvec2(1.0, 2.0)"
  doAssert $dvec3(1.0, 2.0, 3.0) == "dvec3(1.0, 2.0, 3.0)"
  doAssert $dvec4(1.0, 2.0, 3.0, 4.0) == "dvec4(1.0, 2.0, 3.0, 4.0)"

block:
  # test swizzle vec
  var a = vec2(1, 2)
  doAssert a.x == 1.0
  doAssert a.y == 2.0
  doAssert a.yx == vec2(2, 1)
  doAssert a.gr == vec2(2, 1)
  doAssert a.ts == vec2(2, 1)
  doAssert a.xxx == vec3(1, 1, 1)

  a.yx = vec2(-1, -2)
  doAssert a == vec2(-2, -1)

  a.xx = vec2(-7, -3)
  doAssert a == vec2(-3, -1)

  when compiles(a.xyzxyz):
    doAssert false

  when compiles(a.z = 123):
    doAssert false

  var b = vec4(1, 2, 3, 4)
  doAssert b == vec4(1, 2, 3, 4)
  b.wzyx = b
  doAssert b == vec4(4, 3, 2, 1)

  b.g = 123
  doAssert b == vec4(4.0, 123.0, 2.0, 1.0)

block:
  # test swizzle dvec float64
  var a = dvec2(1, 2)
  doAssert a.x == 1.0
  doAssert a.y == 2.0
  doAssert a.yx == dvec2(2, 1)
  doAssert a.gr == dvec2(2, 1)
  doAssert a.ts == dvec2(2, 1)
  doAssert a.xxx == dvec3(1, 1, 1)

  a.yx = dvec2(-1, -2)
  doAssert a == dvec2(-2, -1)

  a.xx = dvec2(-7, -3)
  doAssert a == dvec2(-3, -1)

  when compiles(a.xyzxyz):
    doAssert false

  when compiles(a.z = 123):
    doAssert false

  var b = dvec4(1, 2, 3, 4)
  doAssert b == dvec4(1, 2, 3, 4)

  b.g = 123
  doAssert b == dvec4(1.0, 123.0, 3.0, 4.0)

block:
  # test swizzle self-assignment
  var a = dvec2(1, 2)
  a.yx = a
  doAssert a == dvec2(2, 1)

  var b = dvec3(1, 2, 3)
  b.zyx = b
  doAssert b == dvec3(3, 2, 1)

  var c = dvec4(1, 2, 3, 4)
  c.wzyx = c
  doAssert c == dvec4(4, 3, 2, 1)

block:
  # Test swizzle calls only once
  var callCount = 0
  proc countsCalls(): Vec2 =
    inc callCount

  doAssert countsCalls().yx == vec2(0, 0)
  doAssert callCount == 1

  callCount = 0
  doAssert vec2(0, 0) == countsCalls().yx
  doAssert callCount == 1

  var tmp: Vec2
  proc countsCalls2(): var Vec2 =
    inc callCount
    return tmp

  callCount = 0
  countsCalls2().yx = vec2(0, 0)
  doAssert callCount == 1

block:
  # Test swizzle with complex expressions
  var a = [
    vec2(1, 2),
    vec2(3, 4),
    vec2(5, 6),
    vec2(7, 8),
  ]
  var i = 0
  proc f(): var Vec2 =
    # function with side effects
    result = a[i]
    inc i

  doAssert f().yx == vec2(2, 1)
  doAssert f().gr == vec2(4, 3)
  doAssert f().ts == vec2(6, 5)
  doAssert f().yx == vec2(8, 7)
  doAssert i == 4

  i = 0
  f().yx = f()
  doAssert a[0] == vec2(4, 3)
  doAssert a[1] == vec2(3, 4)
  doAssert i == 2

  var b = [
    vec3(1, 2, 3),
    vec3(4, 5, 6),
    vec3(7, 8, 9),
  ]
  i = 0
  proc g(): var Vec3 =
    # function with side effects
    result = b[i]
    inc i

  doAssert g().yxz == vec3(2, 1, 3)
  doAssert g().bgr == vec3(6, 5, 4)
  doAssert g().tps == vec3(8, 9, 7)
  doAssert i == 3

  i = 0
  g().yxz = g()
  doAssert b[0] == vec3(5, 4, 6)
  doAssert b[1] == vec3(4, 5, 6)
  doAssert i == 2

  var c = [
    vec4(1, 2, 3, 4),
    vec4(5, 6, 7, 8),
  ]
  i = 0
  proc h(): var Vec4 =
    # function with side effects
    result = c[i]
    inc i

  doAssert h().yxzw == vec4(2, 1, 3, 4)
  doAssert h().tqsp == vec4(6, 8, 5, 7)
  doAssert i == 2

  i = 0
  h().wzyx = h()
  doAssert c[0] == vec4(8, 7, 6, 5)
  doAssert c[1] == vec4(5, 6, 7, 8)
  doAssert i == 2


block:
  # Test basic mat constructors.
  block:
    let
      _ = mat2()
      _ = mat3()
      _ = mat4()

  block:
    let
      _ = mat2(
        1, 0,
        0, 1
      )
      _ = mat3(
        1, 0, 0,
        0, 1, 0,
        0, 0, 1
      )
      _ = mat4(
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1
      )

  block:
    # test $ string functions
    doAssert $mat2(
      1, 3,
      0, 1
    ) == """mat2(
  1.0, 3.0,
  0.0, 1.0
)"""
    doAssert $mat3(
      1, 3, 0,
      0, 1, 0,
      0, 3, 1
    ) == """mat3(
  1.0, 3.0, 0.0,
  0.0, 1.0, 0.0,
  0.0, 3.0, 1.0
)"""
    doAssert $mat4(
      1, 3, 0, 0,
      0, 1, 0, 0,
      0, 3, 1, 0,
      0, 3, 0, 1
    ) == """mat4(
  1.0, 3.0, 0.0, 0.0,
  0.0, 1.0, 0.0, 0.0,
  0.0, 3.0, 1.0, 0.0,
  0.0, 3.0, 0.0, 1.0
)"""
    doAssert $dmat2(
      1, 0,
      4, 1
    ) == """dmat2(
  1.0, 0.0,
  4.0, 1.0
)"""
    doAssert $dmat3(
      1, 0, 0,
      4, 1, 0,
      4, 0, 1
    ) == """dmat3(
  1.0, 0.0, 0.0,
  4.0, 1.0, 0.0,
  4.0, 0.0, 1.0
)"""
    doAssert $dmat4(
      1, 0, 0, 0,
      4, 1, 0, 0,
      4, 0, 1, 0,
      4, 0, 0, 1
    ) == """dmat4(
  1.0, 0.0, 0.0, 0.0,
  4.0, 1.0, 0.0, 0.0,
  4.0, 0.0, 1.0, 0.0,
  4.0, 0.0, 0.0, 1.0
)"""

  block:
    let
      _ = mat2(
        vec2(1, 0),
        vec2(0, 1)
      )
      _ = mat3(
        vec3(1, 0, 0),
        vec3(0, 1, 0),
        vec3(0, 0, 1)
      )
      _ = mat4(
        vec4(1, 0, 0, 0),
        vec4(0, 1, 0, 0),
        vec4(0, 0, 1, 0),
        vec4(0, 0, 0, 1)
      )

  block:
    let
      _ = dmat2()
      _ = dmat3()
      _ = dmat4()

  block:
    let
      _ = dmat2(
        1, 0,
        0, 1
      )
      _ = dmat3(
        1, 0, 0,
        0, 1, 0,
        0, 0, 1
      )
      _ = dmat4(
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1
      )

  block:
    let
      _ = dmat2(
        dvec2(1, 0),
        dvec2(0, 1)
      )
      _ = dmat3(
        dvec3(1, 0, 0),
        dvec3(0, 1, 0),
        dvec3(0, 0, 1)
      )
      _ = dmat4(
        dvec4(1, 0, 0, 0),
        dvec4(0, 1, 0, 0),
        dvec4(0, 0, 1, 0),
        dvec4(0, 0, 0, 1)
      )

  block:
    var
      d2 = dmat2()
      d3 = dmat3()
      d4 = dmat4()

    d2[0, 0] = 123.123
    d2[1, 1] = 123.123

    d3[0, 0] = 123.123
    d3[1, 1] = 123.123
    d3[2, 2] = 123.123

    d4[0, 0] = 123.123
    d4[1, 1] = 123.123
    d4[2, 2] = 123.123
    d4[3, 3] = 123.123

block:
  # Test basic mat functions.
  doAssert dmat3().transpose() ~= dmat3(
    1.0, 0.0, 0.0,
    0.0, 1.0, 0.0,
    0.0, 0.0, 1.0
  )
  doAssert dmat4().transpose() ~= dmat4(
    1.0, 0.0, 0.0, 0.0,
    0.0, 1.0, 0.0, 0.0,
    0.0, 0.0, 1.0, 0.0,
    0.0, 0.0, 0.0, 1.0
  )

  doAssert scale(dvec2(1, 2)) ~= dmat3(
    1.0, 0.0, 0.0,
    0.0, 2.0, 0.0,
    0.0, 0.0, 1.0
  )
  doAssert scale(dvec3(2, 2, 3)) ~= dmat4(
    2.0, 0.0, 0.0, 0.0,
    0.0, 2.0, 0.0, 0.0,
    0.0, 0.0, 3.0, 0.0,
    0.0, 0.0, 0.0, 1.0
  )

  doAssert translate(dvec2(1, 2)) ~= dmat3(
    1.0, 0.0, 0.0,
    0.0, 1.0, 0.0,
    1.0, 2.0, 1.0
  )
  doAssert translate(dvec3(1, 2, 3)) ~= dmat4(
    1.0, 0.0, 0.0, 0.0,
    0.0, 1.0, 0.0, 0.0,
    0.0, 0.0, 1.0, 0.0,
    1.0, 2.0, 3.0, 1.0
  )

  doAssert rotate(1.0) ~= dmat3(
    0.5403023058681398, -0.8414709848078965, 0.0,
    0.8414709848078965, 0.5403023058681398, 0.0,
    0.0, 0.0, 1.0
  )

  doAssert scale(dvec2(2)) ~= dmat3(
    2.0, 0.0, 0.0,
    0.0, 2.0, 0.0,
    0.0, 0.0, 1.0
  )
  doAssert scale(dvec3(2)) ~= dmat4(
    2.0, 0.0, 0.0, 0.0,
    0.0, 2.0, 0.0, 0.0,
    0.0, 0.0, 2.0, 0.0,
    0.0, 0.0, 0.0, 1.0
  )

  doAssert translate(dvec2(2)) ~= dmat3(
    1.0, 0.0, 0.0,
    0.0, 1.0, 0.0,
    2.0, 2.0, 1.0
  )
  doAssert translate(dvec3(2)) ~= dmat4(
    1.0, 0.0, 0.0, 0.0,
    0.0, 1.0, 0.0, 0.0,
    0.0, 0.0, 1.0, 0.0,
    2.0, 2.0, 2.0, 1.0
  )

  doAssert rotate(1.0).inverse() ~= dmat3(
    0.5403023058681398, 0.8414709848078965, -0.0,
    -0.8414709848078965, 0.5403023058681398, -0.0,
    0.0, -0.0, 1.0
  )
  doAssert rotate(1.0, dvec3(1, 0, 0)).inverse() ~= dmat4(
    1.0, 0.0, 0.0, 0.0,
    -0.0, 0.5403022766113281, 0.8414710164070129, 0.0,
    0.0, -0.8414710164070129, 0.5403022766113281, 0.0,
    0.0, 0.0, 0.0, 1.0
  )


  block:
    doAssert translate(vec2(1, 2)).pos == vec2(1, 2)

    var translation = translate(vec2(1, 2))
    translation.pos = vec2(3, 4)
    doAssert translation.pos == vec2(3, 4)

  block:
    doAssert translate(vec3(1, 2, 3)).pos == vec3(1, 2, 3)

    var translation = translate(vec3(1, 2, 3))
    translation.pos = vec3(3, 4, 5)
    doAssert translation.pos == vec3(3, 4, 5)

block:
  # Test basic vector mat4 and quat.
  var m1 = mat4(
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1)
  var q1 = m1.quat()
  var m2 = q1.mat4()
  doAssert m2 ~= mat4(
    1.00000, 0.00000, 0.00000, 0.00000,
    0.00000, 1.00000, 0.00000, 0.00000,
    0.00000, 0.00000, 1.00000, 0.00000,
    0.00000, 0.00000, 0.00000, 1.00000
  )
  doAssert m1 ~= (m2)

block:
  # Test basic vector mat4 -1.
  var m1 = mat4(
    1, 0, 0, 0,
    0, 0, -1, 0,
    0, 1, 0, 0,
    0, 0, 0, 1)
  var q1 = m1.quat()
  var m2 = q1.mat4()
  doAssert m1 ~= m2

block:
  # Test Y 90.
  var m1 = rotate(PI/2, dvec3(0, 1, 0))
  var q1 = m1.quat()
  var m2 = q1.mat4()
  doAssert m1 ~= m2

block:
  # Test -Y 90.
  var m1 = rotate(PI/2, dvec3(0, -1, 0))
  var q1 = m1.quat()
  var m2 = q1.mat4()
  doAssert m1 ~= m2

block:
  # Test X 90.
  var m1 = rotate(PI/2, dvec3(1, 0, 0))
  var q1 = m1.quat()
  var m2 = q1.mat4()
  doAssert m1 ~= m2

block:
  # Test Y 90.
  var m1 = rotate(PI/2, dvec3(1, 0, 0))
  var q1 = m1.quat()
  var m2 = q1.mat4()
  doAssert m1 ~= m2

block:
  # Test 1,1,1 1.11rad.
  var m1 = rotate(PI*1.11, dvec3(1, 1, 1).normalize())
  var q1 = m1.quat()
  var m2 = q1.mat4()
  doAssert m1 ~= m2

block:
  # Test 1,1,1 1.11rad.
  var m1 = rotate(PI*1.11, dvec3(-1, 1, 1).normalize())
  var q1 = m1.quat()
  var m2 = q1.mat4()
  doAssert m1 ~= m2

block:
  # Test 1,1,1 1.11rad.
  var m1 = rotate(PI*1.11, dvec3(-1, 0.34, 1.123).normalize())
  var q1 = m1.quat()
  var m2 = q1.mat4()
  doAssert m1 ~= m2

block:
  # Test super random quat test.
  for i in 0 ..< 1000:
    var m1 = rotate(
      PI*rand(2.0),
      dvec3(rand(2.0)-0.5, rand(2.0)-0.5, rand(2.0)-0.5).normalize()
    )
    var q1 = m1.quat()
    var m2 = q1.mat4()
    doAssert m1 ~= m2

block:
  # Test *=1 /=1 don't change anything.
  var v2 = vec2(0, 0)
  v2 *= 1
  v2 /= 1
  doAssert v2 == vec2(0, 0)

  var v3 = vec3(0, 0, 0)
  v3 *= 1
  v3 /= 1
  doAssert v3 == vec3(0, 0, 0)

  var v4 = vec4(0, 0, 0, 0)
  v4 *= 1
  v4 /= 1
  doAssert v4 == vec4(0, 0, 0, 0)

  var q = quat(0, 0, 0, 0)
  q *= 1
  q /= 1
  doAssert q == quat(0, 0, 0, 0)

block:
  # Test matrix and vector multiplication.
  var a3 = mat3(
    0.9659258723258972, -0.258819043636322, 0.0,
    0.258819043636322, 0.9659258723258972, 0.0,
    -25.00000953674316, 70.09619140625, 1.0
  )
  var b3 = mat3(
    0.9659258127212524, 0.258819043636322, 0.0,
    -0.258819043636322, 0.9659258127212524, 0.0,
    77.64571380615234, 0.0, 1.0
  )

  when not defined(js):
    # TODO: Figure out why we loose soo much precision in js.

    doAssert a3 * b3 ~= mat3(
      1.0000, 0.0000, 0.0000,
      0.0000, 1.0000, 0.0000,
      50.0000, 50.0000, 1.0000
    )

    doAssert a3 * vec2(77.64571380615234, 0) ~= vec2(50.0, 50.0)

  doAssert mat3(1, 2, 3, 4, 5, 6, 7, 8, 9) *
    mat3(10, 20, 30, 40, 50, 60, 70, 80, 90) ~= mat3(
      300.0000, 360.0000, 420.0000,
      660.0000, 810.0000, 960.0000,
      1020.0000, 1260.0000, 1500.0000
    )

block:
  # test quat and matrix
  doAssert ortho[float32](-1, 1, 1, -1, -1000, 1000) ~= mat4(
    1.0, 0.0, 0.0, 0.0,
    0.0, -1.0, 0.0, 0.0,
    0.0, 0.0, -0.001000000047497451,
    0.0, -0.0, 0.0, -0.0, 1.0
  )

  doAssert perspective[float32](75, 1.666, 1, 1000) ~= mat4(
    0.7822480201721191, 0.0, 0.0, 0.0,
    0.0, 1.30322527885437, 0.0, 0.0,
    0.0, 0.0, -1.002002000808716, -1.0,
    0.0, 0.0, -2.002002000808716, 0.0
  )

  # Test super random quat test.
  for i in 0 ..< 1000:
    var m1 = rotate(
      PI*rand(2.0),
      dvec3(rand(2.0)-0.5, rand(2.0)-0.5, rand(2.0)-0.5).normalize()
    )
    var q1 = m1.quat()
    var m2 = q1.mat4()
    doAssert m1 ~= m2

block:
  # test fromTwoVectors
  let
    a = vec3(1, 0, 0)
    b = vec3(0, 1, 0)
    q1 = fromTwoVectors(a, b)
  doAssert q1.mat4 * a ~= b

  for i in 0 ..< 1000:
    let
      a = vec3(rand(2.0)-0.5, rand(2.0)-0.5, rand(2.0)-0.5).normalize()
      b = vec3(rand(2.0)-0.5, rand(2.0)-0.5, rand(2.0)-0.5).normalize()
      q = fromTwoVectors(a, b)
    doAssert dist(q.mat4 * a, b) < 1E5

block:
  let mat2d = translate(vec2(10, 20)) * rotate(45.toRadians) * scale(vec2(2))

  let mat3d = translate(vec3(10, 20, 0)) * rotateZ(45.toRadians) * scale(vec3(2))

  doAssert mat2d ~= mat3(
    1.414213538169861, -1.414213538169861, 0.0,
    1.414213538169861, 1.414213538169861, 0.0,
    10.0, 20.0, 1.0
  )

  doAssert mat3d ~= mat4(
    1.414213418960571, -1.41421365737915, 0.0, 0.0,
    1.41421365737915, 1.414213418960571, 0.0, 0.0,
    0.0, 0.0, 2.0, 0.0,
    10.0, 20.0, 0.0, 1.0
  )

block:
  let
    a2 = vec2(10, -10)
    b2 = vec2(-10, 10)
    a3 = vec3(10, -10, 7)
    b3 = vec3(-10, 10, 0)
    a4 = vec4(10, -10, 7, -2)
    b4 = vec4(-10, 10, 0, -1)

  doAssert min(a2, b2) == vec2(-10, -10)
  doAssert min(a3, b3) == vec3(-10, -10, 0)
  doAssert min(a4, b4) == vec4(-10, -10, 0, -2)

  doAssert max(a2, b2) == vec2(10, 10)
  doAssert max(a3, b3) == vec3(10, 10, 7)
  doAssert max(a4, b4) == vec4(10, 10, 7, -1)

  doAssert mix(10f, 7, 0.75) == 7.75
  doAssert mix(a2, b2, 0.75) == vec2(-5.0, 5.0)
  doAssert mix(a3, b3, 0.75) == vec3(-5.0, 5.0, 1.75)
  doAssert mix(a4, b4, 0.75) == vec4(-5.0, 5.0, 1.75, -1.25)

  doAssert `mod`(1, 2) == 1
  doAssert `mod`(vec2(12, 6), vec2(6, 12)) == vec2(0, 6)
  doAssert `mod`(vec3(12, 6, 18), vec3(6, 12, 7)) == vec3(0, 6, 4)
  doAssert `mod`(vec4(12, 6, 18, 16), vec4(6, 12, 7, 15)) == vec4(0, 6, 4, 1)

  doAssert `zmod`(1, 2) == 1
  doAssert `zmod`(vec2(12, 6), vec2(6, 12)) == vec2(0, 6)
  doAssert `zmod`(vec3(12, 6, 18), vec3(6, 12, 7)) == vec3(0, 6, 4)
  doAssert `zmod`(vec4(12, 6, 18, 16), vec4(6, 12, 7, 15)) == vec4(0, 6, 4, 1)

block:
  doAssert vec2(1, 1) == vec2(1, 1)
  doAssert dvec2(2, 2) == dvec2(2, 2)
  doAssert bvec2(true, true) == bvec2(true, true)
  doAssert ivec2(3, 3) == ivec2(3, 3)
  doAssert uvec2(3, 3) == uvec2(3, 3)

  doAssert vec3(1, 1, 1) == vec3(1, 1, 1)
  doAssert dvec3(2, 2, 2) == dvec3(2, 2, 2)
  doAssert bvec3(true, true, true) == bvec3(true, true, true)
  doAssert ivec3(3, 3, 3) == ivec3(3, 3, 3)
  doAssert uvec3(3, 3, 3) == uvec3(3, 3, 3)

  doAssert vec4(1, 1, 1, 1) == vec4(1, 1, 1, 1)
  doAssert dvec4(2, 2, 2, 2) == dvec4(2, 2, 2, 2)
  doAssert bvec4(true, true, true, false) == bvec4(true, true, true, false)
  doAssert ivec4(3, 3, 3, 3) == ivec4(3, 3, 3, 3)
  doAssert uvec4(3, 3, 3, 3) == uvec4(3, 3, 3, 3)

  doAssert vec2(1, 1) != vec2(1, 2)
  doAssert dvec2(2, 2) != dvec2(2, 3)
  doAssert bvec2(true, true) != bvec2(true, false)
  doAssert ivec2(3, 3) != ivec2(3, 4)
  doAssert uvec2(3, 3) != uvec2(3, 4)

  doAssert vec3(1, 1, 1) != vec3(1, 1, 2)
  doAssert dvec3(2, 2, 2) != dvec3(2, 2, 3)
  doAssert bvec3(true, true, true) != bvec3(true, true, false)
  doAssert ivec3(3, 3, 3) != ivec3(3, 3, 4)
  doAssert uvec3(3, 3, 3) != uvec3(3, 3, 4)

  doAssert vec4(1, 1, 1, 1) != vec4(1, 1, 1, 2)
  doAssert dvec4(2, 2, 2, 2) != dvec4(2, 2, 2, 3)
  doAssert bvec4(true, true, true, false) != bvec4(true, true, true, true)
  doAssert ivec4(3, 3, 3, 3) != ivec4(3, 3, 3, 4)
  doAssert uvec4(3, 3, 3, 3) != uvec4(3, 3, 3, 4)

block:
  doAssert vec2(ivec2(1, 1)) == vec2(1, 1)
  doAssert vec2(uvec2(5, 5)) == vec2(5, 5)
  doAssert ivec2(uvec2(23, 23)) == ivec2(23, 23)
  doAssert uvec2(ivec2(12, 12)) == uvec2(12, 12)
  doAssert vec3(ivec3(1, 2, 3)) == vec3(1, 2, 3)
  doAssert vec3(uvec3(4, 5, 6)) == vec3(4, 5, 6)
  doAssert ivec3(uvec3(7, 8, 9)) == ivec3(7, 8, 9)
  doAssert uvec3(ivec3(10, 11, 12)) == uvec3(10, 11, 12)
  doAssert vec4(ivec4(13, 14, 15, 16)) == vec4(13, 14, 15, 16)
  doAssert vec4(uvec4(17, 18, 19, 20)) == vec4(17, 18, 19, 20)
  doAssert ivec4(uvec4(21, 22, 23, 24)) == ivec4(21, 22, 23, 24)
  doAssert uvec4(ivec4(25, 26, 27, 28)) == uvec4(25, 26, 27, 28)

block:
  # Test for https://github.com/treeform/vmath/issues/44
  doAssert PI.toDegrees() == 180
  doAssert (PI*2).toDegrees() == 360

block:
  # Test for https://github.com/treeform/vmath/issues/45
  block:
    let a = uvec2(10, 10)
    var b: UVec2
    when compiles(b = a / 2): doAssert false # type mismatch
    b = a div 2

  block:
    let a = vec2(10, 10)
    var b: Vec2
    b = a / 2
    when compiles(b = a div 2): doAssert false # type mismatch

proc eq(a, b: Vec3): bool =
  const epsilon = 0.001
  return abs(angleBetween(a.x, b.x)) < epsilon and
    abs(angleBetween(a.y, b.y)) < epsilon and
    abs(angleBetween(a.z, b.z)) < epsilon

const PI = PI.float32

block:
  # test Euler angles from a vector
  doAssert vec3(0, 0, 0).toAngles.eq vec3(0f, 0f, 0f)
  doAssert vec3(0, 0, 1).toAngles.eq vec3(0f, 0f, 0f) # forward
  doAssert vec3(0, 0, -1).toAngles.eq vec3(0f, PI, 0f) # back
  doAssert vec3(-1, 0, 0).toAngles.eq vec3(0f, PI/2, 0f) # right
  doAssert vec3(1, 0, 0).toAngles.eq vec3(0f, -PI/2, 0f) # left
  doAssert vec3(0, 1, 0).toAngles.eq vec3(PI/2, 0f, 0f) # up
  doAssert vec3(0, -1, 0).toAngles.eq vec3(-PI/2, 0f, 0f) # down

block:
  # test Euler angles from a matrix
  doAssert translate(vec3(0, 0, 0)).toAngles.eq vec3(0f, 0f, 0f)
  doAssert rotateX(0f).toAngles.eq vec3(0f, 0f, 0f) # forward
  doAssert rotateY(PI).toAngles.eq vec3(0f, -PI, 0f) # back
  doAssert rotateY(PI/2).toAngles.eq vec3(0f, PI/2, 0f) # back
  doAssert rotateY(-PI/2).toAngles.eq vec3(0f, -PI/2, 0f) # back
  doAssert rotateX(PI/2).toAngles.eq vec3(PI/2, 0f, 0f) # up
  doAssert rotateX(-PI/2).toAngles.eq vec3(-PI/2, 0f, 0f) # down
  doAssert rotateZ(PI/2).toAngles.eq vec3(0f, 0f, PI/2) # tilt right
  doAssert rotateZ(-PI/2).toAngles.eq vec3(0f, 0f, -PI/2) # tilt left

  doAssert mat4().toAngles.eq vec3(0, 0, 0)

  doAssert rotateX(10.toRadians()).toAngles.eq vec3(10.toRadians(), 0, 0)
  doAssert rotateY(10.toRadians()).toAngles.eq vec3(0, 10.toRadians(), 0)
  doAssert rotateZ(10.toRadians()).toAngles.eq vec3(0, 0, 10.toRadians())
  doAssert rotateX(89.toRadians()).toAngles.eq vec3(89.toRadians(), 0, 0)
  doAssert rotateY(89.toRadians()).toAngles.eq vec3(0, 89.toRadians(), 0)
  doAssert rotateZ(89.toRadians()).toAngles.eq vec3(0, 0, 89.toRadians())
  doAssert rotateX(90.toRadians()).toAngles.eq vec3(90.toRadians(), 0, 0)
  doAssert rotateY(90.toRadians()).toAngles.eq vec3(0, 90.toRadians(), 0)
  doAssert rotateZ(90.toRadians()).toAngles.eq vec3(0, 0, 90.toRadians())
  doAssert rotateX(90.toRadians()).toAngles.eq vec3(90.toRadians(), 0, 0)
  doAssert rotateY(90.toRadians()).toAngles.eq vec3(0, 90.toRadians(), 0)
  doAssert rotateZ(-90.toRadians()).toAngles.eq vec3(0, 0, -90.toRadians())
  doAssert rotateY(180.toRadians()).toAngles.eq vec3(0, -180.toRadians(), 0)
  doAssert rotateZ(180.toRadians()).toAngles.eq vec3(0, 0, 180.toRadians())
  doAssert rotateY(-180.toRadians()).toAngles.eq vec3(0, 180.toRadians(), 0)
  doAssert rotateZ(-180.toRadians()).toAngles.eq vec3(0, 0, 180.toRadians())

block:
  # Euler angles fuzzing tests.

  # Test fromAngles with and without roll have same forward
  for i in 0 .. 1000:
    let
      xr = rand(-89.9f .. 89.9f).toRadians
      yr = rand(-180 .. 180).toRadians
      zr = rand(-180 .. 180).toRadians
      a = vec3(xr, yr, zr)
      b = vec3(xr, yr, 0f)
      ma = fromAngles(a)
      mb = fromAngles(b)

    doAssert ma.forward() ~= mb.forward()

  # Test forward/back, right/left, up/down combos
  for i in 0 .. 1000:
    let
      xr = rand(-89.9f .. 89.9f).toRadians
      yr = rand(-180 .. 180).toRadians
      zr = rand(-180 .. 180).toRadians
      b = vec3(xr, yr, zr)
      m = fromAngles(b)

    doAssert m.forward() ~= m * vec3(0, 0, 1)
    doAssert m.back() ~= m * vec3(0, 0, -1)

    doAssert m.right() ~= m * vec3(-1, 0, 0)
    doAssert m.left() ~= m * vec3(1, 0, 0)

    doAssert m.up() ~= m * vec3(0, 1, 0)
    doAssert m.down() ~= m * vec3(0, -1, 0)

  # Test non-polar and non-rotated cases
  for i in 0 .. 1000:
    let
      xr = rand(-89.9f .. 89.9f).toRadians
      yr = rand(-180 .. 180).toRadians
      zr = 0f
      b = vec3(xr, yr, zr)
      m = fromAngles(b)
      a = m.toAngles()
    doAssert a.eq(b)

  # Test non-polar cases
  for i in 0 .. 1000:
    let
      xr = rand(-89.9f .. 89.9f).toRadians
      yr = rand(-180 .. 180).toRadians
      zr = rand(-180 .. 180).toRadians
      b = vec3(xr, yr, zr)
      m = fromAngles(b)
      a = m.toAngles()
    doAssert a.eq(b)

  # Test polar and non-rotated cases
  for i in 0 .. 1000:
    let
      xr = sample([-90, 90]).toRadians
      yr = rand(-180 .. 180).toRadians
      zr = 0f
      b = vec3(xr, yr, zr)
      m = fromAngles(b)
      a = m.toAngles()
    doAssert a.eq(b)

  # Test polar and crazy rotated cases
  for i in 0 .. 1000:
    let
      xr = sample([-90, 90]).toRadians
      yr = rand(-180 .. 180).toRadians
      zr = rand(-180 .. 180).toRadians
      b = vec3(xr, yr, zr)
      m = fromAngles(b)
      a = m.toAngles()

    doAssert abs(angleBetween(a.x, b.x)) < 0.001
    if xr > 0:
      doAssert abs(angleBetween(a.y, b.y + b.z)) < 0.001
    else:
      doAssert abs(angleBetween(a.y, b.y - b.z)) < 0.001

block:
  # Test for https://github.com/treeform/vmath/issues/73
  template gen2DTestsFor(constructor: untyped): void =
    doAssert angle(constructor(1, 0), constructor(1, 0)) ~= 0
    doAssert angle(constructor(1, 1), constructor(-1, -1)) ~= Pi
    doAssert angle(constructor(1, 0), constructor(0, 1)) ~= Pi/2
    doAssert angle(constructor(1, 0), constructor(-1, 0)) ~= Pi
    doAssert angle(constructor(1, 1), constructor(1, -1)) ~= Pi/2

    # Edge cases:
    doAssert angle(constructor(0, 0), constructor(1, 0)).isNaN()

  gen2DTestsFor vec2
  gen2DTestsFor dvec2

  template gen3DTestsFor(constructor: untyped): void =
    doAssert angle(constructor(1, 0, 0), constructor(1, 0, 0)) ~= 0
    doAssert angle(constructor(1, 1, 1), constructor(-1, -1, -1)) ~= Pi
    doAssert angle(constructor(1, 0, 0), constructor(0, 1, 0)) ~= Pi/2
    doAssert angle(constructor(1, 0, 0), constructor(-1, 0, 0)) ~= Pi
    doAssert angle(constructor(1, 1, 1), constructor(1, -1, 1)) ~= arccos(1/3)
    doAssert angle(constructor(1, 0, 0), constructor(0, 0, 1)) ~= Pi/2
    doAssert angle(constructor(1, 1, 1), constructor(-1, -1, 1)) ~= arccos(-1/3)

    # Edge cases:
    doAssert angle(vec3(0, 0, 0), vec3(1, 0, 0)).isNaN()

  gen3DTestsFor vec3
  gen3DTestsFor dvec3

echo "test finished successfully"



================================================
FILE: tools/genswizzle.nim
================================================
import 
  std/strformat

var
  swizzles = @["xyzw", "rgba", "stpq"]
  code = ""

code.add "# Generated by tools/genswizzle - don't edit manually.\n"

for swizzle in swizzles[1 .. ^1]:
  code.add "\n# 1 x " & swizzle & "\n"
  for i1, s1 in swizzle:
    code.add &"proc {s1}*[T](a: GVec234[T]): T = a[{i1}]\n"
  for i1, s1 in swizzle:
    code.add &"proc `{s1}=`*[T](a: var GVec234[T], b: T) = a[{i1}] = b\n"

for swizzle in swizzles:
  code.add "\n# 2 x " & swizzle & "\n"
  for i1, s1 in swizzle:
    for i2, s2 in swizzle:
      code.add &"proc {s1}{s2}*[T](a: GVec234[T]): GVec2[T] = gvec2(a[{i1}], a[{i2}])\n"
  for i1, s1 in swizzle:
    for i2, s2 in swizzle:
      code.add &"proc `{s1}{s2}=`*[T](a: var GVec234[T], b: GVec2[T]) = (let b = b; a[{i1}] = b.x; a[{i2}] = b.y)\n"

for swizzle in swizzles:
  code.add "\n# 3 x " & swizzle & "\n"
  for i1, s1 in swizzle:
    for i2, s2 in swizzle:
      for i3, s3 in swizzle:
        code.add &"proc {s1}{s2}{s3}*[T](a: GVec234[T]): GVec3[T] = gvec3(a[{i1}], a[{i2}], a[{i3}])\n"
  for i1, s1 in swizzle:
    for i2, s2 in swizzle:
      for i3, s3 in swizzle:
        code.add &"proc `{s1}{s2}{s3}=`*[T](a: var GVec234[T], b: GVec3[T]) = (let b = b; a[{i1}] = b.x; a[{i2}] = b.y; a[{i3}] = b.z)\n"

for swizzle in swizzles:
  code.add "\n# 4 x " & swizzle & "\n"
  for i1, s1 in swizzle:
    for i2, s2 in swizzle:
      for i3, s3 in swizzle:
        for i4, s4 in swizzle:
          code.add &"proc {s1}{s2}{s3}{s4}*[T](a: GVec234[T]): GVec4[T] = gvec4(a[{i1}], a[{i2}], a[{i3}], a[{i4}])\n"
  for i1, s1 in swizzle:
    for i2, s2 in swizzle:
      for i3, s3 in swizzle:
        for i4, s4 in swizzle:
          code.add &"proc `{s1}{s2}{s3}{s4}=`*[T](a: var GVec234[T], b: GVec4[T]) = (let b = b; a[{i1}] = b.x; a[{i2}] = b.y; a[{i3}] = b.z; a[{i4}] = b.w)\n"

writeFile("src/vmath/swizzle.nim", code)


